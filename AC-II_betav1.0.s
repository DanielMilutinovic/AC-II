;AC-II beta v1.0 (port of AriCalculator beta v1.0 to XEP100) 

;matrix keypad columns: Port P[0-5]
;matrix keypad rows: PT1AD0[0-7]

;ST7565 GLCD:Port A.0
;            Port H[0-3]

;busy LED: Port E.0
;error LED: Port E.1

;make the following changes before uploading to actual device:
;1) comment out FCS1 at beginning of main (push a value onto the stack in FCS) 
;2) comment out FCS2 and uncomment AD 1 in PORTinit subroutine
;3) comment out FCS3 in sendByte subroutine
;4) comment out FCS4 in RTIisr interrupt
;5) comment out FCS5 in scanKey subroutine (breakpoint is placed here in FCS)
;6) comment out FCS6 in M6
;7) comment out FCS7 in M5
;8) comment out FCS8 in M4
;9) comment out FCS9 in M3
;10) comment out FCS10 in M2
;11) comment out FCS11 in M1
;12) comment out FCS12 at beginning of main (enter a program in FCS)
;13) comment out FCS13 in dbgPrg
;14) comment out FCS14 in dbgPrg

              ABSENTRY entry                     ;for absolute assembly: mark this as application entry point
                                                 ;this is required for Full Chip Simulation mode    
;include definitions
 
              INCLUDE 'derivative.inc'
              
;************************************************ 
;*                  Definitions                 *
;************************************************

BIT0          EQU %00000001
BIT1          EQU %00000010
BIT2          EQU %00000100
BIT3          EQU %00001000
BIT4          EQU %00010000
BIT5          EQU %00100000
BIT6          EQU %01000000
BIT7          EQU %10000000

endPrg        EQU $7A                            ;122 = code to mark the end of the program
noOperation   EQU $B8                            ;184 = code for NOP program instruction

lenExpBytes   EQU $01                            ;length of exponent in bytes
lenManBytes   EQU $08                            ;length of mantissa in bytes
lenFPNBytes   EQU $09                            ;the total length of the FPN in bytes
lenManBBytes  EQU $07                            ;length of the mantissa of the binary value of the FPN in bytes 
                                                 ;(used in the multiplication subroutine)
lenManBBytes2 EQU $0E                            ;the length of memory allocated for the shift and add algorithm
                                                 ;in the multiplication subroutine. It is equal to 2 * lenManBBytes
lenManBBytes3 EQU $0D                            ;the actual length of the product obtained in the multiplication
                                                 ;subroutine                                             
lenMan        EQU $10                            ;length of mantissa in digits
              
maxLenExp     EQU $02                            ;maximum number of digits that can be entered in the exponent
maxLenMan     EQU $0A                            ;maximum number of digits that can be entered in the mantissa

us_start      EQU $20AB                          ;user stack start address

ms_end        EQU $20B4                          ;memory stack end address. The memory stack is used to store values.
                                                 ;usPointer initially points here
                                                 
m_K           EQU $213B                          ;K mantissa memory start address
m_KEnd        EQU $2142                          ;K mantissa memory end address

ms_start_LS   EQU $219D                          ;prgCounter initially points here

ps_start      EQU $219E                          ;program stack start address
ps_end        EQU $319D                          ;program stack end address
ps_retAddr    EQU $317E                          ;start address of stack to store address to return to after  
                                                 ;subroutine is executed (up to 16 subroutine nests)

stopgap       EQU $319E                          ;initialised with endPrg to terminate program execution  

m_com         EQU $319F                          ;command line mantissa memory start address
e_com         EQU $31A7                          ;command line exponent memory start address
m_comEnd      EQU $31A6                          ;command line mantissa memory end address

m_a           EQU $31A8                          ;FPN_a mantissa memory start address
e_a           EQU $31B0                          ;FPN_a exponent memory start address
m_aEnd        EQU $31AF                          ;FPN_a mantissa memory end address                          

m_b           EQU $31B1                          ;FPN_b mantissa memory start address
e_b           EQU $31B9                          ;FPN_b exponent memory start address
m_bEnd        EQU $31B8                          ;FPN_b mantissa memory end address                          

m_c           EQU $31BA                          ;FPN_c mantissa memory start address
endm_c        EQU $31C0                          ;FPN_c mantissa memory end address

m_d           EQU $31C1                          ;FPN_d mantissa memory start address
endm_d        EQU $31C7                          ;FPN_d mantissa memory end address

m_e           EQU $31C8                          ;FPN_e mantissa memory start address
endm_e        EQU $31CE                          ;FPN_e mantissa memory end address 
                                                 
m_f           EQU $31CF                          ;FPN_f mantissa memory start address
e_f           EQU $31D7                          ;FPN_f exponent memory start address
m_fEnd        EQU $31D6                          ;FPN_f mantissa memory end address 

m_g           EQU $31D8                          ;FPN_g mantissa memory start address
e_g           EQU $31E0                          ;FPN_g exponent memory start address
m_gEnd        EQU $31DF                          ;FPN_g mantissa memory end address

m_h           EQU $31E1                          ;FPN_h mantissa memory start address
e_h           EQU $31E9                          ;FPN_h exponent memory start address
m_hEnd        EQU $31E8                          ;FPN_h mantissa memory end address
                                                 
m_i           EQU $31EA                          ;FPN_i mantissa memory start address
e_i           EQU $31F2                          ;FPN_i exponent memory start address
m_iEnd        EQU $31F1                          ;FPN_i mantissa memory end address

x0            EQU $31F3                          ;start of first row of general storage stack

im_end        EQU $3301                          ;imaginary number stack end address
im_start      EQU $33AC                          ;imaginary number stack start address

ds_end        EQU $33B5                          ;denominator stack end address
ds_start      EQU $3460                          ;denominator stack start address

rnSeed        EQU $3469                          ;start of random number seed
rnSeedEnd     EQU $3470                          ;end of random number seed
                                                 
VARstart      EQU $3471                          ;absolute address to place variable data
ROMstart      EQU $4000                          ;absolute address to place code/constant data

wFont         EQU $08                            ;width of command line/stack character font
wFontSL       EQU $06                            ;width of status line character font                                                 

;*************************************************
;*            Variable Data Section              *
;*************************************************
              ORG VARstart                       ;main program, mathematical subroutines and basic mathematical
                                                 ;functions, as well as non-mathematical subroutines and functions
                                                 ;accessed during program execution (stack operations, PICK and GOTO
                                                 ;instructions)
                                                 ;sendByte and sendData subroutines are here instead of page 38 with
                                                 ;other display related subroutines because they are frequently used  

colNumber     DS.B 1                             ;the number of data bytes to be sent to the display 
cursorValue   DS.B 1                             ;either #$00 or #$FF - used to turn the cursor off/on
counter1      DS.B 1                             ;general purpose counter for use in loops
counter2      DS.B 1                             ;general purpose counter for use in loops
counter3      DS.B 1                             ;general purpose counter for use in loops
counter4      DS.B 1                             ;general purpose counter for use in loops
cursorRate    DS.W 1                             ;used to determine the rate at which the cursor blinks
diffExp       DS.B 1                             ;diffExp = e_a - e_b (used in addFPN subroutine)

flag1         DS.B 1                             ;flag1.0 = shift - set when shift key pressed
                                                 ;flag1.1 = keyFound - set when the pressed key has been found
                                                 ;flag1.2 = keyPressed - set when a key has been pressed
                                                 ;flag1.3 = sci - set when "Dec" is pressed and held
                                                 ;flag1.4 = MEM - set/cleared when "MEM" pressed
                                                 ;flag1.5 = sub - set when "-" pressed
                                                 ;flag1.6 = grad - set when grad mode is selected
                                                 ;flag1.7 = curOff - set to turn the cursor off                                                  
                                                                                                  
flag2         DS.B 1                             ;flag2.0 = expPressed - set when the exponent entry field is active
                                                 ;flag2.1 = dpPressed - set when the decimal point key is pressed
                                                 ;flag2.2 = zf - set when the first digit on the command line is 0
                                                 ;flag2.3 = expNeg - set when the exponent is negative
                                                 ;flag2.4 = manNeg - set when the command line mantissa is negative
                                                 ;flag2.5 = oFlow - set when the FPN overflows
                                                 ;flag2.6 = uFlow - set when the FPN underflows
                                                 ;flag2.7 = usPDec - set when the user stack pointer has been 
                                                 ;decremented
                                                 
flag3         DS.B 1                             ;flag3.0 = gFlag0 - generic flag 0 (used in x^y/x^(1/y) and Enter)
                                                 ;flag3.1 = rcl - set when "RCL" is pressed
                                                 ;flag3.2 = hex - set when "Hex" pressed 
                                                 ;flag3.3 = hex/bin - set when in either hexadecimal or binary mode                                                
                                                 ;flag3.4 = sto - set when "STO" is pressed
                                                 ;flag3.5 = codeInput - set when instructions are entered via code  
                                                 ;flag3.6 = prg - set when in program edit/debug mode
                                                 ;flag3.7 = run - set when in program execution mode
                                                 
flag4         DS.B 1                             ;flag4.0 = bin - set when "Bin" pressed
                                                 ;flag4.1 = cpx - set when "CPX" folder selected
                                                 ;flag4.2 = ext - set when exact mode is selected
                                                 ;flag4.3 = alpha - set when shift is held
                                                 ;flag4.4 = rad - set when rad mode is selected
                                                 ;flag4.5 = time - set/cleared when "TME" pressed
                                                 ;flag4.6 = updtPrgScreen - set when the program stack is to be 
                                                 ;updated
                                                 ;flag4.7 = updtScreen - set when the status line, stack and command
                                                 ;line are to be updated

flag5         DS.B 1                             ;flag5.0 = ge (greater than or equal to) - set when FPN_a >= FPN_b 
                                                 ;flag5.1 = le (less than or equal to) - set when FPN_a <= FPN_b
                                                 ;flag5.2 =  
                                                 ;flag5.3 = incPrgCtr - cleared if prgCounter should not be 
                                                 ;incremented
                                                 ;flag5.4 = ip - set when the imaginary part is positive
                                                 ;flag5.5 = iz - set when the imaginary part is zero
                                                 ;flag5.6 = ABT - set/cleared when "ABT" pressed
                                                 ;flag5.7 = 2-adic - set when "Bin" is pressed and held                                                                                                                                                   
                                                 
keyNumber     DS.B 1                             ;the keypad number of the key pressed
keyNumber2    DS.B 1                             ;the keypad number of the key pressed copied here (debugging KEYNO->)
keyValue      DS.B 1                             ;the value (0-9) stored when one of the numerical keys is pressed
lenMemBytes   DS.B 1                             ;the length in bytes of the binary value to be multiplied by 10, 
                                                 ;used when updating the exponent and in the multiplication subroutine 
logbTen       DS.W 1                             ;the address of the logb (10) value used to find ld and ln
logValues     DS.W 1                             ;the address of the special values used in the 2^x, e^x and 10^x
                                                 ;subroutines
memAddr1      DS.W 1                             ;16-bit memory address
memAddr1_LSBY DS.W 1                             ;16-bit memory address
memAddr2      DS.W 1                             ;16-bit memory address
menu          DS.B 1                             ;user/program menu number
negLogValues  DS.W 1                             ;the address of the negative special values used in the 2^x, e^x and 
                                                 ;10^x subroutines
noDigDp       DS.B 1                             ;number of digits entered after the decimal point 
noDigExp      DS.B 1                             ;number of digits entered in the command line exponent (0-2)
noDigMan      DS.B 1                             ;number of digits entered in the command line mantissa (0-10)
noZero        DS.B 1                             ;number of leading zeros in a given mantissa
pageNumber    DS.B 1                             ;the current page number on the screen
prgCounter    DS.W 1                             ;points to the program stack level address, from
                                                 ;$219E to $319D (4kb)
prgCounterSt  DS.W 1                             ;used to determine program step number in dispPrgIstr ($219D)
prgCounterStM1
              DS.W 1                             ;equal to prgCounterSt - 1, so that 1 does not need to be subtracted
                                                 ;from D in GOTO instruction and JUMPTOSUBRTE (GOTO and JUMPSR), 
                                                 ;resulting in faster program execution
                                                 
prgStackPtr   DS.W 1                             ;points to the address to return to after subroutine is executed   
power         DS.B 1                             ;power = min (noZero - 1,diffExp), used in addFPN subroutine
savedY        DS.B 1                             ;the current Y coordinate is saved when need to return there
savedY2       DS.B 1
screenNumber  DS.B 1                             ;the number of the stack screen displayed  

tcntOvrflw    DS.W 1                             ;the number of times the timer overflows
tcntOvrflw2   DS.W 1                             ;the number of times tcntOvrflw overflows 
tcntRegStart  DS.W 1                             ;the value of TCNT when the timer is started
tcntRegEnd    DS.W 1                             ;the value of TCNT when the timer is stopped

usPointer     DS.W 1                             ;points to the user stack level address, from
                                                 ;$2000 to $20AB, giving a total of 18 levels 
Ycoord        DS.B 1                             ;the value of the current Y coordinate on the screen is stored  
                                                 ;as the display can't be read 

;************************************************
;*           Code/Constant Data Section         *
;************************************************
              ORG ROMstart                       ;main program, mathematical subroutines and basic mathematical
                                                 ;functions, as well as non-mathematical subroutines and functions
                                                 ;accessed during program execution (stack operations, PICK and GOTO
                                                 ;instructions)
                                                 ;sendByte and sendData subroutines are here instead of page FB with
                                                 ;other display related subroutines because they are frequently used
;*******************Main Program*****************
            
entry:        LDS #RAMEnd+1                      ;initialise stack pointer, RAMEnd = #0x3FFF (see MC9S12XEP100.inc)

              MOVB #$01,TIM_TSCR2                ;timer set with no interrupt & prescale factor = 2
              
              MOVB #$10,RTICTL                   ;initialise the Real Time Interrupt (RTI) for keypad scanning with 
                                                 ;fastest interrupt period
              
              CALL PORTinit                      ;initialise all ports
              
              CALL SPIinit                       ;initialise SPI0
                         
              CALL DISPinit                      ;initialise the ST7565 display
              
              CALL VARinit                       ;initialise variables
              
              CALL dispStatL                     ;display the status line on page 0 of the ST7565 GLCD
              
              CALL dispStack                     ;display the 5 stack level labels on pages 1 - 5
              
              CALL clrComL                       ;clear the command line (page 6)
              
              JSR clrComLMem                     ;clear command line memory
              
              CALL dispMenu                      ;display the menu on page 7
              
              LDAA #$B6

              BCLR PTH,#BIT0                     ;A0 = 0,send command

              JSR sendByte                       ;set to page 6
              
              MOVB #$08,Ycoord                    
              JSR setY                           ;set Ycoord and Y to 8, and A0 = 1 (send data)                          
              
              MOVW #$0001,cursorRate             			    
					    CLR cursorValue                    ;cursor immediately visible when calculator turned on
					    
					    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS1: enter values onto the user stack here
					                                       ;e.g. place "-1" on level 1
					    ;LDX #us_start      
              
              ;MOVB #$99,1,X+                     ;->
              ;MOVB #$99,1,X+
              ;MOVB #$99,1,X+
              ;MOVB #$99,1,X+
              ;MOVB #$99,1,X+
              ;MOVB #$99,1,X+
              ;MOVB #$99,1,X+
              ;MOVB #$99,1,X+                                           
                                                 
              ;MOVB #$00,0,X                      ;<-
              
              ;MOVW #$20AB,usPointer              ;1 value on the stack
					    
					    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					    
					    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS12: enter values onto the program stack here
					                                       
					    ;LDX #ps_start      
              
              ;MOVB #$6F,1,X+                     
              ;MOVB #$09,1,X+
              ;MOVB #$04,1,X+
              ;MOVB #$10,1,X+
              ;MOVB #$F3,1,X+                     
              ;MOVB #$03,1,X+
              ;MOVB #$03,1,X+
              ;MOVB #$00,1,X+
              ;MOVB #$0C,1,X+                     
              ;MOVB #$20,1,X+
              ;MOVB #$7A,1,X+
              ;MOVB #$0E,1,X+ 
              ;MOVB #$00,1,X+
              ;MOVB #$7A,1,X+  
					    
					    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                       
              CLI                                ;unmask interrupts
              
              BSET CRGINT,#BIT7                  ;enable RTI
              
loopforever:  BRA loopforever                    ;wait for RTI 

;*******************Subroutines******************

;absFPN: determine the absolute value of FPN_M1 and invert the manNeg flag if FPN_M1 < 0.

absFPN:       LDX memAddr1
              LDAA 0,X
              ANDA #$F0
              BEQ absFPN_1                       ;exit if FPN_M1 is non-negative 
              JSR negFPN                         ;otherwise negate FPN_M1 and invert manNeg flag
              LDAA flag2
              EORA #BIT4
              STAA flag2             

absFPN_1:     RTS

;addFPN: FPN_a + FPN_b -> FPN_a. The exponent of FPN_a must be greater than or equal to the exponent of FPN_b. 

addFPN:       BCLR flag2,#BIT4                   ;clear manNeg flag 
              MOVW #m_a,memAddr1
                            
              JSR absFPN                         ;set FPN_a to its absolute value
                            
              JSR lzMan                          ;determine number of leading 0's in |m_a| and store in noZero
              
              LDAA noZero
              CMPA #lenMan
              BNE addFPN_0                       ;branch if FPN_a <> 0
              
              MOVB e_b,e_a                       ;otherwise set e_a = e_b and add mantissas. This part is necessary
              BRA addFPN_7                       ;to avoid e.g. 10^-20 + 0 = 0                                                  

addFPN_0:     BRCLR flag2,#BIT4,addFPN_1         ;branch if manNeg flag not set 
              JSR negFPN                         ;otherwise restore FPN_a to its original value

addFPN_1:     LDAA noZero                        ;power = min (noZero - 1,diffExp)
              DECA
              CMPA diffExp
              BLO addFPN_2                       ;if noZero - 1 < diffExp, set power = noZero - 1
              MOVB diffExp,power                 ;otherwise power = diffExp
              BRA addFPN_3 
              
addFPN_2:     STAA power
              
addFPN_3:     TST power
              BEQ addFPN_5                       ;if power = 0 do not shift m_a left or change e_a
              
              MOVB power,counter3                ;multMan10 subroutine uses counter1 and counter2
                           
addFPN_4:     JSR multMan10                      ;multiply FPN_a by 10^power
              DEC e_a                            ;e_a decremented to preserve equality
              DEC counter3
              BNE addFPN_4
                                      
addFPN_5:     LDAA e_a
              CMPA e_b
              BEQ addFPN_7                       ;if e_a = e_b add m_a and m_b
                                              
              LDAA e_a
              SUBA e_b
              STAA diffExp                       ;otherwise e_a > e_b, so update diffExp = e_a - e_b
              
              MOVB diffExp,counter3              ;divMan10 subroutine uses counter1 and counter2
              
              MOVW #m_b,memAddr1
                            
addFPN_6:     JSR divMan10                       ;divide FPN_b by 10^diffExp with the remainder in A
              INC e_b                            ;e_b incremented to preserve equality              
              DEC counter3
              BNE addFPN_6
              
              CMPA #$05
              BLO addFPN_7                       ;if A < 5 add m_a and m_b
              
              JSR incFPN                         ;otherwise increment FPN_b first              
                            
addFPN_7:     MOVW #m_a,memAddr1
              JSR addMan                         ;add mantissa of FPN_a to mantissa of FPN_b and store the result
                                                 ;in FPN_a                            
              RTS

;addMan: adds the mantissa of FPN_a to that of FPN_b and stores the result in FPN_a

addMan:       LDX #m_aEnd                        ;X points to LS byte of mantissa of FPN_a
              
              LDY #m_bEnd                        ;Y points to LS byte of mantissa of FPN_b
              
              MOVB #lenManBytes,counter1
              
              LDAA 0,X
              ADDA 1,Y-
              DAA                                ;decimal adjust as BCD arithmetic is used
              STAA 1,X-
              
              DEC counter1
              
addMan_1:     LDAA 0,X
              ADCA 1,Y-
              DAA                                ;decimal adjust as BCD arithmetic is used
              STAA 1,X- 
              DEC counter1
              BNE addMan_1
              
              INX
              LDAA 0,X
              ANDA #$F0                
              BEQ addMan_2                       ;exit if the MS nibble of FPN_a = 0
              
              CMPA #$90
              BEQ addMan_2                       ;exit if the MS nibble of FPN_a = 9
              
              MOVW #m_a,memAddr1
              
              JSR divMan10                       ;otherwise overflow has occurred, so shift mantissa of FPN_a
                                                 ;one nibble right into A and increment e_a          
              INC e_a                          
              CMPA #$05
              BLO addMan_2                       ;exit if A is less than 5
              JSR incFPN                         ;otherwise increment FPN_a first                                           

addMan_2:     RTS

;addMan2: adds the mantissa of FPN_h to that of FPN_g and stores the result in FPN_h

addMan2:      LDX #m_hEnd                        ;X points to LS byte of mantissa of FPN_h
              
              LDY #m_gEnd                        ;Y points to LS byte of mantissa of FPN_g
              
              MOVB #lenManBytes,counter1
              
              LDAA 0,X
              ADDA 1,Y-
              DAA                                ;decimal adjust as BCD arithmetic is used
              STAA 1,X-
              
              DEC counter1
              
addMan2_1:    LDAA 0,X
              ADCA 1,Y-
              DAA                                ;decimal adjust as BCD arithmetic is used
              STAA 1,X- 
              DEC counter1
              BNE addMan2_1
              
              INX
              LDAA 0,X
              ANDA #$F0                
              BEQ addMan2_2                      ;exit if the MS nibble of FPN_h = 0
              
              CMPA #$90
              BEQ addMan2_2                      ;exit if the MS nibble of FPN_h = 9
              
              MOVW #m_h,memAddr1
              
              JSR divMan10                       ;otherwise overflow has occurred, so shift mantissa of FPN_h
                                                 ;one nibble right into A and increment e_h          
              INC e_h                          
              CMPA #$05
              BLO addMan2_2                      ;exit if A is less than 5
              JSR incFPN                         ;otherwise increment FPN_h first                                           

addMan2_2:    RTS

;addm_cTm_d: add 7-byte long binary value at m_c to 7-byte long binary value at m_d and stores the result at m_d 

addm_cTm_d:   LDX #m_d
              LDY #m_c

              LDAB #lenManBBytes
              DECB
              ABX                                ;X points to LS byte of m_d
              ABY                                ;Y points to LS byte of m_c
              
              STAB counter1                      ;counter1 = lenManBBytes - 1

              LDAA 0,X
              ADDA 1,Y-
              STAA 1,X-
              
addm_cTm_d_1: LDAA 0,X
              ADCA 1,Y-
              STAA 1,X-
              DEC counter1
              BNE addm_cTm_d_1  

              RTS 

;arccosFPN: find theta = FPN_f such that the cosine of theta = FPN_h (FPN_1)

arccosFPN:    MOVW #m_h,memAddr1
              JSR copyFPN                        ;FPN_h -> FPN_b
   
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_h -> FPN_a
              
              JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a
                                                 ;i.e. FPN_h ^ 2 -> FPN_a
                                                 
              JSR negFPN                         ;FPN_a = -FPN_h^2
              
              MOVB #$07,counter1
              LDX #m_b
              
              CLRA
              
arccosFPN_1:  STAA 1,X+                          ;FPN_b = 1 ->
              DEC counter1
              BNE arccosFPN_1
              
              MOVB #$01,1,X+                     
              
              CLR 0,X                            ;<-
              
              JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b
              
              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a, i.e. 1 - FPN_h^2 -> FPN_a
              
              JSR lzMan                          ;determine number of leading zeros in FPN_a
              
              LDAA #lenMan 
              
              JSR sqrtFPN                        ;find the square root of FPN_a and store the result in FPN_b
                                                 ;i.e. FPN_b = sqrt(1-FPN_h^2) 
                                                 
              MOVW #m_b,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = sqrt(1-FPN_h^2)
              
              MOVW #m_h,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = FPN_h
              
              MOVW #m_a,memAddr1
              
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BEQ arccosFPN_2                    ;branch if FPN_a = 0, since divFPN subroutine requires non-zero
                                                 ;dividend              
              JSR divFPN                         ;otherwise FPN_a/FPN_b -> FPN_a, 
                                                 ;i.e. sqrt(1-FPN_h^2)/FPN_h -> FPN_a              
arccosFPN_2:  MOVW #m_h,memAddr2
              JSR copyFPN                        ;sqrt(1-FPN_h^2)/FPN_h -> FPN_h
              
              JSR arctanFPN
              
              RTS                                              ;    

;arctanFPN: find theta = FPN_f such that the tangent of theta = FPN_h (FPN_1)   

arctanFPN:    LDX #m_a                           ;set X = FPN_a = 1 = 00 10 00 00 00 00 00 00 00 ->
              MOVB #$00,1,X+
              MOVB #$10,1,X+
              
              CLRA
              MOVB #07,counter1
arctanFPN_1:  STAA 1,X+
              DEC counter1
              BNE arctanFPN_1                    ;<-
              
              LDX #m_f                           ;set theta = FPN_f = 0 = 00 00 00 00 00 00 00 00 F3 ->

              MOVB #$08,counter1
arctanFPN_2:  STAA 1,X+
              DEC counter1
              BNE arctanFPN_2
              
              MOVB #$F3,0,X                      ;<-       

              MOVW #m_h,memAddr1

              JSR lzMan                          ;determine the number of leading zeros in Y = m_h
              LDAA #lenMan
              SUBA noZero
              DECA
              ADDA e_h                           ;A = e_h(s), the exponent of FPN_h when it is in scientific format. 
                                                 ;This determines by how many nibbles m_h needs to be shifted to 
                                                 ;the left and by how many nibbles m_a needs to be shifted to the 
                                                 ;right
                                                 
              BMI arctanFPN_6                    ;branch if e_h(s) < 0
              
              STAA counter3
              BEQ arctanFPN_4                    ;branch if e_h(s) = 0 (X does not need to be shifted)
              
              MOVW #m_a,memAddr1
arctanFPN_3:  JSR divMan10                       ;shift X e_h(s) nibbles to the right
              DEC counter3
              BNE arctanFPN_3
              
arctanFPN_4:  LDAA noZero
              DECA
              DECA
              STAA counter3
              BEQ arctanFPN_8                    ;branch if noZero - 2 = 0 (Y does not need to be shifted)
              
              MOVW #m_h,memAddr1 
              
              BMI arctanFPN_5_1                  ;branch if noZero - 2 < 0              
                         
arctanFPN_5:  JSR multMan10                      ;shift Y noZero - 2 nibbles to the left            
              DEC counter3
              BNE arctanFPN_5
              
              BRA arctanFPN_8
              
arctanFPN_5_1:NEG counter3

arctanFPN_5_2:JSR divMan10                       ;shift Y 2 - noZero nibbles to the right            
              DEC counter3
              BNE arctanFPN_5_2              
                        
              BRA arctanFPN_8
              
arctanFPN_6:  DECA
              DECA
              ADDA noZero
              STAA counter3                      ;counter3 = noZero - 2 + e_h(s)                         
                            
              BEQ arctanFPN_8                    ;branch if noZero - 2 + e_h(s) = 0 (Y does not need to be shifted)
              
              BMI arctanFPN_7_1                  ;branch if noZero - 2 + e_h(s) < 0              
                                                               
arctanFPN_7:  JSR multMan10                      ;shift Y noZero - 2 + e_h(s) nibbles to the left            
              DEC counter3
              BNE arctanFPN_7
              
              BRA arctanFPN_8 
              
arctanFPN_7_1:
              NEGA
              
              STAA counter3                      ;counter3 = 2 - noZero - e_h(s) > 0                              
arctanFPN_7_2:  
              JSR divMan10                       ;shift Y 2 - noZero - e_h(s) nibbles to the right            
              DEC counter3
              BNE arctanFPN_7_2
                                              
arctanFPN_8:  MOVW #m_a,memAddr1
              MOVW #m_g,memAddr2
              JSR copyMan                        ;m_g = m_a = X
              
              MOVW #m_g,memAddr1   

              MOVB counter3,counter4  
              TST counter3
              BEQ arctanFPN_11                   ;branch if K = counter3 = 0, i.e. if X does not need to be shifted              
              
arctanFPN_10: JSR divMan10                       ;otherwise shift X K nibbles to the right
              DEC counter4
              BNE arctanFPN_10

arctanFPN_11: MOVB #$08,counter1                 ;number of bytes to compare

              LDY #m_h
              LDX #m_g
              
arctanFPN_12: LDAA 1,Y+
              CMPA 1,X+
              BHI arctanFPN_14                   ;branch if m_h = Y > 10^-K * X = m_g
              BLO arctanFPN_13                   ;branch if m_h = Y < 10^-K * X = m_g
              DEC counter1
              BNE arctanFPN_12                   ;otherwise bytes are equal so compare the next byte
              BRA arctanFPN_14                   ;m_h = Y = 10^-K * X = m_g
              
arctanFPN_13: INC counter3                       ;increment K

              LDAA counter3
              CMPA #$0E
              LBEQ arctanFPN_18                  ;long branch if K = 14 

              JSR divMan10                       ;shift m_g 1 nibble to the right
              
              BRA arctanFPN_11                   ;test again
              
arctanFPN_14: LDX #tanAngles
	            LDAB counter3
	            INCB
              ASLB
              LDY B,X                            ;Y points to arctan(10^-(K+1))
              DEY                                ;Y points to LS byte of arctan(10^-K)

              LDX #m_fEnd                        ;X points to LS byte of m_f = theta
              
              MOVB #$07,counter1
              
              LDAA 0,X                           ;m_f + arctan(10^-K) -> m_f ->
              ADDA 1,Y-
              DAA
              STAA 1,X-
              
arctanFPN_15: LDAA 0,X
              ADCA 1,Y-
              DAA
              STAA 1,X-
              
              DEC counter1
              BNE arctanFPN_15                   ;<-
              
              MOVW #m_h,memAddr1
              MOVW #m_b,memAddr2
              JSR copyMan                        ;m_b = m_h = Y
              
              MOVW #m_g,memAddr1
              
              JSR negFPN                         ;negate m_g = 10^-K * X
              
              JSR addMan2                        ;m_h + m_g -> m_h
                                                 ;i.e. Y - 10^-K * X -> m_h = new Y
                                                 
              MOVW #m_b,memAddr1
                                                 
              MOVB counter3,counter4
              TST counter4
              BEQ arctanFPN_17                   ;do not shift Y if K = 0
              
arctanFPN_16: JSR divMan10                       ;otherwise multiply Y = m_b by 10^-K
              DEC counter4
              BNE arctanFPN_16
              
arctanFPN_17: JSR addMan                         ;m_a + m_b -> m_a
                                                 ;i.e. X + 10^-K * Y -> m_a = new X
              
              LBRA arctanFPN_8                   ;repeat              
              
arctanFPN_18: RTS       

;BCDToBin: converts the mantissa of FPN_M2 to binary and stores the result in FPN_M1

BCDToBin:     MOVB #lenManBBytes,counter1        ;set mantissa of FPN_M1 to 0 -> 
              CLRA
              LDX memAddr1
              
BCDToBin_0:   STAA 1,X+
              DEC counter1
              BNE BCDToBin_0                     ;<-     

              MOVB #lenManBytes,counter2         ;multBin10add subroutine uses counter1

              LDY memAddr2

BCDToBin_1:   LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              STAA keyValue                      ;keyValue = MS nibble of byte of FPN_M2

              JSR multBin10add                   ;multiply FPN_M1 by 10 and add keyValue

              LDAA 1,Y+

              ANDA #$0F
              STAA keyValue                      ;keyValue = LS nibble of byte of FPN_M2
              
              JSR multBin10add                   ;multiply FPN_M1 by 10 and add keyValue

              DEC counter2
              BNE BCDToBin_1
              
              RTS
              
;BCDToBin2: converts the mantissa of FPN_M2 to binary and stores the result in FPN_M1

BCDToBin2:    MOVB #lenManBytes,counter1        ;set mantissa of FPN_M1 to 0 -> 
              CLRA
              LDX memAddr1
              
BCDToBin2_0:  STAA 1,X+
              DEC counter1
              BNE BCDToBin2_0                     ;<-     

              MOVB #lenManBytes,counter2         ;multBin10add subroutine uses counter1

              LDY memAddr2

BCDToBin2_1:  LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              STAA keyValue                      ;keyValue = MS nibble of byte of FPN_M2

              JSR multBin10add                   ;multiply FPN_M1 by 10 and add keyValue

              LDAA 1,Y+

              ANDA #$0F
              STAA keyValue                      ;keyValue = LS nibble of byte of FPN_M2
              
              JSR multBin10add                   ;multiply FPN_M1 by 10 and add keyValue

              DEC counter2
              BNE BCDToBin2_1
              
              RTS 

;BinToBCD: convert the 13-byte binary value starting in m_d,m_e to BCD and store the result in m_e, m_d and
;m_c

BinToBCD:     MOVW #Ten29End,memAddr2            ;memAddr2 = address of LS byte of 10^29
              
              JSR placeValue                     ;determine power of ten place value
              
              PSHB                               ;push the power of ten place value onto the stack
              
              MOVW #Ten28End,memAddr2            ;memAddr2 = address of LS byte of 10^28
              
              JSR placeValue                     
              
              PSHB                               
              
              MOVW #Ten27End,memAddr2            ;memAddr2 = address of LS byte of 10^27
              
              JSR placeValue                     
              
              PSHB                               
              
              MOVW #Ten26End,memAddr2            ;memAddr2 = address of LS byte of 10^26
              
              JSR placeValue                     
              
              PSHB                               
              
              MOVW #Ten25End,memAddr2            ;memAddr2 = address of LS byte of 10^25
              
              JSR placeValue                    
              
              PSHB                               
              
              MOVW #Ten24End,memAddr2            ;memAddr2 = address of LS byte of 10^24
              
              JSR placeValue                     
              
              PSHB                               
              
              MOVW #Ten23End,memAddr2            ;memAddr2 = address of LS byte of 10^23
              
              JSR placeValue                     
              
              PSHB                               
              
              MOVW #Ten22End,memAddr2            ;memAddr2 = address of LS byte of 10^22
              
              JSR placeValue                     
              
              PSHB                               
              
              MOVW #Ten21End,memAddr2            ;memAddr2 = address of LS byte of 10^21
              
              JSR placeValue                     
              
              PSHB                               
              
              MOVW #Ten20End,memAddr2            ;memAddr2 = address of LS byte of 10^20
              
              JSR placeValue                     
              
              PSHB                               
              
              MOVW #Ten19End,memAddr2            ;memAddr2 = address of LS byte of 10^19
              
              JSR placeValue                     
              
              PSHB                               
              
              MOVW #Ten18End,memAddr2            ;memAddr2 = address of LS byte of 10^18
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten17End,memAddr2            ;memAddr2 = address of LS byte of 10^17
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten16End,memAddr2            ;memAddr2 = address of LS byte of 10^16
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten15End,memAddr2            ;memAddr2 = address of LS byte of 10^15
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten14End,memAddr2            ;memAddr2 = address of LS byte of 10^14
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten13End,memAddr2            ;memAddr2 = address of LS byte of 10^13
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten12End,memAddr2            ;memAddr2 = address of LS byte of 10^12
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten11End,memAddr2            ;memAddr2 = address of LS byte of 10^11
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten10End,memAddr2            ;memAddr2 = address of LS byte of 10^10
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten9End,memAddr2             ;memAddr2 = address of LS byte of 10^9
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten8End,memAddr2             ;memAddr2 = address of LS byte of 10^8
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten7End,memAddr2             ;memAddr2 = address of LS byte of 10^7
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten6End,memAddr2             ;memAddr2 = address of LS byte of 10^6
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten5End,memAddr2             ;memAddr2 = address of LS byte of 10^5
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten4End,memAddr2             ;memAddr2 = address of LS byte of 10^4
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten3End,memAddr2             ;memAddr2 = address of LS byte of 10^3
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten2End,memAddr2             ;memAddr2 = address of LS byte of 10^2
              
              JSR placeValue
              
              PSHB
              
              MOVW #Ten1End,memAddr2             ;memAddr2 = address of LS byte of 10^1
              
              JSR placeValue
              
              LDX #endm_e                        ;X points to the LS byte of m_e
              
              ASLB
              ASLB
              ASLB
              ASLB
              
              ADDB 0,X
              STAB 1,X-                          ;LS byte of m_e = 10's,1's of product
              
              MOVB #lenManBBytes2,counter1
                                         
BinToBCD_1:   PULB                               ;fill in m_e,m_d and part of m_c 
              STAB 0,X
              PULB
              ASLB
              ASLB
              ASLB
              ASLB
              ADDB 0,X
              STAB 1,X-
              
              DEC counter1
              BNE BinToBCD_1

              RTS             

;BinToBCD2: convert the 7-byte binary value in m_e to BCD and store the result in the mantissa of FPN_a

BinToBCD2:    MOVW #Ten14End2,memAddr2           ;memAddr2 = address of LS byte of 10^14
              
              JSR placeValue2                    ;determine power of ten place value
              
              PSHB                               ;push the power of ten place value onto the stack
              
              MOVW #Ten13End2,memAddr2           ;memAddr2 = address of LS byte of 10^13
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten12End2,memAddr2           ;memAddr2 = address of LS byte of 10^12
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten11End2,memAddr2           ;memAddr2 = address of LS byte of 10^11
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten10End2,memAddr2           ;memAddr2 = address of LS byte of 10^10
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten9End2,memAddr2            ;memAddr2 = address of LS byte of 10^9
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten8End2,memAddr2            ;memAddr2 = address of LS byte of 10^8
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten7End2,memAddr2            ;memAddr2 = address of LS byte of 10^7
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten6End2,memAddr2            ;memAddr2 = address of LS byte of 10^6
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten5End2,memAddr2            ;memAddr2 = address of LS byte of 10^5
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten4End2,memAddr2            ;memAddr2 = address of LS byte of 10^4
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten3End2,memAddr2            ;memAddr2 = address of LS byte of 10^3
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten2End2,memAddr2            ;memAddr2 = address of LS byte of 10^2
              
              JSR placeValue2
              
              PSHB
              
              MOVW #Ten1End2,memAddr2            ;memAddr2 = address of LS byte of 10^1
              
              JSR placeValue2
              
              PSHB                               ;10's place value pushed onto the stack
              
              LDX #endm_e                        ;X points to the LS byte of m_e
              
              LDAA 0,X                           ;A = 1's place value
              
              LDX #m_aEnd                        ;X points to LS byte of mantissa of FPN_a             
                            
              STAA 0,X
              
              MOVB #lenManBBytes,counter1
                                         
BinToBCD2_1:  PULA                               ;fill in the remainder of FPN_a
              ASLA
              ASLA
              ASLA
              ASLA
              ADDA 0,X
              STAA 1,X-
              PULA              
              STAA 0,X
              
              DEC counter1
              BNE BinToBCD2_1

              RTS

;clearPage: clear the current page on the ST7565 GLCD
                                                 
clearPage:    CLR Ycoord
              JSR setY                           ;sets Y = 0 and A0 = 1 

              CLRA
              
              MOVB #$80,colNumber                ;colNumber = 128,index for number of columns cleared 
					    
clearPage_1:  JSR sendByte                       ;blank the column

              DEC colNumber                     
              BNE clearPage_1                    
              
              RTS

;cmpExp: compare exponents of FPN_1 and FPN_2. FPN with larger exponent is copied to m_a and the other to m_b
     
cmpExp:       LDX usPointer
              LDAB #lenManBytes
              ABX                                ;X = usPointer + lenManBytes = e_1

              TFR X,Y
              INY
              PSHY                               ;Stack = usPointer + lenFPNBytes = FPN_2
              ABY                                ;Y = FPN_2 + lenManBytes = e_2         
              
              LDAA 0,X
              SUBA 0,Y
              BGT cmpExp_1                       ;e_1 > = e_2 (2's complement) -> FPN_1 copied to m_a, FPN_2 to m_b 
              
              MOVW usPointer,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;otherwise FPN_1 copied to m_b, FPN_2 to m_a
              
              PULY
              STY memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN
              
              BRA cmpExp_2             
              
cmpExp_1:     MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        
              
              PULY
              STY memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN     

cmpExp_2:     LDAA e_a
              SUBA e_b
              STAA diffExp
                           
              RTS
              
;cmpExpIm: compare exponents of FPN_1_imaginary and FPN_2_imaginary. FPN with larger exponent is copied to m_a and 
;the other to m_b
     
cmpExpIm:     LDD usPointer
              ADDD #$1301
              PSHD                               ;address of FPN_1 imaginary pushed onto the stack
              ADDD #lenManBytes 
              TFR D,X                            ;X points to e_1_imaginary

              TFR X,Y
              INY
              PSHY                               ;address of FPN_2_imaginary is pushed onto the stack
              LDAB #lenManBytes 
              ABY                                ;Y points to e_2_imaginary
              
              LDAA 0,X
              SUBA 0,Y
              BGT cmpExpIm_1                     ;e_1_imaginary > = e_2_imaginary (2's complement) -> FPN_1_imaginary
                                                 ;copied to m_a, FPN_2_imaginary to m_b              
              PULY
              STY memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;otherwise FPN_1_imaginary copied to m_b, FPN_2_imaginary to m_a
              
              PULD
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN
              
              BRA cmpExpIm_2             
              
cmpExpIm_1:   PULY
              STY memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN    

              PULD
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN

cmpExpIm_2:   LDAA e_a
              SUBA e_b
              STAA diffExp
                           
              RTS
              
;cmpExp_ab: compare exponents of FPN_a and FPN_b. FPN with larger exponent is copied to FPN_a and the other to FPN_b
     
cmpExp_ab:    LDAA e_a
              SUBA e_b
              BPL cmpExp_ab_1                    ;branch since e_a >= e_b 
              
              MOVW #m_a,memAddr1                 ;otherwise swap FPN_a and FPN_b ->
              MOVW #m_c,memAddr2
              JSR copyFPN                        ;FPN_a copied to FPN_c
              
              MOVW #m_b,memAddr1                 
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_b copied to FPN_a
              
              MOVW #m_c,memAddr1                 
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_c (= FPN_a) copied to FPN_b               

cmpExp_ab_1:  LDAA e_a
              SUBA e_b
              STAA diffExp
                           
              RTS

;calcDpt: calculate the depth (i.e. number of levels) of the user stack and store it in A

calcDpt:      LDD #ms_end 
              SUBD usPointer
              
              LDX #lenFPNBytes
              
              IDIV                               ;D / X -> X, remainder -> D
              
              PSHX                               
              INS
              PULA                               ;A = stack depth 
              
              RTS 

;chkCom: negate the mantissa/exponent entered on the command line if required and check for overflow and underflow  

chkCom:       MOVW #m_com,memAddr1 
              
              BRCLR flag2,#BIT4,chkCom_1                         
              JSR negFPN                         ;negate m_com if manNeg flag set
                                     
chkCom_1:     BRCLR flag2,#BIT3,chkCom_2
              NEG e_com                          ;negate e_com if expNeg flag set 
              
chkCom_2:     LDAA e_com                         ;subtract noDigDp from e_com and store the result in e_com
              SUBA noDigDp
              STAA e_com
             
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE chkCom_3                       ;branch if m_com <> 0  
              CLR e_com                          ;otherwise m_com = 0 so clear e_com (in case user enters e.g. 0 50)
              BRA chkCom_4
              
chkCom_3:     JSR chkOFPN                        ;check the command line value for overflow

              JSR chkUFPN                        ;check the command line value for underflow              
              
chkCom_4:     RTS                               

;chkExp: check the exponents prior to multiplication/division and set the oFlow and uFlow flags accordingly

chkExp:       BCLR flag2,#BIT5                   ;clear oFlow flag
              BCLR flag2,#BIT6                   ;clear uFlow flag
              BCLR flag2,#BIT3                   ;clear expNeg flag
              
              LDAA e_a
              BPL chkExp_1                       ;branch if e_a >= 0
              
              LDAA e_b
              BPL chkExp_6                       ;e_a < 0 and e_b >= 0 , so -99 =< e_a + e_b <= 98 -> exit
              
              BSET flag2,#BIT3                   ;otherwise e_a < 0 and e_b < 0 so set expNeg flag and NEG e_a & e_b
              NEG e_a
              NEG e_b
              BRA chkExp_2
              
chkExp_1:     LDAA e_b
              BPL chkExp_2                       ;e_a >= 0 and e_b >= 0
              BRA chkExp_6                       ;otherwise e_a >= 0 and e_b < 0, so -99 =< e_a + e_b <= 98 -> exit                                                   
              
chkExp_2:     LDAA e_a
              ADDA e_b                           ;A = e_a + e_b (unsigned)
              BRCLR flag2,#BIT3,chkExp_5         ;branch if e_a,e_b both positive
              CMPA #$80                  
              BLS chkExp_4                       ;if e_a,e_b both negative and e_a + e_b >= -128 then restore 
                                                 ;e_a and e_b to their original values and exit
              BSET flag2,#BIT6                   ;otherwise set uFlow flag, increment usPointer and set FPN_1 to 0
                                                 ;before exiting
              LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer
              LDX usPointer
              
              MOVB #lenFPNBytes,counter1
              CLRA
              
chkExp_3:     STAA 1,X+
              DEC counter1
              BNE chkExp_3
              
chkExp_4:     NEG e_a
              NEG e_b
              BRA chkExp_6
              
chkExp_5:     CMPA #$63
              BLS chkExp_6                       ;exit if e_a,e_b both positive and e_a + e_b <= 99
              BSET flag2,#BIT5                   ;otherwise set the oFlow before exiting          
              
chkExp_6:     RTS

;chkOFPN: checks FPN_M1 and sets the oFlow flag if overflow occurs. 

chkOFPN:      BCLR flag2,#BIT5                   ;clear oFlow flag  
              BCLR flag2,#BIT4                   ;assume FPN_M1 is positive
                            
              JSR absFPN                         ;set FPN_M1 to its absolute value
              
              JSR lzMan                          ;determine the number of leading zeros in mantissa
              
              BRCLR flag2,#BIT4,chkOFPN_1
              
              JSR negFPN                         ;return mantissa to original value if it was negative                                                   
              
chkOFPN_1:    LDX memAddr1                             
              LDAB #lenManBytes
              ABX                                ;X points to the exponent of FPN_M1 

              LDAA 0,X
              ADDA #lenMan
              SUBA noZero                        ;A = exponent + lenMan - noZero 
              
              CMPA #$64
              BLE chkOFPN_2                      ;exit if exponent + lenMan - noZero <= 100
              BSET flag2,#BIT5                   ;otherwise set the oFlow flag before exiting
                                                        
chkOFPN_2:    RTS

;chkUFPN: checks FPN_M1 and sets it to 0 if underflow occurs. 
;Note: any call to chkUFPN must occur immediately after calling chkOFPN as it is assumed 
;A = exponent + lenMan - noZero (see chkOFPN subroutine) 

chkUFPN:      CMPA #$9E
              BGE chkUFPN_2                      ;exit if exponent + lenMan - noZero >= -98
              
              MOVB #lenFPNBytes,counter1         ;otherwise underflow so set FPN_M1 to 0 
              CLRA
              LDX memAddr1
              
chkUFPN_1:    STAA 1,X+
              DEC counter1
              BNE chkUFPN_1
               
chkUFPN_2:    RTS

;clrComLMem: clears command line memory and related flags and variables 

clrComLMem:   CLRA
              LDX #m_com
              MOVB #lenFPNBytes,counter1              
              
clrComLMem_1: STAA 1,X+                          ;clear command line memory 
              DEC counter1
              BNE clrComLMem_1
              
              CLR flag2                          ;clear all related flags and variables
              CLR noDigMan
              CLR noDigExp
              CLR noDigDp
              
              RTS
              
;cmdToBCD: convert the 7-byte binary m_com value to BCD and store the result in m_com

cmdToBCD:     MOVW #Ten16End2,memAddr2           ;memAddr2 = address of LS byte of 10^16
              
              JSR placeValue3
              
              PSHB

              MOVW #Ten15End2,memAddr2           ;memAddr2 = address of LS byte of 10^15
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten14End2,memAddr2           ;memAddr2 = address of LS byte of 10^14
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten13End2,memAddr2           ;memAddr2 = address of LS byte of 10^13
              
              JSR placeValue3
              
              PSHB    

              MOVW #Ten12End2,memAddr2           ;memAddr2 = address of LS byte of 10^12
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten11End2,memAddr2           ;memAddr2 = address of LS byte of 10^11
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten10End2,memAddr2           ;memAddr2 = address of LS byte of 10^10
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten9End2,memAddr2            ;memAddr2 = address of LS byte of 10^9
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten8End2,memAddr2            ;memAddr2 = address of LS byte of 10^8
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten7End2,memAddr2            ;memAddr2 = address of LS byte of 10^7
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten6End2,memAddr2            ;memAddr2 = address of LS byte of 10^6
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten5End2,memAddr2            ;memAddr2 = address of LS byte of 10^5
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten4End2,memAddr2            ;memAddr2 = address of LS byte of 10^4
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten3End2,memAddr2            ;memAddr2 = address of LS byte of 10^3
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten2End2,memAddr2            ;memAddr2 = address of LS byte of 10^2
              
              JSR placeValue3
              
              PSHB
              
              MOVW #Ten1End2,memAddr2            ;memAddr2 = address of LS byte of 10^1
              
              JSR placeValue3
              
              PSHB                               ;10's place value pushed onto the stack
              
              LDX #m_comEnd                      ;X points to the LS byte of m_com              
              
              MOVB #$08,counter1
                                     
cmdToBCD_1:   PULA                               ;fill in the remainder of m_com
              ASLA
              ASLA
              ASLA
              ASLA
              ADDA 0,X
              STAA 1,X-
              
              PULA              
              STAA 0,X              
              
              DEC counter1
              BNE cmdToBCD_1

              RTS

;cmdToBCD2: convert the 2-adic m_com value to BCD and store the numerator in FPN_1_numerator/m_a and the denominator 
;in FPN_1_denominator/m_b 

cmdToBCD2:    PSHD   

              ;clear m_a ->
              
              CLRA 
              MOVB #$09,counter1
              LDX #m_a
              
cmdToBCD2_5:  STAA 1,X+
              DEC counter1
              BNE cmdToBCD2_5
              
              ;<-
              
              ;set m_f = 1 ->
              
              MOVB #$09,counter1
              LDX #m_f
              
cmdToBCD2_6:  STAA 1,X+
              DEC counter1
              BNE cmdToBCD2_6
              
              LDX #m_fEnd
              MOVB #$01,0,X
              
              ;<-
              
              TST noDigDp
              BNE cmdToBCD2_25
              
              BRA cmdToBCD2_26                   ;otherwise there are no values after the tick so branch 
              
              ;set m_com = r = repeating part of 2-adic number and m_a = k = constant part ->
              
cmdToBCD2_25: MOVB noDigDp,counter1
              
cmdToBCD2_2:  MOVB #$07,counter2
              LDX #m_com
              
              ASR 1,X+                           ;shift m_com 1 bit to the right ->
              
cmdToBCD2_3:  ROR 1,X+
              DEC counter2
              BNE cmdToBCD2_3                    ;<-
              
              MOVB #$08,counter2
              LDX #m_a
              
cmdToBCD2_4:  ROR 1,X+                           ;ROR m_a so that LS bit of m_com is shifted into MS bit of m_a ->
              DEC counter2
              BNE cmdToBCD2_4                    ;<-
              
              DEC counter1                       ;repeat N times
              BNE cmdToBCD2_2
              
              ;<-
              
              ;transpose k to LS end of m_a ->
              
              MOVB noDigDp,counter1
              INC counter1
              CLC
              
cmdToBCD2_18: MOVB #$08,counter2
              LDX #m_aEnd
              
cmdToBCD2_19: ROL 1,X-                           ;shift m_a 1 bit to the left -> 
              DEC counter2
              BNE cmdToBCD2_19                   ;<-
              
              DEC counter1
              BNE cmdToBCD2_18                   ;repeat N times             
              
              ;<-
              
              ;determine k*2^m and 2^m ->
              
cmdToBCD2_26: MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = k
              
              LDAA noDigMan
              SUBA noDigDp
              STAA counter1                      ;counter1 = m = number of bits in r
              
cmdToBCD2_8:  LDX #m_aEnd
              MOVB #$07,counter2
              
              ASL 1,X-                           ;shift FPN_a 1 bit to the left ->
              
cmdToBCD2_7:  ROL 1,X-
              DEC counter2
              BNE cmdToBCD2_7                    ;<-
              
              LDX #m_fEnd
              MOVB #$07,counter2
              
              ASL 1,X-                           ;shift FPN_f 1 bit to the left ->
              
cmdToBCD2_9:  ROL 1,X-
              DEC counter2
              BNE cmdToBCD2_9                    ;<- 
              
              DEC counter1
              BNE cmdToBCD2_8                    ;repeat m times
              
              ;determine k*2^m - k and 2^m - 1 ->
              
              LDX #m_aEnd
              LDY #m_bEnd
              MOVB #$07,counter1
              
              LDAA 0,X                           ;FPN_a = k*2^m - k ->
              SUBA 1,Y-
              STAA 1,X-                   
              
cmdToBCD2_10: LDAA 0,X
              SBCA 1,Y-
              STAA 1,X-
              DEC counter1
              BNE cmdToBCD2_10                   ;<- 
              
              LDX #m_fEnd
              MOVB #$07,counter1
              
              LDAA 0,X                           ;FPN_f = 2*m - 1 ->
              SUBA #$01
              STAA 1,X-
                                          
cmdToBCD2_11: LDAA 0,X
              SBCA #$00
              STAA 1,X-
              DEC counter1
              BNE cmdToBCD2_11                   ;<-               
              
              ;<-
              
              ;determine r*2^N ->              
                            
cmdToBCD2_12: TST noDigDp
              BEQ cmdToBCD2_27                   ;do not shift if there are no digits after the tick 

              LDX #m_comEnd
              MOVB #$07,counter2
              
              ASL 1,X-                           ;shift m_com 1 bit to the left ->
              
cmdToBCD2_13: ROL 1,X-
              DEC counter2
              BNE cmdToBCD2_13                   ;<- 
              
              DEC noDigDp
              BNE cmdToBCD2_12                   ;repeat noDigDp = N times           
              
              ;<- 
              
              ;determine k*2^m - k - r*2^N and convert to BCD->
              
cmdToBCD2_27: LDX #m_aEnd
              LDY #m_comEnd
              MOVB #$07,counter1
              
              LDAA 0,X                           ;FPN_a = k*2^m - k - r*2^N ->
              SUBA 1,Y-
              STAA 1,X-                   
              
cmdToBCD2_14: LDAA 0,X
              SBCA 1,Y-
              STAA 1,X-
              DEC counter1
              BNE cmdToBCD2_14                   ;<-
              
              BCLR flag2,#BIT4                   ;clear manNeg flag
              
              LDX #m_a
              LDAA 0,X
              
              BPL cmdToBCD2_22                   ;branch if m_a >= 0
              
              MOVB #$08,counter1                 ;otherwise complement m_a ->
              
cmdToBCD2_23: COM 1,X+
              DEC counter1
              BNE cmdToBCD2_23                   ;<-
              
              DEX
              
              MOVB #$07,counter1                 ;add 1 to m_a and store the result in m_a ->
              
              LDAA 0,X
              ADDA #$01
              STAA 1,X-
              
cmdToBCD2_24: LDAA 0,X
              ADCA #$00
              STAA 1,X-
              
              DEC counter1
              BNE cmdToBCD2_24                   ;<- (m_a has now been negated)
              
              BSET flag2,#BIT4                   ;set manNeg flag to indicate result should be negative
              
cmdToBCD2_22: LDX #m_a
              INX 
              LDY #m_e
              
              MOVB #$07,counter1
              
cmdToBCD2_15: LDAA 1,X+                          ;m_e = FPN_a ->
              STAA 1,Y+
              DEC counter1
              BNE cmdToBCD2_15                   ;<-
              
              JSR BinToBCD2                      ;convert m_e to BCD and store in m_a
              
              MOVW #m_g,memAddr2
              JSR copyMan
              
              ;<-
              
              ;convert 2^m - 1 to BCD and store in m_b ->
              
              LDX #m_f
              INX 
              LDY #m_e
              
              MOVB #$07,counter1
              
cmdToBCD2_16: LDAA 1,X+                          ;m_e = FPN_f ->
              STAA 1,Y+
              DEC counter1
              BNE cmdToBCD2_16                   ;<-
              
              JSR BinToBCD2                      ;convert m_e to BCD and store in m_a
              
              MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2
              JSR copyMan                         
              
              ;<-
              
              MOVW #m_g,memAddr1
              MOVW #m_a,memAddr2
              JSR copyMan                        ;restore m_a
              
              MOVW #m_a,memAddr1
                            
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE cmdToBCD2_17                   ;continue if FPN_a = FPN_1_numerator <> 0
              
              ;otherwise set FPN_1_numerator = FPN_a = 0 and FPN_1_denominator = 1 ->
              
              PULD
              PSHD
              
              STD memAddr2
              JSR copyFPN                        ;copy FPN_a to FPN_1_numerator
              
              PULD
              ADDD #$13B5
              
              TFR D,X                            ;X points to FPN_1_denominator
              CLRA
              MOVB #$07,counter1
              
cmdToBCD2_20: STAA 1,X+                          ;set FPN_1_denominator = 1 -> 
              DEC counter1
              BNE cmdToBCD2_20
              
              MOVB #$01,1,X+                     
              
              STAA 0,X                           ;<- 
              
              BSET flag3,#BIT0                   ;set gFlag0 to indicate 2-adic number entered on command line = 0
              
              BRA cmdToBCD2_21
              
              ;<-               

cmdToBCD2_17: JSR tzFPN                          ;eliminate any trailing zeros in FPN_M1 = FPN_a = FPN_1_numerator
              
              PULD
              PSHD
              
              STD memAddr2
              JSR copyFPN                        ;copy FPN_a to FPN_1_numerator
              
              BRCLR flag2,#BIT4,cmdToBCD2_28     ;branch if FPN_1_numerator should be positive
              
              PULD
              PSHD              
              STD memAddr1
              JSR negFPN                         ;otherwise negate FPN_1_numerator first
              
cmdToBCD2_28: MOVW #m_b,memAddr1               
              JSR tzFPN_b                        ;eliminate any trailing zeros in FPN_M1 = FPN_b = FPN_1_denominator
              
              PULD              
              ADDD #$13B5
              
              STD memAddr2
              JSR copyFPN                        ;copy FPN_b to FPN_1_denominator
              
              JSR cmpExp_ab
              
cmdToBCD2_21: RTS

;cmpFPN_GE: subtracts FPN_b from FPN_a and sets ge flag if the result is greater than or equal to zero

cmpFPN_GE:    BCLR flag5,#BIT0                   ;clear ge flag        

              JSR subFPN                         ;FPN_a - FPN_b -> FPN_a

              LDX #m_a                           ;X points to FPN_a - FPN_b
              
              LDAA 0,X                           ;A = MS byte of mantissa of FPN_a - FPN_b
              ANDA #$F0
              BNE cmpFPN_GE_1                    ;exit if MS nibble of mantissa is not zero, i.e. if FPN_a < FPN_b  
              BSET flag5,#BIT0                   ;otherwise FPN_a >= FPN_b, so set ge flag       

cmpFPN_GE_1:  RTS 

;cmpFPN_LE: subtracts FPN_a from FPN_b and sets le flag if the result is greater than or equal to zero

cmpFPN_LE:    BCLR flag5,#BIT1                   ;clear le flag        

              JSR subFPN_ba                      ;FPN_b - FPN_a -> FPN_a

              LDX #m_a                           ;X points to FPN_b - FPN_a
              
              LDAA 0,X                           ;A = MS byte of mantissa of FPN_b - FPN_a
              ANDA #$F0
              BNE cmpFPN_LE_1                    ;exit if MS nibble of mantissa is not zero, i.e. if FPN_a > FPN_b  
              BSET flag5,#BIT1                   ;otherwise FPN_a <= FPN_b, so set le flag       

cmpFPN_LE_1:  RTS 

;copyFPN: copies the FPN of length "lenFPNBytes" bytes from memAddr1 to memAddr2

copyFPN:      LDX memAddr1                         
              LDY memAddr2
                            
              MOVB #lenFPNBytes,counter1                       
              
copyFPN_1:    LDAA 1,X+
              STAA 1,Y+
              DEC counter1
              BNE copyFPN_1             
              
              RTS

;copyMan: copies the mantissa of length "lenManBytes" bytes from memAddr1 to memAddr2

copyMan:      LDX memAddr1                         
              LDY memAddr2
                            
              MOVB #lenManBytes,counter1                       
              
copyMan_1:    LDAA 1,X+
              STAA 1,Y+
              DEC counter1
              BNE copyMan_1             
              
              RTS 
              
;copyMem: copies memory of length "lenMemBytes" bytes from memAddr1 to memAddr2

copyMem:      LDX memAddr1                         
              LDY memAddr2
                            
              MOVB lenMemBytes,counter1                       
              
copyMem_1:    LDAA 1,X+
              STAA 1,Y+
              DEC counter1
              BNE copyMem_1             
              
              RTS

;dbgProg: debug the program starting at prgCounterSt + 1
                                                 
dbgProg:      ;MOVB #$06,counter1   
              ;JSR clearStack                     ;clear pages 1 - 6
              
              ;CALL clearStack2                    ;clear pages 0 - 6
              
              MOVB #wFont,savedY2
                                                               
              ;CALL updateStack                   ;clear pages 1 -5 and display 
              
key140_1:     BCLR PTH,#BIT0                     ;A0 = 0,send command 

              LDAA #$B7                          ;set to page 7
              JSR sendByte          
              
              CLR Ycoord                   
              JSR setY                           ;Y = 0    

              LDX #DbgMenu
              MOVB #$80,colNumber
              JSR sendData3                      ;display the debug menu     

              LDD prgCounter                     ;increment prgCounter
              ADDD #$0001
              STD prgCounter
              
              PSHD
              
              LDAA #$B0                                        
              BCLR PTH,#BIT0                     ;A0 = 0,send command
              JSR sendByte                       ;set to page 0
              
              JSR clearPage                      ;clear page 0
              
						  PULD
						  
						  CALL dispPrgIstr                   ;display the program line number,code and instruction on page 0
						  
key140_2:     BCLR flag1,#BIT1                   ;clear the keyFound flag		  

              BCLR PT1AD0,#BIT0                  ;clear all keypad rows
              BCLR PT1AD0,#BIT1
              BCLR PT1AD0,#BIT2
              BCLR PT1AD0,#BIT3
              BCLR PT1AD0,#BIT4
              BCLR PT1AD0,#BIT5
              BCLR PT1AD0,#BIT6
              BCLR PT1AD0,#BIT7
                            
key140_3:     LDAA PTP
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS14: simulate key press
              ;CLRA
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              COMA
                            
              BEQ key140_3                       ;loop if keypad not pressed (A=0)                                             
              
              CALL scanKey2                      ;otherwise scan keypad           
             
              BRCLR flag1,#BIT1,key140_2         ;loop if pressed key was not found   

              BCLR PT1AD0,#BIT0                  ;clear all keypad rows
              BCLR PT1AD0,#BIT1
              BCLR PT1AD0,#BIT2
              BCLR PT1AD0,#BIT3
              BCLR PT1AD0,#BIT4
              BCLR PT1AD0,#BIT5
              BCLR PT1AD0,#BIT6
              BCLR PT1AD0,#BIT7
             
key140_4:     LDAA PTP
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS13: simulate key release
              ;LDAA #$FF
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              COMA
              BNE key140_4                       ;loop until pressed key is released               
                           
              LDAA keyNumber                     ;place breakpoint here in FCS
              CMPA #$2F
              BEQ key140_5                       ;if keyNumber = 47,execute program instruction and update 
                                                 ;command line/stack              
              CMPA #$24
              BEQ key140_7                       ;if keyNumber = 36 then exit debug mode              
              
              BRA key140_2                       ;otherwise scan keypad again
              
key140_5:     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              LDAA #$B6                                        
              BCLR PTH,#BIT0                     ;A0 = 0,send command
              JSR sendByte                       ;set to page 6 (the command line)
              
              MOVB savedY2,Ycoord
              JSR setY                           ;Y = savedY2               					    
			       
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              LDX #keyTable     

              LDY prgCounter
              LDAB 0,Y                           ;(prgCounter) -> B
              CLRA
              
              CMPB #$7B
              BEQ key140_6                       ;do not execute the TMRON instruction (123)
               
              CMPB #$7C
              BEQ key140_6                       ;do not execute the TMROFF instruction (124)
              
              ASLD                               ;multiply D by 2             
              
              JSR keyHdlr                        ;execute the instruction
              
              BRCLR flag4,#BIT7,key140_6         ;branch if updtScreen flag is clear (to display command line)
              
              CALL updateStack                   ;otherwise update the stack and clear the command line                            
              CALL clrComL
              
              MOVB #wFont,savedY2                ;reset savedY2
              
              LBRA key140_1                      ;repeat                        
              
key140_6:     MOVB Ycoord,savedY2                ;update savedY2
              
              BSET flag4,#BIT7                   ;set the updtScreen flag               
              
              LBRA key140_1                      ;repeat
              
key140_7:     JSR clrComLMem                     ;clear command line memory
                            
              RTS

;decFPN_a: subtracts 1 from FPN_a;;;;;;;;;;;;;;;;;

decFPN_a:     LDX #m_aEnd                        ;X points to the LS byte of mantissa of FPN_a
              
              LDAB #$07
              
              LDAA 0,X
              ADDA #$99
              DAA
              STAA 1,X-
              
decFPN_a_1:   LDAA 0,X
              ADCA #$99
              DAA
              STAA 1,X-
              DECB
              BNE decFPN_a_1                 

              RTS

;decFPN_b: subtracts 1 from FPN_b;;;;;;;;;;;;;;;;;

decFPN_b:     LDX #m_bEnd                        ;X points to the LS byte of mantissa of FPN_b
              
              LDAB #$07
              
              LDAA 0,X
              ADDA #$99
              DAA
              STAA 1,X-
              
decFPN_b_1:   LDAA 0,X
              ADCA #$99
              DAA
              STAA 1,X-
              DECB
              BNE decFPN_b_1                 

              RTS

;decK: subtracts 1 from K;;;;;;;;;;;;;;;;;;;;;;;;;

decK:         LDX #m_KEnd                        ;X points to the LS byte of mantissa of K

              LDAB #$07
              
              LDAA 0,X
              ADDA #$99
              DAA
              STAA 1,X-
              
decK_1:       LDAA 0,X
              ADCA #$99
              DAA
              STAA 1,X-
              DECB
              BNE decK_1                 

              RTS

;delay: cause a timer delay;;;;;;;;;;;;;;;;;;;;;;;

delay:        MOVB #$80,TIM_TSCR1                ;TIM_TSCR1 = 1000 0000,timer enabled 
            
delay_1:      BRCLR TIM_TFLG2,#BIT7,delay_1      ;branch to delay_1 if TOF = 0, i.e loop until TOF = 1 
                                                 ;(i.e until timer overflows)
              
              MOVB #BIT7,TIM_TFLG2               ;set TIM_TFLG2.7 = TOF to clear the timer overflow flag (TOF) 
            
              CLR TIM_TSCR1                      ;TIM_TSCR1 = 0000 0000,timer disabled 
              
              RTS
              
;dispDp: display the decimal point/tick at the current position of Y

dispDp:       BRCLR flag5,#BIT7,dispDp_1         ;branch if not in 2-adic mode      

              LDX #Tick
              BRA dispDp_2        

dispDp_1:     LDX #decPoint

dispDp_2:     MOVB #wFont,colNumber                
              JSR sendData                                              

              RTS
              
;dispError: displays "ERROR" on the status line/exits a program when an error occurs 

dispError:    ;BCLR PORTE,#BIT1                   ;light ERROR LED on pin PE1
              ;BCLR PORTD,#BIT1                   ;light ERROR LED on pin PD1 (prototype)     

              BRSET flag3,#BIT7,dispError_1      ;branch if program is being executed    

              LDX #Error                          
              MOVB #$1E,colNumber
              CALL dispStatLI
              
              JSR clrComLMem                     ;clear command line memory              
              CALL clrComL                       ;reset the command line
              
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              
              BRA dispError_3
              
dispError_1:  BRCLR TIM_TSCR2,#BIT7,dispError_2  ;branch if TMRON instruction was not executed in the program 

              SEI                                ;otherwise set the I mask bit to make RTI uninterruptible 

              CLR TIM_TSCR1                      ;TSCR1 = 0000 0000,timer stopped

              MOVB #$01,TIM_TSCR2                ;TSCR2 = 0000 0001
                                                 ;timer set with no interrupt & prescale factor = 2
              
              MOVW TIM_TCNT,tcntRegEnd           ;store counter register end value
              
              BSET CRGINT,#BIT7                  ;enable RTI

dispError_2:  BCLR flag3,#BIT7                   ;clear run flag

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              BCLR PTH,#BIT0                     ;A0 = 0, send command	

			        LDAA #$B0                          ;page 0  
              JSR sendByte                       ;set the page

              MOVB #$1B,Ycoord
              JSR setY                           ;Y = 27
              
              LDX #Space
              MOVB #wFontSL,colNumber
              JSR sendData2                      ;clear "R" from the status line
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        

              LDX #Error                          
              MOVB #$1E,colNumber
              CALL dispStatLI
              
              JSR clrComLMem                     ;clear command line memory
              CALL clrComL                       ;reset the command line
              
              BCLR flag4,#BIT7                   ;clear updtScreen flag
                            
              LDS #$3FF2                         ;return address of scanKey_4 is stored at $3FF2 on the stack
                                                 
              JMP keyHdlr_1 
              
dispError_3:  RTS

;divFPN: divide FPN_a by FPN_b and store the result in FPN_a

divFPN:       LDAA e_a
              SUBA e_b
              STAA e_a                           ;e_2 - e_1 -> e_a       

              BCLR flag2,#BIT2                   ;clear zf flag
              BCLR flag2,#BIT4                   ;clear manNeg flag

              MOVW #m_a,memAddr1
              JSR absFPN                         ;set |FPN_a| and set manNeg flag if FPN_a < 0
              
              MOVW #m_b,memAddr1
              JSR absFPN                         ;set |FPN_b| and invert manNeg flag if FPN_b < 0
              
              MOVB #lenManBBytes,lenMemBytes     ;lenMemBytes = lenManBBytes for BCDToBin subroutine
              
              MOVW #m_b,memAddr2
              MOVW #m_c,memAddr1 
              
              JSR BCDToBin                       ;convert |FPN_b| to binary and store in FPN_c
              
              MOVW #m_a,memAddr2
              MOVW #m_e,memAddr1 
              
              JSR BCDToBin                       ;convert |FPN_a| to binary and store in FPN_e
              
              CLRA
              LDX #m_d
              MOVB #lenManBBytes,counter1
                                                     
divFPN_1:     STAA 1,X+                          ;clear m_d ->
              DEC counter1
              BNE divFPN_1                       ;<- 
              
              JSR idivFPN                        ;divide m_e_bin by m_c_bin,quotient in m_e,remainder in m_d
              
              JSR BinToBCD2                      ;convert m_e to BCD and store in mantissa of FPN_a
              
              MOVW #m_a,memAddr1
              
              JSR lzMan                          ;determine the number of leading zeros in FPN_a
              
              LDAA noZero
              BEQ divFPN_5                       ;branch if FPN_a contains 10 significant figures
              CMPA #lenMan
              BNE divFPN_2                       ;branch if FPN_a <> 0
              BSET flag2,#BIT2                   ;otherwise set zf flag

divFPN_2:     MOVW #m_d,memAddr1
              MOVW #m_e,memAddr2
              JSR copyMem                        ;the remainder is copied to m_e
              
              MOVW #m_e,memAddr1
              JSR multBin10                      ;10 * remainder becomes the new dividend
              
              CLRA
              LDX #m_d
              MOVB #lenManBBytes,counter1
                            
divFPN_3:     STAA 1,X+                          ;clear m_d ->
              DEC counter1
              BNE divFPN_3                       ;<-
              
              JSR idivFPN
              
              DEC e_a                            ;decrement the exponent
                            
              LDX #m_e
              LDAB #lenManBBytes
              DECB
              ABX                                ;X points to LS byte of the quotient m_e
              
              LDAA 0,X
              BEQ divFPN_4                       ;branch if quotient = 0 (0 =< quotient <= 9)
              BCLR flag2,#BIT2                   ;otherwise clear zf flag
              
divFPN_4:     STAA keyValue                      ;quotient -> keyValue               
                            
              MOVW #m_a,memAddr1
              JSR multMan10add                   ;shift the mantissa of FPN_a one nibble to the left and add 
                                                 ;keyValue to obtain the next digit of the result
              
              BRSET flag2,#BIT2,divFPN_2         ;loop if there is no non-zero leading digit
              
              DEC noZero                         ;otherwise decrement noZero              
              BNE divFPN_2

divFPN_5:     LDX #m_d
              LDAB #lenManBBytes
              DECB
              ABX                                ;X points to LS byte of remainder m_d
              
              STAB counter1
              
              ASL 1,X-
              
divFPN_6:     ROL 1,X-
              DEC counter1
              BNE divFPN_6                       ;remainder m_d multiplied by 2
              
              LDX #m_d
              ABX                                ;X points to LS byte of m_d = 2 * remainder = 2r
              
              LDY #m_c
              ABY                                ;Y points to LS byte of divisor d = m_c
              
              STAB counter1
              
              LDAA 1,X-
              SUBA 1,Y-
                            
divFPN_7:     LDAA 1,X-
              SBCA 1,Y-
              DEC counter1
              BNE divFPN_7                       ;2r - d
              
              BCS divFPN_8                       ;branch if 2r - d < 0 (i.e. r/d < 1/2 -> no round-up)
              JSR incFPN                         ;otherwise increment mantissa of FPN_a first
              
divFPN_8:     LDX #m_a
              LDAA 0,X
              ANDA #$F0
              BEQ divFPN_9                       ;branch if the MS nibble of FPN_a = 0
              
              JSR divMan10                       ;otherwise shift the mantissa one nibble to the right              
              INC e_a                            ;increment e_a to maintain equality
              LDAB 0,X
              ANDB #$0F
              STAB 0,X                           ;set the MS nibble of FPN_a to 0  
              CMPA #$05
              BLT divFPN_9                       ;exit if A < 5
              JSR incFPN                         ;otherwise increment FPN_a before exiting
              
divFPN_9:     MOVB #lenExpBytes,lenMemBytes      ;lenMemBytes = lenExpBytes to update value of exponent when entering
                                                 ;values on the command line after the division is performed            
              RTS

;divMan10: divides the mantissa of FPN_M1 by 10 (BCD equivalent of ASR) and shifts the LS nibble into A. 
;Note: lenManBytes must be greater than 1.

divMan10:     LDX memAddr1
              
              MOVB #$04,counter1
              
divMan10_1:   PSHX         

              MOVB #lenManBytes,counter2
              DEC counter2
                            
              ASR 1,X+                  
              
divMan10_2:   ROR 1,X+
              DEC counter2
              BNE divMan10_2
              
              RORA
              
              PULX                               ;X points to the MS byte of the mantissa
               
              DEC counter1
              BNE divMan10_1
              
              ASRA                               ;ASR A by 1 nibble
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB 0,X                           ;B = MS byte of the mantissa
              ANDB #$F0
              BEQ divMan10_3                     ;exit if B = 0 (i.e. FPN_M1 is positive) 
              LDAB 0,X                           ;otherwise MS byte = 9x (i.e. FPN_M1 is negative)
              ANDB #$0F
              ADDB #$90
              STAB 0,X
              
divMan10_3:   RTS

;divMan1030dig: divides the 30-digit mantissa at endm_c = $31BF by 10 (BCD equivalent of ASR)
 
divMan1030dig:
              LDX #endm_c
              
              MOVB #$04,counter1
              
divMan1030dig_1:   
              PSHX         

              MOVB #$0F,counter2
              DEC counter2
                            
              ASR 1,X+                  
              
divMan1030dig_2:   
              ROR 1,X+
              DEC counter2
              BNE divMan1030dig_2
              
              PULX                               ;X points to the MS byte of the mantissa
               
              DEC counter1
              BNE divMan1030dig_1
                            
              RTS

;exePrg: execute the program;;;;;;;;;;;;;;;;;;;;;;

exePrg:       BSET flag3,#BIT7                   ;set the run flag

              MOVW #ps_retAddr,prgStackPtr       ;initialise the program stack pointer for subroutine calls 

exePrg_1:     LDX #keyTable     

              LDY prgCounter
              INY
              STY prgCounter
              
              LDAB 0,Y                           ;(prgCounter) -> B
              CLRA
              
              ASLD                               ;multiply D by 2
              
              JSR keyHdlr                        ;execute instruction
              
              BRA exePrg_1                       ;repeat until endPrg instruction executed 

;expFPN: calculates a^FPN_f and stores the result in FPN_b, a = 2, e

expFPN:       MOVW #m_f,memAddr1 
              
              LDX #m_f
              LDAA 0,X
              ANDA #$F0
              PSHA                               ;the value in A will be used at the end of the subroutine
              BEQ expFPN_1_1                     ;branch if FPN_f >= 0
              
              JSR negFPN                         ;otherwise negate FPN_f to make it positive                             
              
expFPN_1_1:   LDX #m_b                           ;set Y = 1 = FPN_b = 01 00 00 00 00 00 00 00 F2 ->
              MOVB #$01,1,X+

              CLRA
              MOVB #07,counter1
expFPN_1:     STAA 1,X+
              DEC counter1
              BNE expFPN_1                       
              
              MOVB #$F2,0,X                      ;<-
              
              LDAA #$0D
              ADDA e_f                           ;A = noZero - (1 - e_f(s)), where e_f(s) is the exponent of 
                                                 ;FPN_f when it is in scientific format. This determines by how many
                                                 ;nibbles m_f needs to be shifted to the left/right
              STAA counter3                                                  
              
              BEQ expFPN_4                       ;branch if counter3 = 0, i.e. when m_f does not need to be shifted
              BPL expFPN_3                       ;branch if counter3 > 0, i.e. when m_f needs to be shifted counter3 
                                                 ;nibbles to the left
              NEG counter3                       ;otherwise counter3 < 0 and m_f needs to be shifted -counter3
                                                 ;nibbles to the right  
expFPN_2:     JSR divMan10                       ;shift m_f counter3 nibbles to the right -> 
              DEC counter3
              BNE expFPN_2                       ;<-                                              
              
              BRA expFPN_4       
              
expFPN_3:     JSR multMan10                      ;shift m_f counter3 nibbles to the left ->
              DEC counter3
              BNE expFPN_3                       ;<-
              
                                                 ;K = counter3 = 0               
              
expFPN_4:     LDAA counter3
              CMPA #$0D
              LBHI expFPN_11                     ;branch if X > 13
              
expFPN_5:     LDX logValues
	            LDAB counter3
              ASLB
              LDY B,X                            ;Y points to ln(1 + 10^-K)
              
              LDX #m_f
              
              MOVB #$08,counter1                 ;number of bytes to compare
              
expFPN_5_1:   LDAA 1,X+
              CMPA 1,Y+
              BHI expFPN_7                       ;branch if X = m_f > ln(1 + 10^-K)
              BLO expFPN_6                       ;branch if X = m_f < ln(1 + 10^-K)
              DEC counter1
              BNE expFPN_5_1                     ;otherwise bytes are equal so compare the next byte
              BRA expFPN_7                       ;m_f = ln(1 + 10^-K)
              
expFPN_6:     INC counter3                       ;increment K and repeat
              BRA expFPN_4
              
expFPN_7:     LDX negLogValues                
	            LDAB counter3
              INCB
              ASLB
              LDY B,X                            ;Y points to -ln(1 + 10^-K)
              DEY                                ;Y points to LS byte of -ln(1 + 10^-K))

              LDX #m_fEnd                        ;X points to LS byte of m_f
              
              MOVB #$07,counter1
              
              LDAA 0,X                           ;X - ln(1 + 10^-K) -> X ->
              ADDA 1,Y-
              DAA
              STAA 1,X-
              
expFPN_8:     LDAA 0,X
              ADCA 1,Y-
              DAA
              STAA 1,X-
              
              DEC counter1
              BNE expFPN_8                       ;<-
              
              MOVW #m_b,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;TEMP = m_a = m_b = Y
              
              MOVB counter3,counter4
              TST counter4
              BEQ expFPN_10                      ;do not shift Y if K = 0
              
expFPN_9:     JSR divMan10                       ;multiply Y = m_b by 10^-K                       
              DEC counter4
              BNE expFPN_9
              
expFPN_10:    JSR addMan                         ;m_a + m_b -> m_a, i.e.
                                                 ;Y + 10^-K * Y -> m_a                                                 
              MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2              
              JSR copyFPN                        ;m_a -> m_b, i.e Y + 10^-K * Y -> Y 
                                                 
              LBRA expFPN_5                      ;repeat              
              
expFPN_11:    PULA
              TSTA
              BEQ expFPN_13                      ;branch if the exponent was non-negative
              
              LDX #m_a                           ;otherwise set FPN_a = 00 00 00 00 00 00 00 01 00 ->

              MOVB #lenManBytes,counter1
              DEC counter1
              CLRA 
              
expFPN_12:    STAA 1,X+
              DEC counter1
              BNE expFPN_12                     
              
              MOVB #$01,1,X+
              CLR 0,X                            ;<- 
              
              JSR divFPN                         ;FPN_a / FPN_b -> FPN_a, i.e. 1 / FPN_b -> FPN_a 
              
              MOVW #m_b,memAddr2 
              JSR copyFPN                        ;FPN_a -> FPN_b              
              
expFPN_13:    RTS 

;expFPN2: calculates 10^FPN_f and stores the result in FPN_b

expFPN2:      MOVW #m_f,memAddr1 
              
              LDX #m_f
              LDAA 0,X
              ANDA #$F0
              PSHA                               ;the value in A will be used at the end of the subroutine
              BEQ expFPN2_1_1                    ;branch if FPN_f >= 0
              
              JSR negFPN                         ;otherwise negate FPN_f to make it positive                             
              
expFPN2_1_1:  LDX #m_b                           ;set Y = 1 = FPN_b = 01 00 00 00 00 00 00 00 F2 ->
              MOVB #$01,1,X+

              CLRA
              MOVB #07,counter1
expFPN2_1:    STAA 1,X+
              DEC counter1
              BNE expFPN2_1                       
              
              MOVB #$F2,0,X                      ;<-
              
              LDAA #$0E
              ADDA e_f                           ;A = noZero - (1 - e_f(s)), where e_f(s) is the exponent of 
                                                 ;FPN_f when it is in scientific format. This determines by how many
                                                 ;nibbles m_f needs to be shifted to the left/right
              STAA counter3                                                  
              
              BEQ expFPN2_4                      ;branch if counter3 = 0, i.e. when m_f does not need to be shifted
              BPL expFPN2_3                      ;branch if counter3 > 0, i.e. when m_f needs to be shifted counter3 
                                                 ;nibbles to the left
              NEG counter3                       ;otherwise counter3 < 0 and m_f needs to be shifted -counter3
                                                 ;nibbles to the right  
expFPN2_2:    JSR divMan10                       ;shift m_f counter3 nibbles to the right -> 
              DEC counter3
              BNE expFPN2_2                      ;<-                                              
              
              BRA expFPN2_4       
              
expFPN2_3:    JSR multMan10                      ;shift m_f counter3 nibbles to the left ->
              DEC counter3
              BNE expFPN2_3                      ;<-
              
                                                 ;K = counter3 = 0               
              
expFPN2_4:    LDAA counter3
              CMPA #$0D
              LBHI expFPN2_11                    ;branch if K > 13
              
expFPN2_5:    LDX logValues
	            LDAB counter3
              ASLB
              LDY B,X                            ;Y points to ln(1 + 10^-K)
              
              LDX #m_f
              
              MOVB #$08,counter1                 ;number of bytes to compare
              
expFPN2_5_1:  LDAA 1,X+
              CMPA 1,Y+
              BHI expFPN2_7                      ;branch if X = m_f > ln(1 + 10^-K)
              BLO expFPN2_6                      ;branch if X = m_f < ln(1 + 10^-K)
              DEC counter1
              BNE expFPN2_5_1                    ;otherwise bytes are equal so compare the next byte
              BRA expFPN2_7                      ;m_f = ln(1 + 10^-K)
              
expFPN2_6:    INC counter3                       ;increment K and repeat
              BRA expFPN2_4
              
expFPN2_7:    LDX negLogValues                
	            LDAB counter3
              INCB
              ASLB
              LDY B,X                            ;Y points to -ln(1 + 10^-K)
              DEY                                ;Y points to LS byte of -ln(1 + 10^-K))

              LDX #m_fEnd                        ;X points to LS byte of m_f
              
              MOVB #$07,counter1
              
              LDAA 0,X                           ;X - ln(1 + 10^-K) -> X ->
              ADDA 1,Y-
              DAA
              STAA 1,X-
              
expFPN2_8:    LDAA 0,X
              ADCA 1,Y-
              DAA
              STAA 1,X-
              
              DEC counter1
              BNE expFPN2_8                      ;<-
              
              MOVW #m_b,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;TEMP = m_a = m_b = Y
              
              MOVB counter3,counter4
              TST counter4
              BEQ expFPN2_10                     ;do not shift Y if K = 0
              
expFPN2_9:    JSR divMan10                       ;multiply Y = m_b by 10^-K                       
              DEC counter4
              BNE expFPN2_9
              
expFPN2_10:   JSR addMan                         ;m_a + m_b -> m_a, i.e.
                                                 ;Y + 10^-K * Y -> m_a                                                 
              MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2              
              JSR copyFPN                        ;m_a -> m_b, i.e Y + 10^-K * Y -> Y 
                                                 
              LBRA expFPN2_5                     ;repeat              
              
expFPN2_11:   PULA
              TSTA
              BEQ expFPN2_13                     ;branch if the exponent was non-negative
              
              LDX #m_a                           ;otherwise set FPN_a = 00 00 00 00 00 00 00 01 00 ->

              MOVB #lenManBytes,counter1
              DEC counter1
              CLRA 
              
expFPN2_12:   STAA 1,X+
              DEC counter1
              BNE expFPN2_12                     
              
              MOVB #$01,1,X+
              CLR 0,X                            ;<- 
              
              JSR divFPN                         ;FPN_a / FPN_b -> FPN_a, i.e. 1 / FPN_b -> FPN_a 
              
              MOVW #m_b,memAddr2 
              JSR copyFPN                        ;FPN_a -> FPN_b              
              
expFPN2_13:   RTS    
      
;GCDFPN_ab: find the GCD of FPN_a and FPN_b;;;;;;;

GCDFPN_ab:    CLR counter4                       ;GCD = g * 2^d, d = counter4

              MOVW #m_a,memAddr1
              
              TST e_a
              BEQ keyGCD_8_1
              
              MOVB e_a,counter3                  ;multMan10 subroutine uses counter1 and counter2
                           
keyGCD_8:     JSR multMan10                      ;multiply FPN_a by 10^e_a
              DEC e_a                            ;e_a decremented to preserve equality
              DEC counter3
              BNE keyGCD_8
              
keyGCD_8_1:   MOVW #m_f,memAddr2
              JSR copyMan
              
              MOVB #$08,lenMemBytes
              
              JSR BCDToBin2                      ;convert m_f to binary and store in m_a
              
              MOVW #m_b,memAddr1              
              JSR copyMan                        
              
              JSR BCDToBin2                      ;convert m_f to binary and store in m_b
              
              MOVB #$01,lenMemBytes
              MOVW #m_a,memAddr1

keyGCD_9:     LDAA m_aEnd                        ;A  = LS byte of mantissa of m_a
              RORA
              BCS keyGCD_11                      ;branch if m_a is odd
              
              LDAA m_bEnd
              RORA
              LBCS keyGCD_12                     ;branch if m_b is odd (and m_a is even)
              
                                                 ;otherwise both m_a and m_b are even so rotate each 1 bit to the
                                                 ;right (i.e. divide by 2)
              LDX #m_a                           ;divide m_a by 2  ->
              MOVB #$07,counter1
              
              ASR 1,X+

keyGCD_10:    ROR 1,X+
              DEC counter1
              BNE keyGCD_10                      ;<-
              
              LDX #m_b                           ;divide m_b by 2  ->
              MOVB #$07,counter1
              
              ASR 1,X+

keyGCD_10_1:  ROR 1,X+
              DEC counter1
              BNE keyGCD_10_1                    ;<-
              
              INC counter4
              
              BRA keyGCD_9                       ;repeat 
              
keyGCD_11:                                       ;m_a is odd -> 
              ;test if m_a = m_b ->

              MOVB #$08,counter1                 ;compare 8 bytes
              
              LDX #m_aEnd
              LDY #m_bEnd
              
keyGCD_11_1:  LDAA 1,X-
              CMPA 1,Y-
               
              BNE keyGCD_11_2                    ;exit if m_a <> m_b
              
              DEC counter1
              BNE keyGCD_11_1                    ;test next byte 
              
              LBRA keyGCD_13                     ;m_a = m_b
              
              ;<- 
              
keyGCD_11_2:  ;if m_b even then divide m_b by 2 and goto key212_9

              LDAA m_bEnd
              RORA
              
              BCS keyGCD_11_3                    ;branch if m_b is odd
              
              MOVB #$07,counter1                 ;otherwise divide m_b by 2 ->
              
              LDX #m_b
              
              ASR 1,X+
              
keyGCD_11_2_1:ROR 1,X+
              DEC counter1
              BNE keyGCD_11_2_1                  ;<-
              
              BRA keyGCD_9
              
              ;<-
              
              ;else if m_a > m_b then set m_a = (m_a - m_b)/2 and goto key212_9
              
keyGCD_11_3:  JSR copyMan                        ;copy m_a to m_f in case m_a < m_b and m_a needs to be restored  

              MOVB #$07,counter1                 ;m_a - m_b -> m_a ->  

              LDX #m_aEnd                        
              LDY #m_bEnd
              
              LDAA 0,X
              SUBA 1,Y-
              STAA 1,X-
              
keyGCD_11_3_1:LDAA 0,X
              SBCA 1,Y-
              STAA 1,X-
              
              DEC counter1
              BNE keyGCD_11_3_1                  ;<-
              
              INX
              LDAA 0,X
              BMI keyGCD_11_4                    ;branch if m_a < m_b 
              
              MOVB #$07,counter1                 ;otherwise divide m_a by 2 ->
              
              ASR 1,X+
              
keyGCD_11_3_2:ROR 1,X+
              DEC counter1
              BNE keyGCD_11_3_2                  ;<-
               
              LBRA keyGCD_9
              
              ;<-
              
              ;else set m_b = (m_b - m_a)/2 and goto key212_9
              
keyGCD_11_4:  MOVB #$08,counter1                 ;complement m_a ->
              
keyGCD_11_4_1:COM 1,X+
              DEC counter1
              BNE keyGCD_11_4_1                  ;<-
              
              DEX
              
              MOVB #$07,counter1                 ;add 1 to m_a and store the result in m_b->
              
              LDY #m_bEnd
              
              LDAA 1,X-
              ADDA #$01
              STAA 1,Y-
              
keyGCD_11_4_2:LDAA 1,X-
              ADCA #$00
              STAA 1,Y-
              
              DEC counter1
              BNE keyGCD_11_4_2                  ;<- (m_b is now equal to m_b - m_a)
              
              MOVW #m_f,memAddr1
              MOVW #m_a,memAddr2
              JSR copyMan                        ;restore m_a
              
              MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2                 ;restore memAddr1 and memAddr2 
                
              MOVB #$07,counter1                 ;divide m_b by 2 ->
              
              LDX #m_b
              
              ASR 1,X+
              
keyGCD_11_4_3:ROR 1,X+
              DEC counter1
              BNE keyGCD_11_4_3                  ;<-            
              
              LBRA keyGCD_9
              
              ;<-
                                                               
keyGCD_12:                                       ;m_b is odd ->
              ;test if m_a = m_b ->

              MOVB #$08,counter1                 ;compare 8 bytes
              
              LDX #m_aEnd
              LDY #m_bEnd
              
keyGCD_12_1:  LDAA 1,X-
              CMPA 1,Y-
               
              BNE keyGCD_12_2                    ;exit if m_a <> m_b
              
              DEC counter1
              BNE keyGCD_12_1                    ;test next byte 
              
              BRA keyGCD_13                      ;m_a = m_b
              
              ;<- 
              
keyGCD_12_2:  ;m_a is even so divide m_a by 2 and goto key212_9
              
              MOVB #$07,counter1                 ;divide m_a by 2 ->
              
              LDX #m_a
              
              ASR 1,X+
              
keyGCD_12_2_1:ROR 1,X+
              DEC counter1
              BNE keyGCD_12_2_1                  ;<-
              
              LBRA keyGCD_9
              
              ;<-

keyGCD_13:    MOVB #$07,counter1                 ;m_a,m_b not both even and m_a = m_b
              
              TST counter4
              BEQ keyGCD_16                      ;do not shift m_a if d = counter4 = 0
              
              LDX #m_aEnd                        ;shift m_a 1 bit to the left (i.e. multiply by 2) ->

              ASL 1,X-

keyGCD_14:    ROL 1,X-                           
              DEC counter1
              BNE keyGCD_14                      ;<-
              
              DEC counter4                       ;repeat d = counter 4 times since GCD = g * 2^d, where g = m_a
              BNE keyGCD_13
              
keyGCD_16:    LDX #m_a
              INX
              
              MOVB #$07,counter1                 ;copy m_a to m_e ->
              
              LDY #m_e
              
keyGCD_15:    LDAA 1,X+
              STAA 1,Y+
              DEC counter1
              BNE keyGCD_15                      ;<-
              
              JSR BinToBCD2                      ;convert m_e to BCD and store in m_a
              
              LDAA e_a
              ADDA power
              STAA e_a
              
GCDFPN_ab_exit:
              RTS 

;idivFPN: divide m_e by m_c. The quotient is stored in m_e and the remainder in m_c

idivFPN:      LDX #m_e
              LDAB #lenManBBytes
              DECB
              ABX                                ;X points to the LS byte of m_e
              
              STX memAddr1_LSBY
              
              MOVB #$38,counter1                 ;counter1 = no. of bytes of dividend/divisor * 8  
              
idivFPN_1:    MOVB #lenManBBytes2,counter2      
              DEC counter2
              
              ASL 1,X-                           ;ASL LS byte of m_e              
              
idivFPN_2:    ROL 1,X-                           ;ROL remaining bytes of m_e/m_d
              DEC counter2
              BNE idivFPN_2
              
              LDX #m_d
              ABX                                ;X points to LS byte of m_d
              
              LDY #m_c
              ABY                                ;Y points to LS byte of m_c
              
              MOVB #lenManBBytes,counter2      
              DEC counter2
              
              LDAA 0,X
              SUBA 1,Y-
              STAA 1,X-                          ;subtract LS byte of m_c from LS byte of m_d and store result in m_d
              
idivFPN_3:    LDAA 0,X
              SBCA 1,Y-
              STAA 1,X-                          ;subtract remaining bytes of m_c from m_d and store result in m_d
              DEC counter2
              BNE idivFPN_3
              
              BCC idivFPN_5                      ;branch if m_d - m_c >= 0 
              LDX #m_d                           ;otherwise m_d - m_c < 0 so restore m_d to its original value
              ABX                                ;X points to LS byte of m_d
              
              LDY #m_c
              ABY                                ;Y points to LS byte of m_c
              
              MOVB #lenManBBytes,counter2      
              DEC counter2
              
              LDAA 0,X
              ADDA 1,Y-
              STAA 1,X-                          ;add LS byte of m_c to LS byte of m_d and store result in m_d
              
idivFPN_4:    LDAA 0,X
              ADCA 1,Y-
              STAA 1,X-                          ;add remaining bytes of m_c to m_d and store result in m_d
              DEC counter2
              BNE idivFPN_4
              
              BRA idivFPN_6 
                                          
idivFPN_5:    LDX memAddr1_LSBY                  ;X points to LS byte of m_e
                           
              LDAA 0,X
              ORAA #$01                          
              STAA 0,X                           ;set LS bit of LS byte of m_e to 1
              
idivFPN_6:    LDX memAddr1_LSBY                  ;X points to LS byte of m_e
              DEC counter1
              BNE idivFPN_1                        

              RTS

;incFPN: adds 1 to the FPN in memAddr1;;;;;;;;;;;;

incFPN:       LDX memAddr1                           
              LDAB #lenManBytes 
              ABX
              DEX                                ;X points to LS byte of memAddr1
              
              STAB counter1
              DEC counter1
              
              LDAA 0,X
              ADDA #$01
              DAA
              STAA 1,X-
              
incFPN_1:     LDAA 0,X
              ADCA #$00
              DAA
              STAA 1,X-
              DEC counter1
              BNE incFPN_1              
              
              RTS
              
;incK: adds 1 to K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

incK:         LDX #m_KEnd                        ;X points to LS byte of K
                           
              LDAB #$07 
                            
              LDAA 0,X
              ADDA #$01
              DAA
              STAA 1,X-
              
incK_1:       LDAA 0,X
              ADCA #$00
              DAA
              STAA 1,X-
              DECB
              BNE incK_1              
              
              RTS

;incPrgStep: increments the program counter and program level 

incPrgStep:   LDX prgCounter
              CPX #ps_end
              BEQ incPrgStep_1                   ;exit if the end of the program stack has been reached
               
              INX                                ;otherwise increment the program counter            
              STX prgCounter                   
              
incPrgStep_1: RTS

;kilo: simulate multiplication by 10^3 and "Enter" press 

kilo:         LDAA e_com
              
              BRSET flag2,#BIT3,kilo_1           ;branch if expNeg flag set
              
              ADDA #$03                          ;otherwise add 3 (kilo) to e_com
              
              BRA kilo_2     
                                        
kilo_1:       SUBA #$03                          ;subtract 3 (kilo) from e_com       

kilo_2:       STAA e_com
              
              JMP Ente                           ;simulate "Enter" press

;logFPN: calculates log b of FPN_f = FPN_1 and stores the result in FPN_a, b = 2, e 

logFPN:       LDAA #lenMan
              SBA                                ;16 - noZero -> A
              ADDA e_f                           ;A = P + 1 = exponent of FPN_1 when it is in scientific format + 1
              PSHA
              
              MOVW #m_f,memAddr1       

              JSR logFPNMan                      ;find Z = the log of the mantissa of FPN_1 divided by 10 and 
                                                 ;store in FPN_a
                                                 
              MOVB #$F3,e_a
              
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = Z                                  
              
              LDX #m_d                           ;clear m_d ->
              MOVB #$07,counter1
              CLRA
              
logFPN_1:     STAA 1,X+
              DEC counter1
              BNE logFPN_1                       ;<-
              
              LDX #m_c                           ;clear first six bytes of m_c ->
              MOVB #$06,counter1
                            
logFPN_2:     STAA 1,X+
              DEC counter1
              BNE logFPN_2                       ;<-
              
              PULA
              TSTA
              BPL logFPN_3                       ;branch if P + 1 >= 0 
              
              NEGA                               ;otherwise negate it first and set expNeg flag 
              BSET flag2,#BIT3
                                 
logFPN_3:     STAA 0,X                           ;m_c = |P + 1| 
              
              MOVB #$F2,e_a                      ;e_a = -14
              
              LDX #m_e                           ;set m_e = log b(10) ->
              LDY logbTen
              
              MOVB #$07,counter1
              
logFPN_4:     LDAA 1,Y+
              STAA 1,X+
              DEC counter1
              BNE logFPN_4                       ;<-
              
              JSR shftAdd                        ;m_c * m_e -> m_d,m_e, i.e. |P + 1| * ln(10) -> m_d,m_e 
              
              JSR BinToBCD                       ;convert the 13-byte binary product to BCD
              
              JSR shFPN30dig                     ;set the 30-digit BCD result to an equivalent 15-digit result and 
                                                 ;copy to m_a
                                                 
              BRCLR flag2,#BIT3,logFPN_5         ;branch if expNeg flag was not set
              JSR negFPN                         ;otherwise negate FPN_a first 
                                                 
logFPN_5:     JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b 
              
              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a
              
              RTS
              
;logFPN2: calculates log 10 of FPN_f = FPN_1 and stores the result in FPN_a 

logFPN2:      LDAA #lenMan
              SBA                                ;16 - noZero -> A
              ADDA e_f                           ;A = P + 1 = exponent of FPN_1 when it is in scientific format + 1
              PSHA
              
              MOVW #m_f,memAddr1       

              JSR logFPNMan                      ;find Z = the log of the mantissa of FPN_1 divided by 10 and 
                                                 ;store in FPN_a                                                 
              MOVB #$F2,e_a
                                                               
              PULA
              TSTA
              BPL logFPN2_1                      ;branch if P + 1 >= 0 
              
              NEGA                               ;otherwise negate it first and set expNeg flag 
              BSET flag2,#BIT3
                                 
logFPN2_1:    CLR counter1                       ;counter1 stores the 10's place digit of |P + 1|     
              
logFPN2_2:    SUBA #$A                           ;subtract 10
              BCS logFPN2_3                      ;result < 0 -> exit loop and add 10
              INC counter1                       ;otherwise increment counter1 and repeat
              BRA logFPN2_2 
              
logFPN2_3:    ADDA #$A                           ;after adding 10 A is equal to 1's place digit

              ASL counter1
              ASL counter1
              ASL counter1
              ASL counter1
              
              ADDA counter1                      ;A = |P + 1| in BCD
              
              CLRB              
              LDX #m_b
              MOVB #$07,counter2
              
logFPN2_4:    STAB 1,X+                          ;FPN_b = P + 1 ->
              DEC counter2
              BNE logFPN2_4
              
              STAA 1,X+
              STAB 0,X
              
              BRCLR flag2,#BIT3,logFPN2_5        ;branch if expNeg flag was not set
              MOVW #m_b,memAddr1
              JSR negFPN                         ;<- otherwise negate FPN_b first 
                                                 
logFPN2_5:    JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b 
              
              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a
              
              RTS

;logFPNMan: calculates log b of the mantissa of FPN_1 divided by 10, and stores the result in FPN_b, b = 2, e 

logFPNMan:    LDAA noZero
              DECA
              DECA
              STAA counter3
              BEQ logFPNMan_4                    ;branch if noZero - 2 = 0 (FPN_f = Y does not need to be shifted)
              
              BMI logFPNMan_2                    ;branch if noZero - 2 < 0              
                         
logFPNMan_1:  JSR multMan10                      ;shift Y noZero - 2 nibbles to the left            
              DEC counter3
              BNE logFPNMan_1
              
              BRA logFPNMan_4
              
logFPNMan_2:  NEG counter3

logFPNMan_3:  JSR divMan10                       ;shift Y 2 - noZero nibbles to the right            
              DEC counter3
              BNE logFPNMan_3           
              
logFPNMan_4:  MOVW #m_h,memAddr2
              JSR copyMan                        ;FPN_h = FPN_f = X  

              CLRA
              
              LDX #m_a                           ;set Z = FPN_a = 0 = 00 00 00 00 00 00 00 00 ->

              MOVB #lenManBytes,counter1
logFPNMan_5:  STAA 1,X+
              DEC counter1
              BNE logFPNMan_5                    ;<-                    
                                                 ;K = counter3 = 0                                                 
              MOVW #m_h,memAddr1
              MOVW #m_g,memAddr2
              JSR copyMan                        ;FPN_g = FPN_h = X 
              
              MOVB counter3,counter4                                  
              
logFPNMan_5_1:
              LDAA counter3
              CMPA #$0D
              LBHI logFPNMan_10                  ;branch if K > 13
              
logFPNMan_5_2:
              MOVB counter3,counter4
              TST counter4
              BEQ logFPNMan_7                    ;do not shift X if K = 0
              
logFPNMan_6:  JSR divMan10                       ;otherwise multiply X = m_h by 10^-K                       
              DEC counter4
              BNE logFPNMan_6
              
logFPNMan_7:  JSR addMan2                        ;m_h + m_g -> m_h, i.e.
                                                 ;10^-K * X + X -> m_h                                                 
              TST m_h
              BEQ logFPNMan_8                    ;branch if MS byte of 10^-K * X + X = 0, i.e. 10^-K * X + X < 1
              
              INC counter3                       ;otherwise increment K
              
              MOVW #m_f,memAddr1
              MOVW #m_h,memAddr2
              JSR copyMan                        ;X = FPN_h = FPN_f = Y
              
              MOVW #m_h,memAddr1
              
              BRA logFPNMan_5_1 
               
logFPNMan_8:  LDX logValues                
	            LDAB counter3
              INCB
              ASLB
              LDY B,X                            ;Y points to ln(1 + 10^-(K+1))
              DEY                                ;Y points to LS byte of ln(1 + 10^-K))

              LDX #m_aEnd                        ;X points to LS byte of m_a = Z
              
              MOVB #$07,counter1
              
              LDAA 0,X                           ;Z + ln(1 + 10^-K) -> Z ->
              ADDA 1,Y-
              DAA
              STAA 1,X-
              
logFPNMan_9:  LDAA 0,X
              ADCA 1,Y-
              DAA
              STAA 1,X-
              
              DEC counter1
              BNE logFPNMan_9                    ;<- 
              
              MOVW #m_h,memAddr1
              MOVW #m_f,memAddr2
              JSR copyMan                        ;Y = FPN_f = FPN_h = X              
              
              MOVW #m_g,memAddr2
              JSR copyMan                        ;FPN_g = FPN_h = X
              
              LBRA logFPNMan_5_2                 ;repeat                 
              
logFPNMan_10: MOVW #m_a,memAddr1
              JSR negFPN                         ;-Z -> Z              
              
              RTS 

;lzMan: determines the number of leading zeros in the "lenManBytes" byte long BCD value in memAddr1 and
;stores the result in noZero

lzMan:        CLR noZero
              
              LDX memAddr1
              MOVB #lenManBytes,counter1
              
lzMan_1:      LDAA 0,X
              BNE lzMan_2                        ;branch if not equal to 0
              INX                                ;otherwise increment X by 1 and noZero by 2
              INC noZero
              INC noZero
              
              DEC counter1
              BNE lzMan_1
              
              BRA lzMan_3
              
lzMan_2:      ANDA #$F0                          ;check MS nibble of X
              BNE lzMan_3                        ;exit if MS nibble is not zero                        ;               
              INC noZero                         ;otherwise MS nibble is 0 (but LS nibble is not),
                                                 ;so increment noZero and exit              
lzMan_3:      RTS

;lzMan30dig: determines the number of leading zeros in the first 7 bytes of the 15-byte long BCD value starting at 
;endm_c = $3166 and stores the result in noZero

lzMan30dig:   CLR noZero
              
              LDX #endm_c
              MOVB #$07,counter1
              
lzMan30dig_1: LDAA 0,X
              BNE lzMan30dig_2                   ;branch if not equal to 0
              INX                                ;otherwise increment X by 1 and noZero by 2
              INC noZero
              INC noZero
              
              DEC counter1
              BNE lzMan30dig_1
              
              BRA lzMan30dig_3
              
lzMan30dig_2: ANDA #$F0                          ;check MS nibble of X
              BNE lzMan30dig_3                   ;exit if MS nibble is not zero                        ;               
              INC noZero                         ;otherwise MS nibble is 0 (but LS nibble is not),
                                                 ;so increment noZero and exit              
lzMan30dig_3: RTS

;manROL: ROL the mantissa of FPN_M1;;;;;;;;;;;;;;;

manROL:       LDX memAddr1
              LDAB #lenManBytes
              DECB
              ABX                                ;X = memAddr1 + lenManBytes - 1 (points to LS byte of FPN_M1)
              
              MOVB #lenManBytes,counter1
              
manROL_1:     ROL 1,X-
              DEC counter1
              BNE manROL_1
              
              RTS
              
;manROR: ROR the mantissa of FPN_M1;;;;;;;;;;;;;;;

manROR:       LDX memAddr1
                            
              MOVB #lenManBytes,counter1
              
manROR_1:     ROR 1,X+
              DEC counter1
              BNE manROR_1
              
              RTS

;mega: simulate multiplication by 10^6 and "Enter" press 

mega:         LDAA e_com
              
              BRSET flag2,#BIT3,mega_1           ;branch if expNeg flag set
              
              ADDA #$06                          ;otherwise add 6 (mega) to e_com
              
              BRA mega_2     
                                        
mega_1:       SUBA #$06                          ;subtract 6 (mega) from e_com       

mega_2:       STAA e_com
              
              JMP Ente                           ;simulate "Enter" press

;micro: simulate multiplication by 10^-6 and "Enter" press 

micro:        LDAA e_com
              
              BRCLR flag2,#BIT3,micro_1          ;branch if expNeg flag clear
              
              ADDA #$06                          ;otherwise add 6 (micro) to e_com
              
              BRA micro_2     
                                        
micro_1:      SUBA #$06                          ;subtract 6 (micro) from e_com       

micro_2:      STAA e_com
              
              JMP Ente                           ;simulate "Enter" press

;milli: simulate multiplication by 10^-3 and "Enter" press 

milli:        LDAA e_com
              
              BRCLR flag2,#BIT3,milli_1          ;branch if expNeg flag clear
              
              ADDA #$03                          ;otherwise add 3 (milli) to e_com
              
              BRA milli_2     
                                        
milli_1:      SUBA #$03                          ;subtract 3 (milli) from e_com       

milli_2:      STAA e_com
              
              JMP Ente                           ;simulate "Enter" press

;multBin: multiplies m_c_bin (7-byte long binary value) with m_e_bin (7-byte long binary value) using the S12 emul
;instruction and stores the 14-byte binary result starting at address m_d

multBin:      RTS

;multBin10: multiplies the lenMemBytes byte long binary value in memAddr1 by 10

multBin10:    LDX memAddr1
              LDAB lenMemBytes
              DECB
              ABX                                ;X = memAddr1 + lenMemBytes - 1 (points to LS byte of memAddr1)                                
              
              STX memAddr1_LSBY                  ;update memAddr1_LSBY       
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;shift 1 bit to the left (i.e. multiply by 2)
              MOVB lenMemBytes,counter1
              DEC counter1
                            
              ASL 1,X-
              
              LDAA counter1
              BEQ multBin10_2                    ;branch if lenMemBytes = 1                           
              
multBin10_1:  ROL 1,X-                           
              DEC counter1
              BNE multBin10_1                         
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;push the value onto the stack, MS byte first
multBin10_2:  INX
           
              MOVB lenMemBytes,counter1
               
multBin10_3:  LDAA 1,X+
              PSHA
              DEC counter1
              BNE multBin10_3
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;shift further 2 bits to the left (i.e. multiply original value by 8)
              DEX
              
              MOVB lenMemBytes,counter1
              DEC counter1
                            
              ASL 1,X-
              
              LDAA counter1
              BEQ multBin10_5                    ;branch if lenMemBytes = 1                          
              
multBin10_4:  ROL 1,X-
              DEC counter1
              BNE multBin10_4
              
multBin10_5:  LDX memAddr1_LSBY                  ;X points to LS byte              
              
              MOVB lenMemBytes,counter1
              DEC counter1
                            
              ASL 1,X-
              
              LDAA counter1
              BEQ multBin10_7                    ;branch if lenMemBytes = 1                           
              
multBin10_6:  ROL 1,X-
              DEC counter1
              BNE multBin10_6
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;memAddr1 is now equal to 8 times the original value, so 
                                                 ;memAddr1 + stack = 10 times the original value
multBin10_7:  LDX memAddr1_LSBY                  ;X points to LS byte
              
              LDAA 0,X
              ADDA 1,SP+
              STAA 1,X-
              
              MOVB lenMemBytes,counter1
              DEC counter1
              
              LDAA counter1
              BEQ multBin10_9                    ;branch if lenMemBytes = 1
              
multBin10_8:  LDAA 0,X
              ADCA 1,SP+
              STAA 1,X-
              DEC counter1
              BNE multBin10_8
                       
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      

multBin10_9:  RTS

;multBin10add: multiplies the lenMembytes byte long binary value in memAddr1 by 10 and then adds keyValue

multBin10add: JSR multBin10                      ;multiply by 10

              LDX memAddr1_LSBY                  ;X points to LS byte 
                            
              LDAA 0,X                           ;add keyValue to LS byte
              ADDA keyValue
              STAA 1,X-
              
              MOVB lenMemBytes,counter1
              DEC counter1
              
              LDAA counter1
              BEQ multBin10add_2                 ;branch if lenMemBytes = 1 
              
multBin10add_1:
              LDAA 0,X
              ADCA #$00
              STAA 1,X-
              DEC counter1
              BNE multBin10add_1                   

multBin10add_2:             
 
              RTS
              
;multFPN: multiply FPN_a with FPN_b and store the result in FPN_a

multFPN:      LDAA e_a
              ADDA e_b
              STAA e_a                           ;e_1 + e_2 -> e_a       

              BCLR flag2,#BIT4                   ;clear manNeg flag

              MOVW #m_a,memAddr1
              JSR absFPN                         ;set |FPN_a| and set manNeg flag if FPN_a < 0
              
              MOVW #m_b,memAddr1
              JSR absFPN                         ;set |FPN_b| and invert manNeg flag if FPN_b < 0
              
              MOVB #lenManBBytes,lenMemBytes     ;lenMemBytes = lenManBBytes for BCDToBin subroutine
              
              MOVW #m_a,memAddr2
              MOVW #m_c,memAddr1 
              
              JSR BCDToBin                       ;convert |FPN_a| to binary and store in FPN_c
              
              MOVW #m_b,memAddr2
              MOVW #m_e,memAddr1 
              
              JSR BCDToBin                       ;convert |FPN_b| to binary and store in FPN_e
              
              MOVB #lenExpBytes,lenMemBytes      ;lenMemBytes = lenExpBytes to update value of exponent when entering
                                                 ;values on the command line after the multiplication is performed             
              CLRA
              LDX #m_d
              MOVB #lenManBBytes,counter1
                                                     
multFPN_1:    STAA 1,X+                          ;clear m_d ->
              DEC counter1
              BNE multFPN_1                      ;<- 
 
              JSR shftAdd                        ;multiply m_c_bin with m_e_bin, result is 13-byte
                                                 ;binary value with the LS byte at the end of m_e
                                                 
              ;JSR multBin                        ;to replace shftAdd subroutine in future version
                                                 
              JSR BinToBCD                       ;convert the 13-byte binary product to BCD
              
              JSR shFPN30dig                     ;set the 30-digit BCD result to an equivalent 15-digit result and 
                                                 ;copy to m_a
              RTS

;multMan10: multiplies the mantissa of FPN_M1 by 10 (BCD equivalent of ASL) and shifts the MS nibble of the 
;mantissa into A. Note: lenManBytes must be greater than 1.

multMan10:    LDX memAddr1
              LDAB #lenManBytes
              DECB
              ABX                                ;X = memAddr1 + lenManBytes - 1 (points to LS byte of FPN_M1)
              
              MOVB #$04,counter1
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;shift 1 bit to the left 4 times
                                                  
multMan10_1:  PSHX                               ;X pushed onto the stack     
              MOVB #lenManBytes,counter2
              DEC counter2
                                          
              ASL 1,X- 
                
multMan10_2:  ROL 1,X-
              DEC counter2
              BNE multMan10_2             
               
              ROLA                               ;shift bit into A     

              PULX                               ;X points to LS byte of FPN_M1
              
              DEC counter1
              BNE multMan10_1
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                    

              RTS

;multMan10add: multiplies the "lenManBytes" byte long BCD value in memAddr1 by 10 and then adds keyValue

multMan10add: JSR multMan10                      ;multiply by 10              
              
              LDAA 0,X                           ;add keyValue to LS byte of FPN_M1
              ADDA keyValue
              STAA 0,X                              

              RTS

;nano: simulate multiplication by 10^-9 and "Enter" press 

nano:         LDAA e_com
              
              BRCLR flag2,#BIT3,nano_1           ;branch if expNeg flag clear
              
              ADDA #$09                          ;otherwise add 9 (nano) to e_com
              
              BRA nano_2     
                                        
nano_1:       SUBA #$09                          ;subtract 9 (nano) from e_com       

nano_2:       STAA e_com
              
              JMP Ente                           ;simulate "Enter" press

;negFPN: negates the FPN in memAddr1 

negFPN:       LDX memAddr1
              LDAB #$07
              ABX                                ;X points to LSBY of FPN_M1
              
              PSHX              
              
              MOVB #lenManBytes,counter1
              
negFPN_1:     LDAA #$99                          ;invert FPN_M1
              SUBA 0,X
              STAA 1,X-
              DEC counter1
              BNE negFPN_1
              
              MOVB #07,counter1
             
              PULX                               ;X points to LSBY of FPN_M1
              
              LDAA 0,X
              ADDA #$01
              DAA                                ;adjust for BCD arithmetic
              STAA 1,X-
              
negFPN_2:     LDAA 0,X                           ;add carry
              ADCA #$00
              DAA                                ;adjust for BCD arithmetic
              STAA 1,X-
              DEC counter1
              BNE negFPN_2
              
              INX
              LDAA 0,X
              CMPA #$10
              BNE negFPN_3                       ;exit if MS byte of FPN_M1 <> 10
              
              LDAB #lenManBytes
              ABX                                ;X points to exponent of FPN_M1
                                       
              LDAA 0,X
              INCA
              STAA 0,X                           ;increment the exponent of FPN_M1
              
              JSR divMan10                       ;divide FPN_M1 by 10
              
negFPN_3:     RTS

;nzKey: updates the m_com/e_com value when a non-zero key is pressed and displays its value on the command line 

nzKey:        BRCLR flag2,#BIT0,nzKey_1          ;branch to nzKey_1 if expPressed is clear

              LDAA noDigExp                      ;exit if noDigExp = maxLenExp
              CMPA #maxLenExp
              BEQ nzKey_4
                            
              INC noDigExp
              MOVW #e_com,memAddr1
              JSR multBin10add                   ;multiply e_com by 10 and add keyValue
              
              BRA nzKey_3 
              
nzKey_1:      BRCLR flag3,#BIT2,nzKey_1_1        ;branch if not in Hex mode

              LDAA noDigMan                      ;exit if noDigMan = 13
              CMPA #$0D
              BEQ nzKey_4
              
              BRA nzKey_1_2      

nzKey_1_1:    LDAA noDigMan                      ;exit if noDigMan = maxLenMan
              CMPA #$0F              
              BEQ nzKey_4
              
nzKey_1_2:    BRSET flag2,#BIT2,nzKey_4          ;exit if zf is set
              
              BRCLR flag2,#BIT1,nzKey_2          ;branch to nzKey_2 if dpPressed flag clear
              INC noDigDp                        
                            
nzKey_2:      MOVW #m_com,memAddr1
              INC noDigMan
                            
              JSR multMan10add                   ;multiply m_com by 10 and add keyValue               
              
nzKey_3:      BRSET flag3,#BIT7,nzKey_5          ;do not display digit if in run mode      

              LDAA keyValue
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display digit               
              
              JSR sendData                     
              
nzKey_4:      BCLR flag4,#BIT7                   ;clear updtScreen flag      

nzKey_5:      RTS

;pico: simulate multiplication by 10^-12 and "Enter" press 

pico:         LDAA e_com
              
              BRCLR flag2,#BIT3,pico_1           ;branch if expNeg flag clear
              
              ADDA #$0C                          ;otherwise add 12 (pico) to e_com
              
              BRA pico_2     
                                        
pico_1:       SUBA #$0C                          ;subtract 12 (pico) from e_com       

pico_2:       STAA e_com
              
              JMP Ente                           ;simulate "Enter" press

;placeValue: determine the place value for the corresponding power of 10 subtracted from the 13-byte binary value
;stored at m_e and m_d

placeValue:   CLRB                                ;place value initially set to 0
              LDX #endm_e                         ;X points to the LS byte of m_e
              LDY memAddr2                        ;Y points to the LS byte of power of ten              
              MOVB #lenManBBytes3,counter1
              DEC counter1                                                  
              
placeValue_1: LDAA 0,X                            ;subtract power of ten from m_e, m_d ->
              SUBA 1,Y-
              STAA 1,X-
              
placeValue_2: LDAA 0,X
              SBCA 1,Y-
              STAA 1,X-
              
              DEC counter1
              BNE placeValue_2                    ;<-
              
              MOVB #lenManBBytes3,counter1
              DEC counter1
              
              LDX #endm_e                        ;X points to the LS byte of m_e
              LDY memAddr2                       ;Y points to LS byte of power of ten
              
              BCS placeValue_3                   ;branch if carry set (i.e. if m_e, m_d - power of ten < 0)
              INCB                               ;otherwise increment the place value and repeat
              BRA placeValue_1
                           
placeValue_3: LDAA 0,X                           ;add power of ten back to m_e, m_d as too much was taken away
              ADDA 1,Y-
              STAA 1,X-
              
placeValue_4: LDAA 0,X
              ADCA 1,Y-
              STAA 1,X-

              DEC counter1
              BNE placeValue_4                   ;<-

              RTS
              
;placeValue2: determine the place value for the corresponding power of 10 subtracted from the 7-byte binary value
;stored at m_e

placeValue2:  CLRB                                ;place value initially set to 0
              LDX #endm_e                         ;X points to the LS byte of m_e
              LDY memAddr2                        ;Y points to the LS byte of power of ten              
              MOVB #lenManBBytes,counter1
              DEC counter1                                                  
              
placeValue2_1:LDAA 0,X                            ;subtract power of ten from m_e ->
              SUBA 1,Y-
              STAA 1,X-
              
placeValue2_2:LDAA 0,X
              SBCA 1,Y-
              STAA 1,X-
              
              DEC counter1
              BNE placeValue2_2                    ;<-
              
              MOVB #lenManBBytes,counter1
              DEC counter1
              
              LDX #endm_e                        ;X points to the LS byte of m_e
              LDY memAddr2                       ;Y points to the LS byte of power of ten
              
              BCS placeValue2_3                  ;branch if carry set (i.e. if m_e - power of ten < 0)
              INCB                               ;otherwise increment the place value and repeat
              BRA placeValue2_1
                           
placeValue2_3:LDAA 0,X                           ;add power of ten back to m_e as too much was taken away
              ADDA 1,Y-
              STAA 1,X-
              
placeValue2_4:LDAA 0,X
              ADCA 1,Y-
              STAA 1,X-

              DEC counter1
              BNE placeValue2_4                   ;<-

              RTS
              
;placeValue3: determine the place value for the corresponding power of 10 subtracted from the 7-byte binary value
;stored at m_com

placeValue3:  CLRB                               ;place value initially set to 0
              LDX #m_comEnd                      ;X points to the LS byte of m_com
              LDY memAddr2                       ;Y points to the LS byte of power of ten              
              MOVB #$06,counter1
              
placeValue3_1:LDAA 0,X                           ;subtract power of ten from m_com ->
              SUBA 1,Y-
              STAA 1,X-
              
placeValue3_2:LDAA 0,X
              SBCA 1,Y-
              STAA 1,X-
              
              DEC counter1
              BNE placeValue3_2                  ;<-
              
              MOVB #$06,counter1
              
              LDX #m_comEnd                      ;X points to the LS byte of m_com
              LDY memAddr2                       ;Y points to the LS byte of power of ten
              
              BCS placeValue3_3                  ;branch if carry set (i.e. if m_com - power of ten < 0)
              INCB                               ;otherwise increment the place value and repeat
              BRA placeValue3_1
                           
placeValue3_3:LDAA 0,X                           ;add power of ten back to m_com as too much was taken away
              ADDA 1,Y-
              STAA 1,X-
              
placeValue3_4:LDAA 0,X
              ADCA 1,Y-
              STAA 1,X-

              DEC counter1
              BNE placeValue3_4                   ;<-

              RTS 
              
;rclFPN: copy the FPN stored in ms_end + 9 * keyNumber to the user stack

rclFPN:       LDD usPointer
              CPD #$2000
              BNE rclFPN_1                       ;if the end of the stack has not yet been reached,push the FPN
                                                 ;onto it
                                                  
              JSR resetStack                     ;otherwise copy the current values to the start of the stack, then 
                                                 ;push the FPN onto it             
              BRA rclFPN_2                                                             
                                                 
rclFPN_1:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              
rclFPN_2:     LDAB keyNumber
              
              LDX #ms_end                        ;ms26 corresponds to the letter "Z" (key 0)
              
              LDAA #$09
              MUL                                ;multiplies keyNumber (in register B) with 9 to determine offset                                                 
                                                 
              ABX                                ;X = ms_end + 9 * keyNumber
              
              STX memAddr1                  
              MOVW usPointer,memAddr2              
              JSR copyFPN                        ;copy the FPN to the user stack
              
              JSR clrComLMem                     ;clear command line memory

              RTS

;resetStack: called when the end of the user stack has been reached. It copies FPN_16 - FPN_20 to FPN_1 - FPN_5 and 
;sets the value of usPointer to the 6th level.

resetStack:   LDX usPointer                      ;X = $2000
              LDY #$2087                         ;Y = the address of us5
              
              MOVB #$05,counter1
              
resetStack_1: MOVB #lenFPNBytes,counter2 

resetStack_2: LDAA 1,X+                          ;copy us20 to us5, us19 to us4, etc                                                 
              STAA 1,Y+
              DEC counter2
              BNE resetStack_2
              
              DEC counter1
              BNE resetStack_1
              
              MOVW #$207E,usPointer              ;the address of us6
              
              RTS
              
;resetStackImag: called when the end of the user stack has been reached. It copies FPN_16_imaginary - FPN_20_imaginary
;to FPN_1_imaginary - FPN_5_imaginary 

resetStackImag:   
              LDX #$3301                         ;X points to the last row of the imaginary number stack
              LDY #$3388                         ;Y points to the 5th row of the imaginary number stack
              
              MOVB #$05,counter1
              
resetStackImag_1: 
              MOVB #lenFPNBytes,counter2 

resetStackImag_2: 
              LDAA 1,X+                          ;copy FPN_20_imaginary to FPN_5_imaginary, 
                                                 ;FPN_19_imaginary to FPN_4_imaginary, etc                                                 
              STAA 1,Y+
              DEC counter2
              BNE resetStackImag_2
              
              DEC counter1
              BNE resetStackImag_1
              
              RTS
              
;resetStackDenom: called when the end of the user stack has been reached. It copies FPN_16_denominator - 
;FPN_20_denominator to FPN_1_denominator - FPN_5_denominator 

resetStackDenom:   
              LDX #$33B5                         ;X points to the last row of the denominator stack
              LDY #$343C                         ;Y points to the 5th row of the denominator stack
              
              MOVB #$05,counter1
              
resetStackDenom_1: 
              MOVB #lenFPNBytes,counter2 

resetStackDenom_2: 
              LDAA 1,X+                          ;copy FPN_20_imaginary to FPN_5_imaginary, 
                                                 ;FPN_19_imaginary to FPN_4_imaginary, etc                                                 
              STAA 1,Y+
              DEC counter2
              BNE resetStackDenom_2
              
              DEC counter1
              BNE resetStackDenom_1
              
              RTS

;RORm_d: rotate 14-byte binary value starting at m_d right through the carry

RORm_d:       LDX #m_d

              MOVB #lenManBBytes2,counter1

RORm_d_1:     ROR 1,X+
              DEC counter1
              BNE RORm_d_1
                            
              RTS

;scanCol: scans the column to determine which key has been pressed                                                           

scanCol:      BRCLR PTP,#BIT5,scanCol_1          ;branch if PTP.5 is clear
                                                 ;i.e. if voltage = 0 (meaning key has been pressed)    
              INC keyNumber                      ;otherwise key has not been pressed so increment keyNumber
              BRCLR PTP,#BIT4,scanCol_1
                
              INC keyNumber
              BRCLR PTP,#BIT3,scanCol_1
                
              INC keyNumber
              BRCLR PTP,#BIT2,scanCol_1
			  
			        INC keyNumber
              BRCLR PTP,#BIT1,scanCol_1
			  
			        INC keyNumber
              BRCLR PTP,#BIT0,scanCol_1
              
              INC keyNumber
              
              BRA scanCol_2                      ;no key in this row has been pressed so exit and scan the next row              

scanCol_1:    BSET flag1,#BIT1                   ;set keyFound

scanCol_2:    RTS
              
;scanKey: scans the keypad to determine which key has been pressed

scanKey:      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS5: Place breakpoint here and 
                                                 ;set keyNumber, then continue 
              ;LBRA scanKey_2
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      

              ;MOVB #$01,counter1

;scanKey_1:    
              JSR delay                          ;timer delay to debounce the key
              ;DEC counter1
              ;BNE scanKey_1
              
              CLR keyNumber
              
              BSET PT1AD0,#BIT1                  ;PT1AD0.0 = 0 -> row A scanned
              BSET PT1AD0,#BIT2
              BSET PT1AD0,#BIT3
              BSET PT1AD0,#BIT4
              BSET PT1AD0,#BIT5
              BSET PT1AD0,#BIT6 
              BSET PT1AD0,#BIT7 
                    
              JSR scanCol                        ;scan all columns of row A
                                          
              BRSET flag1,#BIT1,scanKey_2        ;branch if keyFound set, 
                                                 ;i.e. if pressed key has been found
                                                  
              BSET PT1AD0,#BIT0                  ;PT1AD0.1 = 0 -> row B scanned
              BCLR PT1AD0,#BIT1  

              JSR scanCol                        

              BRSET flag1,#BIT1,scanKey_2

              BSET PT1AD0,#BIT1                  ;PT1AD0.2 = 0 -> row C scanned
              BCLR PT1AD0,#BIT2

              JSR scanCol                       

              BRSET flag1,#BIT1,scanKey_2
              
              BSET PT1AD0,#BIT2                  ;PT1AD0.3 = 0 -> row D scanned
              BCLR PT1AD0,#BIT3               

              JSR scanCol                
              
              BRSET flag1,#BIT1,scanKey_2
			  
			        BSET PT1AD0,#BIT3                  ;PT1AD0.4 = 0 -> row E scanned
              BCLR PT1AD0,#BIT4               

              JSR scanCol                
              
              BRSET flag1,#BIT1,scanKey_2 
              
              BSET PT1AD0,#BIT4                  ;PT1AD0.5 = 0 -> row F scanned
              BCLR PT1AD0,#BIT5               

              JSR scanCol
              
              BRSET flag1,#BIT1,scanKey_2
              
              BSET PT1AD0,#BIT5                  ;PT1AD0.6 = 0 -> row G scanned
              BCLR PT1AD0,#BIT6
              
              JSR scanCol
              
              BRSET flag1,#BIT1,scanKey_2
              
              BSET PT1AD0,#BIT6                  ;PT1AD0.7 = 0 -> row H scanned
              BCLR PT1AD0,#BIT7    
              
              JSR scanCol
              
              BRSET flag1,#BIT1,scanKey_2
              
              LBRA scanKey_7                     ;exit if pressed key not found
              
scanKey_2:    ;BCLR PORTE,#BIT0                   ;turn on BUSY LED on pin PE0
              ;BCLR PORTD,#BIT0                   ;turn on BUSY LED on pin PD0 (prototype) 
              
              BRSET flag3,#BIT6,scanKey_2_0      ;branch if in programming edit mode   

              CALL clrStatus                     ;otherwise clear "Shift"/"Alpha"/"ERROR"/"END"/"STO" on the 
                                                 ;status line, and turn off ERROR LED								              

scanKey_2_0:  BSET flag1,#BIT2                   ;set keyPressed flag as pressed key has been found       
               
              CLRA                                            

              LDAB keyNumber                          
              
              BRCLR flag1,#BIT0,scanKey_2_1      ;branch if shift not pressed
              
              ADDB #$30                          ;otherwise add number of keys = 48
              
              STAB keyNumber
              
              BCLR flag1,#BIT0                   ;clear shift flag
              
              BRA scanKey_2_2

scanKey_2_1:  ;BRCLR flag4,#BIT3,scanKey_2_2      ;branch if shift not held (shift 2) (future implementation for 
                                                  ;shift 2 plane) 

              ;ADDB #$60                          ;otherwise add 2 * number of keys = 96
              
              ;STAB keyNumber 
              
              ;BCLR flag4,#BIT3                   ;clear alpha flag

scanKey_2_2:  BRCLR flag3,#BIT6,scanKey_2_3      ;branch if not in programming edit mode
              
              LDX #keyTableTWO                   ;otherwise X = keyTableTWO when in programming edit mode
              
              LDY prgCounter    
              
              BRA scanKey_3
              
scanKey_2_3:  BRCLR flag3,#BIT4,scanKey_2_4      ;branch if sto flag clear

              BCLR flag4,#BIT7                   ;clear the updtScreen flag               

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              BCLR flag3,#BIT4                   ;clear the sto flag

              CMPB #$1D                          
              BHI scanKey_4                      ;exit if B = keyNumber value is greater than 29             
             
              LDX #DigitVal2
              ABX                                ;X = DigitVal2 + keynumber             
              
              LDAB 0,X                           ;B = value corresponding to keynumber 
                                                 ;e.g. keynumber = 0 -> B = 0, keynumber = 6 -> B = 5
              
              LDX #ms_end                        ;ms26 corresponds to the letter "Z" (key 0)
              
              LDAA #$09
              MUL                                ;multiplies value corresponding to keyNumber (in register B) with 
                                                 ;9 to determine offset
                                                 
              ABX                                ;X = ms_end + 9 * value corresponding to keyNumber
              
              STX memAddr2
              
              JSR stoFPN2            
              
              BRA scanKey_4                         

scanKey_2_4:  BRCLR flag3,#BIT1,scanKey_2_5      ;branch if rcl flag clear

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              BCLR flag3,#BIT1                   ;clear the rcl flag

              CMPB #$1D                          
              BHI scanKey_4                      ;exit if B = keyNumber value is greater than 29
              
              LDX #DigitVal2
              ABX                                ;X = DigitVal2 + keynumber             
              
              LDAB 0,X                           ;B = value corresponding to keynumber 
                                                 ;e.g. keynumber = 0 -> B = 0, keynumber = 6 -> B = 5                                                 
              STAB keyNumber              
              
              JSR rclFPN              
              
              BRA scanKey_4

scanKey_2_5:  LDX #keyTable                      ;X = keyTable when not in programming edit mode                 

scanKey_3:    ;ADDB keyNumber
              ASLD
              
              JSR keyHdlr                        
              
scanKey_4:    BCLR flag1,#BIT1                   ;clear keyFound 

              BRCLR flag3,#BIT6,scanKey_5        ;branch if not in program edit mode

              BRCLR flag4,#BIT6,scanKey_4_1      ;branch if the updtPrgScreen flag is clear
              
              BRCLR flag5,#BIT3,scanKey_4_2      ;branch if the incPrgCtr flag is clear 
              
              JSR incPrgStep
              
scanKey_4_2:  BSET flag5,#BIT3                   ;set the incPrgCtr flag               

              CALL dispPrgMenu                   ;display the program menu (to clear "STORE", "Shift 2" &
                                                 ;"Shift" annunciators)
              
              CALL updatePrgStack                ;update the program stack               
              
scanKey_4_1:  BSET flag4,#BIT6                   ;set the updtPrgScreen flag               
              
              BRA scanKey_7               

scanKey_5:    BRCLR flag4,#BIT7,scanKey_6        ;branch if the updtScreen flag is clear

              BCLR flag3,#BIT7                   ;clear the run flag
              
              CLR screenNumber                                   
              
              CALL dispMenu
              
              CALL updateStack                   ;update the stack
              
              CALL dispStatL                     ;display the status line
                            
              CALL clrComL                       ;clear the command line               
              
scanKey_6:    BSET flag4,#BIT7                   ;set the updtScreen flag                 

scanKey_7:    ;BSET PORTE,#BIT0                   ;turn off BUSY LED on pin PE0
              ;BSET PORTD,#BIT0                   ;turn off BUSY LED on pin PD0 (prototype)

              RTS

;sendByte: send a byte (command or data stored in A) to the ST7565 GLCD via the SPI1

sendByte:     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS3: exit when in Full Chip Simulation mode
              
              ;BRA sendByte_exit              
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              BRCLR SPI1SR,#BIT5,sendByte        ;if SPI1SR.5 (SPTEF) = 0 then branch to sendByte
                                                 ;i.e. loop until SPTEF = 1 (SPTEF = 1 -> SPIDR empty)                                      
            
              STAA SPI1DRL                       ;initiate data transfer and clear SPTEF
            
sendByte_1:   BRCLR SPI1SR,#BIT7,sendByte_1      ;if SPI1SR.7 (SPIF) = 0 then branch to sendByte_1
                                                 ;i.e. loop until SPIF = 1 (SPIF = 1 -> new data copied to SPIDR)
                                         
              LDAB SPI1DRL                       ;read SPI1DRL to B to clear SPIF
              
sendByte_exit:             
              RTS
              
;sendData: sends colNumber data bytes to the ST7565 display and increments Ycoord 

sendData:     LDAA 1,X+                          ;load A with the byte at the location pointed to by X, 
              JSR sendByte                      ;then increment X by 1 and send the byte to the display 

              INC Ycoord                           
                
              DEC colNumber
              BNE sendData 
								
              RTS
              
;sendData2: sends colNumber data bytes to the ST7565 display after setting the bit corresponding to the bottom pixel
;and increments Ycoord
              
sendData2:    LDAA 1,X+                          ;load A with the byte at the location pointed to by X,
                                                 ;then increment X by 1
              ORAA #$80                          ;pixel added at bottom of character to form line
              JSR sendByte

              INC Ycoord                           
                
              DEC colNumber
              BNE sendData2 
								
              RTS 

;sendData3: sends colNumber data bytes to the ST7565 display after setting the bit corresponding to the top pixel
;and increments Ycoord

sendData3:    LDAA 1,X+                          ;load A with the byte at the location pointed to by X,
                                                 ;then increment X by 1
              ORAA #$01                          ;pixel added at top of character to form line
              JSR sendByte

              INC Ycoord                           
                
              DEC colNumber
              BNE sendData3 
								
              RTS 

;setY subroutine: sets the Y coordinate on the display to the value in Ycoord and sets A0 = 1 to send data 

setY:         BCLR PTH,#BIT0                     ;A0 = 0,send command
                                
              LDAA Ycoord
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uncomment for prototype
              
              ADDA #$03
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              ADDA #$10   
              
					    JSR sendByte                      ;set MSN of column address					      
					      
					    LDAA Ycoord
					    
					    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uncomment for prototype
              
              ADDA #$03
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					    
              ANDA #$0F
                
              JSR sendByte                       ;set LSN of column address					      
					      
					    BSET PTH,#BIT0                     ;A0 = 1,send data
					      					      
					    RTS

;shFPN: set |FPN_a| to an equivalent value with a 10-digit mantissa

shFPN:        JSR lzMan                          ;determine the number of leading zeros in mantissa of |FPN_a|
              
              LDAB noZero
              CMPB #$06
              BGE shFPN_2                        ;branch if noZero >= 6
              
              LDAA #$06
              SBA                                ;A - B -> A, i.e. A = 6 - noZero
              STAA counter3
                                          
shFPN_1:      JSR divMan10
              INC e_a                            ;increment e_a to maintain equality
              DEC counter3
              BNE shFPN_1
              
              CMPA #$05
              BLO shFPN_3
                                                   
              JSR incFPN                         ;increment |FPN_a| if A >= 5
              JSR lzMan                          
              LDAA noZero
              CMPA #$06
              BEQ shFPN_3                        ;branch if noZero = 6
              
              JSR divMan10                       ;otherwise shift |FPN_a| one nibble to the right 
              INC e_a                            ;increment e_a to maintain equality
                                                 ;(for case 99,999,999,999 -> 9,999,999,999 -> 10,000,000,000)               
              BRA shFPN_3             
              
shFPN_2:      SUBB #$06
              STAB noZero                        ;noZero - 6 -> noZero
              BRA shFPN_4              

shFPN_3:      CLR noZero     

shFPN_4:      RTS

;shFPN30dig: set the positive 30-digit value starting at endm_c = $3166 to an equivalent 15-digit value and store in 
;m_a

shFPN30dig:   JSR lzMan30dig                     ;determine the number of leading zeros in the first 7 bytes
              
              LDAB noZero
              CMPB #$0E
              BGE shFPN30dig_2                   ;if noZero >= 14 then copy 8-byte portion starting at 
                                                 ;endm_d = $316D to m_a
              
              LDAA #$0E                          ;otherwise shift the 30-digit mantissa to the right first
              SBA                                ;A - B -> A, i.e. A = 14 - noZero
                                          
shFPN30dig_1: JSR divMan1030dig                  ;shift the 30-digit mantissa one nibble to the right
              INC e_a                            ;increment e_a to maintain equality
              DECA
              BNE shFPN30dig_1              
                            
shFPN30dig_2: MOVW #endm_d,memAddr1
              MOVW #m_a,memAddr2
              JSR copyMan
              
              MOVW #m_a,memAddr1
              LDX #m_a
              LDAA 0,X
              ANDA #$F0
              BEQ shFPN30dig_3                   ;exit if the MS nibble of FPN_a = 0              
              
              JSR divMan10                       ;otherwise shift the mantissa one nibble to the right
              INC e_a                            ;increment e_a to maintain equality
              LDAB 0,X
              ANDB #$0F
              STAB 0,X                           ;set the MS nibble of FPN_a to 0  
              CMPA #$05
              BLT shFPN30dig_3                   ;exit if A < 5
              JSR incFPN                         ;otherwise increment FPN_a before exiting   
              
shFPN30dig_3: RTS

;shftAdd: multiplies m_c_bin (7-byte long binary value) with m_e_bin (7-byte long binary value) using the shift 
;right and add algorithm and stores the 14-byte binary result starting at address m_d

shftAdd:      MOVB #$39,counter2                 ;counter2 = 57 index for loop
	                                               ;counter2 = no. of bytes of multiplicand/ier * 8 + 1
              CLC                                ;clear carry
              
shftAdd_1:    BCC shftAdd_2                      ;if carry is clear then only rotate m_d right throught carry
              JSR addm_cTm_d                     ;otherwise add m_c to m_d first

shftAdd_2:    JSR RORm_d                         ;rotate m_d right through carry
              DEC counter2
              BNE shftAdd_1
              
              RTS
              
;sqrtFPN: find the square root of FPN_a and store the result in FPN_a

sqrtFPN:      SUBA noZero
              DECA
              ADDA e_a                           ;A = lenMan - noZero - 1 + e_a, i.e. A is equal to the  
                                                 ;exponent of FPN_1 when it is in scientific format
                                                 
              PSHA                               ;push the exponent of FPN_1 = x onto the stack     

              ASRA                               
              PSHA                               ;push the exponent of sqrt(x) onto the stack      

              CLRB
              LDX #m_b
              MOVB #lenFPNBytes,counter1
                                                               
sqrtFPN_1:    STAB 1,X+                          ;clear FPN_b
              DEC counter1
              BNE sqrtFPN_1
              
              DEX
              DEX
              
              MOVB #$05,0,X                      ;FPN_b = 5                                                  
               
              JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a
                                                 ;i.e. FPN_1 * 5 -> FPN_a                                        
              
              LDX #e_b
              DEX
              CLR 1,X+                           ;FPN_b = 0
              
              MOVW #m_a,memAddr1
              JSR lzMan
              LDAA #lenMan 
              SUBA noZero
              DECA
              ADDA e_a                           ;A = lenMan - noZero - 1 + e_a, i.e. A is equal to the  
                                                 ;exponent of 5x = FPN_1 * 5 when it is in scientific format
                                                 
              PSHA                               ;push the exponent of 5x onto the stack
                       
              LDAB noZero
              CMPB #$02
              BLE sqrtFPN_6                      ;branch if noZero <= 2
              
              ASRA              
              BCS sqrtFPN_4                      ;branch if exponent of 5x was odd
              
              PULA                               ;A = exponent of 5x
              INS
              CMPA 0,SP                          ;compare it to exponent of x
              
              BEQ sqrtFPN_2                      ;if equal, e_b = exponent of sqrt(x) - 13
              
              DES
              PULA
              INS 
              SUBA #$0C
              STAA e_b                           ;otherwise e_b = exponent of sqrt(x) - 12 
              
              BRA sqrtFPN_3 
               
sqrtFPN_2:    DES   
              PULA
              INS 
              SUBA #$0D
              STAA e_b               
              
sqrtFPN_3:    SUBB #$03
              STAB counter3                      ;counter3 = noZero - 3
              BEQ sqrtFPN_11                     ;no need to shift m_a as exponent of 5x is even and noZero = 3
              
              BRA sqrtFPN_5

sqrtFPN_4:    SUBB #$02
              STAB counter3                      ;counter3 = noZero - 2 > 0
              
              INS                                ;ignore exponent of 5x
              PULA                               ;A = exponent of sqrt(x)
              INS                                ;ignore exponent of x
              SUBA #$0D
              STAA e_b                           ;e_b = exponent of sqrt(x) - 13 when exponent of 5x
                                                 ;is odd              
              
sqrtFPN_5:    JSR multMan10                      ;shift m_a one digit to the left ->
              DEC counter3
              BNE sqrtFPN_5                      ;<- 
              
              BRA sqrtFPN_11
              
sqrtFPN_6:    ASRA              
              BCC sqrtFPN_7                      ;branch if exponent of 5x was even
              
              INS                                ;ignore exponent of 5x
              PULA                               ;A = exponent of sqrt(x)
              INS                                ;ignore exponent of x
              SUBA #$0D
              STAA e_b                           ;e_b = exponent of sqrt(x) - 13 when exponent of 5x
                                                 ;is odd                    
              SUBB #$02
              NEGB
              STAB counter3                      ;counter3 = 2 - noZero
              BEQ sqrtFPN_11                     ;no need to shift m_a as exponent of 5x is odd and noZero = 2
              
              BRA sqrtFPN_10

sqrtFPN_7:    PULA                               ;A = exponent of 5x
              INS
              CMPA 0,SP                          ;compare it to exponent of x
              
              BEQ sqrtFPN_8                      ;if equal, e_b = exponent of sqrt(x) - 13
              
              DES
              PULA
              INS 
              SUBA #$0C
              STAA e_b                           ;otherwise e_b = exponent of sqrt(x) - 12  
              
              BRA sqrtFPN_9 
               
sqrtFPN_8:    DES   
              PULA
              INS 
              SUBA #$0D
              STAA e_b                
              
sqrtFPN_9:    SUBB #$03
              NEGB
              STAB counter3                      ;counter3 = 2 - noZero               
              
sqrtFPN_10:   JSR divMan10                       ;shift m_a one digit to the right
              DEC counter3
              BNE sqrtFPN_10
              
sqrtFPN_11:   MOVB #$01,counter3                 ;counter1, counter2 used by subroutines below

sqrtFPN_12:   LDY #m_b
              LDAB counter3
              ABY
              MOVB #$05,0,Y                      ;set counter3 byte to 05
              
              MOVW #m_b,memAddr1
              JSR negFPN                         ;negate m_b
                                 
sqrtFPN_13:   JSR addMan                         ;m_a + m_b (m_a - current value of sqrt(FPN_1)) -> m_a

              LDX #m_a
              LDAA 0,X
              ANDA #$F0                          ;set LS nibble of MS byte of m_a to 0
              BNE sqrtFPN_14                     ;branch if m_a + m_b is negative
              
              LDY #m_b                           ;otherwise increment current value of sqrt(FPN_1)
              LDAB counter3
              ABY
              LDAA 0,Y 
              SUBA #$10                          
              STAA 0,Y                   
              
              BRA sqrtFPN_13                     ;repeat until m_a + m_b is negative
              
sqrtFPN_14:   JSR negFPN                         ;make m_b positive to equal current value of sqrt(FPN_1)                        
              
              JSR addMan                         ;m_a + m_b to restore m_a to last non-negative value 
              
              MOVW #m_a,memAddr1
              
              JSR multMan10                      ;shift m_a one digit to the left
              
              MOVW #m_b,memAddr1
              
              LDY #m_b
              LDAB counter3
              ABY
              LDAA 0,Y
              ANDA #$F0
              STAA 0,Y                           ;clear 5 in counter3 byte of m_b
              
              INC counter3
              
              LDAA counter3
              CMPA #$07
              BGT sqrtFPN_17                     ;branch if m_b has been filled with digits
              
              LDY #m_b
              LDAB counter3
              ABY
              MOVB #$50,0,Y                      ;set counter3 byte to 50
              
              JSR negFPN                         ;negate m_b
                                  
sqrtFPN_15:   JSR addMan                         ;m_a + m_b (m_a - current value of sqrt(FPN_1))
                             
              LDX #m_a
              LDAA 0,X
              ANDA #$F0                          ;set LS nibble of MS byte of m_a to 0
              BNE sqrtFPN_16                     ;branch if m_a + m_b is negative
              
              LDY #m_b                           ;otherwise increment current value of sqrt(FPN_1)
              LDAB counter3
              DECB
              ABY
              LDAA 0,Y 
              SUBA #$01                          
              STAA 0,Y                           ;subtract #$01 from (counter2 - 1) byte of m_b                  
              
              BRA sqrtFPN_15                     ;repeat until m_a + m_b is negative
              
sqrtFPN_16:   JSR negFPN                         ;make m_b positive to equal current value of sqrt(FPN_1) 
              
              JSR addMan                         ;m_a + m_b to restore m_a to last non-negative value
              
              MOVW #m_a,memAddr1
              
              JSR multMan10                      ;shift m_a one digit to the left 
              
              LBRA sqrtFPN_12                    ;repeat until all digits of m_b have been filled      

sqrtFPN_17:   RTS

;stoFPN2: copy the command line/FPN_1 value to the memory stack during program execution

stoFPN2:      LDAA noDigMan
              BNE stoFPN2_2                      ;branch if the command line is not empty 
              LDD usPointer
              CPD #ms_end
              BNE stoFPN2_1                      ;branch if the calculator stack is not empty 
              BRA stoFPN2_3                      ;otherwise the command line and calculator stack are both
                                                 ;empty so exit
              
stoFPN2_1:    MOVW usPointer,memAddr1              
              JSR copyFPN                        ;(X) = FPN_1
              
              BRA stoFPN2_3 
              
stoFPN2_2:    JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,stoFPN2_2_1      ;branch if oFlow flag was not set
                   
              JSR dispError                      ;otherwise display error and terminate program execution
                            
stoFPN2_2_1:  MOVW #m_com,memAddr1              
              JSR copyFPN                        ;(X) = FPN_com
              
              JSR clrComLMem                     ;clear command line memory              
              CALL clrComL                       ;reset the command line           

stoFPN2_3:    RTS 

;subFPN: FPN_a - FPN_b -> FPN_a

subFPN:       MOVW #m_b,memAddr1
              JSR negFPN                         ;-FPN_b -> FPN_b
              
              JSR cmpExp_ab                      ;ensure exponent of FPN_a is not less than the exponent of FPN_b
                                                 ;and set diffExp              
              JSR addFPN       

              RTS
              
;subFPN_ba: FPN_b - FPN_a -> FPN_a

subFPN_ba:    MOVW #m_a,memAddr1
              JSR negFPN                         ;-FPN_a -> FPN_a
              
              JSR cmpExp_ab                      ;ensure exponent of FPN_a is not less than the exponent of FPN_b
                                                 ;and set diffExp              
              JSR addFPN       

              RTS

;tanFPN: finds Y = FPN_a and X = FPN_b such that the tangent of FPN_f (FPN_1) = Y/X  

tanFPN:       TSTA
              BMI tanFPN_6                       ;branch as e_f(s) < 0 so no need to convert m_f to angle between
                                                 ;0 and 2pi
              
              STAA e_f                           ;e_f = e_f(s)
              
              LDAA noZero
              DECA
              DECA
              STAA counter3
              
              BEQ tanFPN_2                       ;branch as FPN_f does not need to be shifted
              
              BPL tanFPN_1                       ;shift m_f counter3 nibbles to the left
              
              JSR divMan10                       ;otherwise shift m_f one nibble to the right
              CLR counter3
              BRA tanFPN_2
              
tanFPN_1:     JSR multMan10                      ;shift m_f counter3 nibbles to the left
              DEC counter3
              BNE tanFPN_1 
                                 
tanFPN_2:     LDX #m_fEnd
              LDY #negTwoPIEnd
                            
              LDAA 0,X                           ;m_f - 2pi (fixed point) ->
              ADDA 1,Y-
              DAA                                ;decimal adjust for BCD
              STAA 1,X-
              
              MOVB #$07,counter1
              
tanFPN_3:     LDAA 0,X
              ADCA 1,Y-
              DAA                                ;decimal adjust for BCD
              STAA 1,X-
              DEC counter1
              BNE tanFPN_3                       ;<-
              
              INX
              LDAA 0,X
              ANDA #$F0
              BEQ tanFPN_2                       ;subtract until m_f < 0 
              
              LDX #m_fEnd
              LDY #TwoPIEnd
                            
              LDAA 0,X                           ;restore m_f by adding 2pi (fixed point) ->
              ADDA 1,Y-
              DAA                                ;decimal adjust for BCD
              STAA 1,X-
              
              MOVB #$07,counter1
              
tanFPN_4:     LDAA 0,X
              ADCA 1,Y-
              DAA                                ;decimal adjust for BCD
              STAA 1,X-
              DEC counter1
              BNE tanFPN_4                       ;<-
              
              DEC e_f
              BMI tanFPN_5                       ;branch as 0 =< FPN_1 < 2pi
              
              JSR multMan10                      ;otherwise shift m_f one nibble to the left and repeat
              BRA tanFPN_2              
              
tanFPN_5:     MOVB #$F3,e_f                      ;set e_f = -13
              BRA tanFPN_9     

tanFPN_6:     ADDA noZero
              DECA 
              DECA                               ;A = noZero - (2 - e_f(s)), where e_f(s) is the exponent of 
                                                 ;FPN_f when it is in scientific format. This determines by how many
                                                 ;nibbles m_f needs to be shifted to the left/right
              STAA counter3                                    
              
              BEQ tanFPN_9                       ;branch if counter3 = 0, i.e. when m_f does not need to be shifted
              BPL tanFPN_8                       ;branch if counter3 > 0, i.e. when m_f needs to be shifted counter3 
                                                 ;nibbles to the left
              NEG counter3                       ;otherwise counter3 < 0 and m_f needs to be shifted -counter3
                                                 ;nibbles to the right  
tanFPN_7:     JSR divMan10                       ;shift m_f counter3 nibbles to the right -> 
              DEC counter3
              BNE tanFPN_7                       ;<-                                              
              
              BRA tanFPN_9       
              
tanFPN_8:     JSR multMan10                      ;shift m_f counter3 nibbles to the left ->
              DEC counter3
              BNE tanFPN_8                       ;<-
              
                                                 ;K = counter3 = 0   

tanFPN_9:     LDX #m_b                           ;set X = FPN_b = 1 = 00 10 00 00 00 00 00 00 00 ->
              MOVB #$00,1,X+
              MOVB #$10,1,X+
              
              CLRA
              MOVB #07,counter1
tanFPN_10:    STAA 1,X+
              DEC counter1
              BNE tanFPN_10                      ;<-
              
              LDX #m_a                           ;set Y = FPN_a = 0 = 00 00 00 00 00 00 00 00 00 ->

              MOVB #lenFPNBytes,counter1
tanFPN_11:    STAA 1,X+
              DEC counter1
              BNE tanFPN_11                      ;<-       

                                                 ;K = counter3 = 0               
              
tanFPN_12:    JSR lzMan                          ;determine number of leading zeros in m_f              
              LDAA noZero
              CMPA #lenMan
              LBEQ tanFPN_22                     ;long branch if theta = m_f = 0
              
tanFPN_13:    LDX #tanAngles
	            LDAB counter3
              ASLB
              LDY B,X                            ;Y points to arctan(10^-K)
              
              LDX #m_f
              
              MOVB #$08,counter1                 ;number of bytes to compare
              
tanFPN_14:    LDAA 1,X+
              CMPA 1,Y+
              BHI tanFPN_16                      ;branch if m_f > arctan(10^-K)
              BLO tanFPN_15                      ;branch if m_f < arctan(10^-K)
              DEC counter1
              BNE tanFPN_14                      ;otherwise bytes are equal so compare the next byte
              BRA tanFPN_16                      ;m_f = arctan(10-K)
              
tanFPN_15:    INC counter3                       ;increment K and repeat
              BRA tanFPN_13
              
tanFPN_16:    LDX #negTanAngles                  
	            LDAB counter3
              INCB
              ASLB
              LDY B,X                            ;Y points to -arctan(10^-(K+1))
              DEY                                ;Y points to LS byte of -arctan(10^-K)

              LDX #m_fEnd                        ;X points to LS byte of m_f
              
              MOVB #$07,counter1
              
              LDAA 0,X                           ;m_f - arctan(10^-K) -> m_f ->
              ADDA 1,Y-
              DAA
              STAA 1,X-
              
tanFPN_17:    LDAA 0,X
              ADCA 1,Y-
              DAA
              STAA 1,X-
              
              DEC counter1
              BNE tanFPN_17                      ;<-
              
              MOVW #m_b,memAddr1
              MOVW #m_g,memAddr2
              JSR copyMan                        ;TEMP = m_g = m_b = X
              
              MOVW #m_a,memAddr1
              MOVW #m_h,memAddr2
              JSR copyMan                        ;TEMP2 = m_h = m_a = Y
              
              MOVB counter3,counter4
              TST counter4
              BEQ tanFPN_19                      ;do not shift Y if K = 0
              
tanFPN_18:    JSR divMan10                       
              DEC counter4
              BNE tanFPN_18
              
tanFPN_19:    JSR negFPN                         ;negate Y
              
              JSR addMan                         ;m_b + m_a -> m_a, i.e.
                                                 ;X - 10^-K * Y -> m_a
                                                 
              MOVW #m_b,memAddr2              
              JSR copyMan                        ;m_a -> m_b, i.e X - 10^-K * Y -> X 
                                                 
              MOVW #m_g,memAddr1
              
              MOVB counter3,counter4
              TST counter4
              BEQ tanFPN_21                      ;do not shift TEMP if K = 0
              
tanFPN_20:    JSR divMan10                       ;multiply TEMP = m_g by 10^-K
              DEC counter4
              BNE tanFPN_20
              
tanFPN_21:    JSR addMan2                        ;m_h + m_g -> m_h
                                                 ;i.e. Y + 10^-K * TEMP -> m_h
                                                 
              MOVW #m_h,memAddr1
              MOVW #m_a,memAddr2
              JSR copyMan                        ;m_h -> m_a, i.e. Y + 10^-K * TEMP -> Y
              
              MOVW #m_f,memAddr1
              
              LBRA tanFPN_12                     ;repeat              
              
tanFPN_22:    RTS       

;tzFPN: eliminates any trailing zeros in the mantissa of FPNM1 = FPN_a, where FPN_a <> 0

tzFPN:        JSR divMan10                       ;shift mantissa of FPN_a one nibble right into A                      
              TSTA
              BNE tzFPN_1                        ;recover if nibble is not zero
              INC e_a                            ;otherwise increment e_a and noZero as the 
                                                 ;mantissa of FPN_a has been shifted one nibble to the right
              INC noZero
              BRA tzFPN 
            
tzFPN_1:      STAA keyValue  
              JSR multMan10add                   ;shift the mantissa of FPN_a one nibble to the left and 
                                                 ;add keyValue to restore the mantissa to its original value           
              RTS

;tzFPN_b: eliminates any trailing zeros in the mantissa of FPNM1 = FPN_b, where FPN_b <> 0

tzFPN_b:      JSR divMan10                       ;shift mantissa of FPN_b one nibble right into A                      
              TSTA
              BNE tzFPN_b_1                      ;recover if nibble is not zero
              INC e_b                            ;otherwise increment e_b as the mantissa of FPN_b has been shifted 
                                                 ;one nibble to the right             
              BRA tzFPN_b 
            
tzFPN_b_1:    STAA keyValue  
              JSR multMan10add                   ;shift the mantissa of FPN_b one nibble to the left and 
                                                 ;add keyValue to restore the mantissa to its original value           
              RTS

;tzFPN_f: eliminates any trailing zeros in the mantissa of FPNM1 = FPN_f, where FPN_f <> 0

tzFPN_f:      JSR divMan10                       ;shift mantissa of FPN_f one nibble right into A                      
              TSTA
              BNE tzFPN_f_1                      ;recover if nibble is not zero
              INC e_f                            ;otherwise increment e_f as the mantissa of FPN_f has been shifted 
                                                 ;one nibble to the right             
              BRA tzFPN_f 
            
tzFPN_f_1:    STAA keyValue  
              JSR multMan10add                   ;shift the mantissa of FPN_f one nibble to the left and 
                                                 ;add keyValue to restore the mantissa to its original value           
              RTS
				  
;******************key functions*****************

;Key 0: Addition;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

Add:          BRSET flag4,#BIT2,key12_27         ;branch if in exact number mode        

              BRCLR flag4,#BIT1,key12_26         ;branch if not in complex number mode
              
              LBRA key12_11

key12_26:     LBRA key12_10              
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;c   d :rational on stack level 1
                                                 ;a   b ;rational on stack level 2
key12_27:     TST noDigMan
              LBEQ key12_33                      ;branch if the command line is empty
              
              ;LDD usPointer
              ;CPD #ms_end
              ;BNE key12_28                       ;branch if the stack is non-empty
              ;BCLR flag4,#BIT7                   ;clear updtScreen flag
              ;LBRA key12_6                       ;exit as the user stack depth = 0
              
              ;************************************
              
              LDD usPointer
              CPD #ms_end
              BNE key12_28                       ;branch if the stack is non-empty
              
              BRCLR flag1,#BIT5,key12_27_3       ;branch if sub flag clear 
              
              BRCLR flag2,#BIT4,key12_27_1       ;branch if manNeg flag clear
              
              BCLR flag2,#BIT4                   ;clear the manNeg flag
              
              BRA key12_27_2              
              
key12_27_1:   BSET flag2,#BIT4                   ;set the manNeg flag

key12_27_2:   BCLR flag1,#BIT5                   ;clear the sub flag               
              
key12_27_3:   JMP Ente                           ;simulate "Enter" press
              
              ;************************************
              
key12_28:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key12_29         ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              LBRA key12_6                                    
 
key12_29:     LDD usPointer
              CPD #$2000
              BNE key12_30                       ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackDenom
              
              LDD usPointer
              ADDD #lenFPNBytes
              
key12_30:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer              
              STD memAddr2
              
              PSHD
              
              MOVW #m_com,memAddr1               
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              PULD
              PSHD
              
              ADDD #$13B5                        
              
              TFR D,X                            ;X points to FPN_1_denominator
              
              CLRA
              MOVB #lenManBBytes,counter1
              
key12_31:     STAA 1,X+                          ;set mantissa of denominator to 1 ->
              DEC counter1
              BNE key12_31
              
              MOVB #$01,0,X                      ;<-
              
              PULD
              PSHD              

              ADDD #lenManBytes                  
              TFR D,X                            ;X points to exponent of FPN_1_numerator
              
              LDAA 0,X                           ;A = exponent of FPN_1_numerator
              BPL key12_32                        ;if exponent of FPN_1_numerator >= 0 set exponent of 
                                                 ;FPN_1_denominator to 0
              
              CLR 0,X                            ;otherwise set exponent of FPN_1_numerator to 0 and exponent of 
                                                 ;FPN_1_denominator to NEGA
              NEGA              
              PSHA
              
              INS
              
              PULD
                            
              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              DES
              DES
              DES
              
              PULA
              
              INS
              INS
              
              STAA 0,X                           ;set exponent of FPN_1_denominator to NEGA               
                           
              BRA key12_34  
              
key12_32:     PULD
              
              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              MOVB #$00,0,X                      ;set exponent of FPN_1_denominator to 0               
                             
              BRA key12_34               
              
key12_33:     JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key12_34                       ;branch if the user stack depth > 1
              LBRA key12_6                       ;return to scanKey subroutine as the user stack depth = 0 or 1
              
key12_34:     BRCLR flag1,#BIT5,key12_35         ;branch if sub flag is clear, i.e. "-" key was not pressed

              MOVW usPointer,memAddr1
              JSR negFPN                         ;otherwise negate FPN_1
              BCLR flag1,#BIT5      

key12_35:     ;a/b + c/d ->
              
              LDD usPointer
              ADDD #$13B5
              STD memAddr1            
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;d -> FPN_a
                  
              LDD usPointer
              ADDD #$13BE
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;b -> FPN_b
              
              ;bd ->
              
              JSR chkExp                         ;check e_a + e_b for overflow/underflow
              
              BRCLR flag2,#BIT5,key12_37         ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36                              
              
key12_37:     BRCLR flag2,#BIT6,key12_38         ;branch if the uFlow flag was not set
                            
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36                                                                                                          
               
key12_38:     JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a

              BRCLR flag2,#BIT4,key12_39         ;branch if bd should be positive
              
              JSR negFPN                         ;otherwise negate it first

key12_39:     JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key12_40         ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36         

key12_40:     BRCLR flag2,#BIT6,key12_41         ;branch if the uFlow flag was not set

              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36      

key12_41:     JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key12_42                       ;branch if FPN_a <> 0 
               
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36
              
              ;<- end bd
              
key12_42:     MOVW #m_a,memAddr1
              MOVW #m_h,memAddr2
              JSR copyFPN                        ;bd -> FPN_h 
              
              MOVW usPointer,memAddr1            
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;c -> FPN_a
                  
              LDD usPointer
              ADDD #$13BE
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;b -> FPN_b
              
              ;bc ->
              
              JSR chkExp                         ;check e_a + e_b for overflow/underflow
              
              BRCLR flag2,#BIT5,key12_43         ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36                              
              
key12_43:     BRCLR flag2,#BIT6,key12_44         ;branch if the uFlow flag was not set
                            
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36
              ;actually, bc = 0 -> continue                                                                                                          
               
key12_44:     JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a

              BRCLR flag2,#BIT4,key12_45         ;branch if bc should be positive
              
              JSR negFPN                         ;otherwise negate it first

key12_45:     JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key12_46         ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36         

key12_46:     BRCLR flag2,#BIT6,key12_47         ;branch if the uFlow flag was not set

              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36
              ;actually, bc = 0 -> continue 
              
              ;<- end bc     

key12_47:     MOVW #m_a,memAddr1
              MOVW #m_i,memAddr2
              JSR copyFPN                        ;bc -> FPN_i
              
              LDD usPointer
              ADDD #$09
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;a -> FPN_a
              
              LDD usPointer
              ADDD #$13B5
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;d -> FPN_b
              
              ;ad ->
              
              JSR chkExp                         ;check e_a + e_b for overflow/underflow
              
              BRCLR flag2,#BIT5,key12_48         ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36                              
              
key12_48:     BRCLR flag2,#BIT6,key12_49         ;branch if the uFlow flag was not set
                            
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36
              ;actually, ad = 0 -> continue                                                                                                          
               
key12_49:     JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a
                            
              BRCLR flag2,#BIT4,key12_50         ;branch if product should be positive 
              JSR negFPN                         ;otherwise negate it first 

key12_50:     JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key12_51         ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key12_36         

key12_51:     BRCLR flag2,#BIT6,key12_52         ;branch if the uFlow flag was not set
                            
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key0_8
              ;actually, ad = 0 -> continue
              
              ;<- end ad 

key12_52:     MOVW #m_i,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = bc
              
              JSR cmpExp_ab
              
              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a , i.e ad + bc -> FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_g,memAddr2
              JSR copyFPN                        ;FPN_g = ad + bc
              
              MOVW #m_h,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;bd -> FPN_b
              
              MOVW #m_b,memAddr1
              JSR tzFPN_b                        ;eliminate trailing zeros from FPN_b
              JSR absFPN                         ;set to absolute value if required
              
              MOVW #m_a,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key12_57                       ;branch if FPN_a = ad + bc <> 0
              
              ;otherwise increment usPointer and set numerator to 0, denominator to 1 ->
              
              LDD usPointer
              ADDD #$09
              STD usPointer
              TFR D,X
              
              CLRA              
              MOVB #$09,counter1
              
key12_58:     STAA 1,X+                          ;set FPN_1_numerator = 0 ->
              DEC counter1
              BNE key12_58                       ;<-
              
              LDD usPointer
              ADDD #$13B5
              TFR D,X
              
              CLRA              
              MOVB #$07,counter1
              
key12_59:     STAA 1,X+                          ;set FPN_1_denominator = 1 ->
              DEC counter1
              BNE key12_59
              
              MOVB #$01,1,X+
              
              STAA 0,X
              
              LBRA key12_56
               
              ;<- 
              
key12_57:     JSR tzFPN                          ;otherwise eliminate trailing zeros from FPN_a
              JSR absFPN                         ;set to absolute value if required 
              
              JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b
                                                 
              MOVB e_b,power                     ;result will be multiplied by 10^power
              
              LDAA e_a                           ;divide FPN_a,b by 10^power
              SUBA e_b
              STAA e_a
              
              CLR e_b
                            
              JSR lzMan   
              
              LDAA noZero
              SUBA e_a
              DECA
              
              BPL key12_53
                                                 ;otherwise don't reduce fraction to simplest form as FPN_a is too
                                                 ;big to find GCD ->              
              MOVW #m_g,memAddr1              
              LDD usPointer
              ADDD #$09
              STD usPointer                      ;increment usPointer
              STD memAddr2
              JSR copyFPN                        ;ac (unsimplified) -> usPointer + 9 (previously a)
              
              MOVW #m_h,memAddr1              
              LDD usPointer
              ADDD #$13B5
              STD memAddr2
              JSR copyFPN                        ;bc (unsimplified) -> usPointer + 13B5 (previously b)
              
              BRA key12_56                       ;<-
                               
key12_53:     JSR GCDFPN_ab                      ;determine GCD of numerator and denominator and store BCD result
                                                 ;in FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;GCD(ad + bc,bd) -> FPN_b
              
              MOVW #m_g,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;ad + bc -> FPN_a 
              
              JSR divFPN                         ;(ad + bc)/GCD(ad + bc,bd) -> FPN_a
              
              BRCLR flag2,#BIT4,key12_54         ;branch if result should be positive
              
              JSR negFPN                         ;otherwise negate it first
              
key12_54:     MOVW #m_a,memAddr1              
              LDD usPointer
              ADDD #$09
              STD usPointer                      ;increment usPointer
              STD memAddr2
              JSR copyFPN                        ;simplified numerator -> usPointer + 9 (previously a) 
              
              MOVW #m_h,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;bd -> FPN_a 
              
              JSR divFPN                         ;bd/GCD(ad + bc,bd) -> FPN_a
              
              BRCLR flag2,#BIT4,key12_55         ;branch if result should be positive
              
              MOVW usPointer,memAddr1              
              JSR negFPN                         ;otherwise negate simplified numerator to maintain equality 
              
key12_55:     MOVW #m_a,memAddr1              
              LDD usPointer
              ADDD #$13B5
              STD memAddr2
              JSR copyFPN                        ;simplified denominator -> usPointer + 13B5 (previously b)

key12_56:     JSR clrComLMem                     ;clear command line memory
              
              ;<- end a/b + c/d 
              
              LBRA key12_36              
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;not exact, not complex

key12_10:     TST noDigMan
              BEQ key12_3                        ;branch if the command line is empty
              
              LDD usPointer
              CPD #ms_end
              BNE key12_6_0                      ;branch if the stack is non-empty
              
              BRCLR flag1,#BIT5,key12_9          ;branch if sub flag clear 
              
              BRCLR flag2,#BIT4,key12_7          ;branch if manNeg flag clear
              
              BCLR flag2,#BIT4                   ;clear the manNeg flag
              
              BRA key12_8              
              
key12_7:      BSET flag2,#BIT4                   ;set the manNeg flag

key12_8:      BCLR flag1,#BIT5                   ;clear the sub flag               
              
key12_9:      JMP Ente                           ;simulate "Enter" press             
              
key12_6_0:    BRCLR flag3,#BIT3,key12_6_2        ;branch if not in Hex/Bin mode
              
              JSR cmdToBCD                       ;otherwise convert the command line value to BCD
              
              BRA key12_6_1
              
key12_6_2:    JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key12_6_1        ;branch if oFlow flag was not set
              
              BCLR flag1,#BIT5                   ;otherwise clear sub flag, display "ERROR" and return to 
              BRA key12_4_2                      ;scanKey subroutine                        

key12_6_1:    LDD usPointer
              CPD #$2000
              BNE key12_1                        ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key12_2                         
                                                  
key12_1:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key12_2:      MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack  
               
              BRA key12_4                       
              
key12_3:      JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key12_4                        ;branch if the user stack depth > 1
              BRA key12_6                        ;exit as the user stack depth = 0 or 1 

key12_4:      BRCLR flag1,#BIT5,key12_4_1        ;branch if sub flag is clear, i.e. "-" key was not pressed

              MOVW usPointer,memAddr1           
                            
              JSR negFPN                         ;otherwise negate FPN_1      

key12_4_1:    JSR cmpExp                         ;FPN_1/2 -> FPN_a/b (FPN with larger exponent copied to FPN_a)               

              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a              
              
              JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow (underflow impossible when adding two
                                                 ;FPN's)
              BRCLR flag2,#BIT5,key12_5          ;branch if oFlow flag was not set
              
key12_4_2:    BRCLR flag2,#BIT7,key12_4_3        ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key12_4_3:    BRCLR flag1,#BIT5,key12_4_4        ;branch if sub flag is clear, i.e. "-" key was not pressed

              MOVW usPointer,memAddr1           
                            
              JSR negFPN                         ;otherwise negate FPN_1   

key12_4_4:    JSR dispError                      ;display "ERROR" on the status line and exit  
              BRA key12_6                       
                                                
key12_5:      JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key12_5_1                      ;branch if FPN_a <> 0  
              CLR e_a                            ;otherwise clear e_a (for cases when algorithm returns e.g. 0 50)
              
key12_5_1:    LDD usPointer
              ADDD #lenFPNBytes                  
              STD usPointer                      ;increment usPointer
              
              STD memAddr2                       ;memAddr2 = usPointer
              
              JSR copyFPN                        ;m_a -> usPointer
                        
              JSR clrComLMem                     ;clear command line memory
              
key12_6:      BCLR flag1,#BIT5                   ;clear the sub flag
              
key12_36:     JMP keyHdlr_1                      ;return to scanKey subroutine
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;add complex numbers
              
key12_11:     TST noDigMan
              BEQ key12_25                       ;branch if the command line is empty
              
              ;LDD usPointer
              ;CPD #ms_end
              ;BNE key12_21                       ;branch if the stack is non-empty
              ;BCLR flag4,#BIT7                   ;clear updtScreen flag
              ;BRA key12_6                        ;exit as the user stack depth = 0
              
              ;************************************
              
              LDD usPointer
              CPD #ms_end
              BNE key12_21                       ;branch if the stack is non-empty
              
              BRCLR flag1,#BIT5,key12_11_3       ;branch if sub flag clear 
              
              BRCLR flag2,#BIT4,key12_11_1       ;branch if manNeg flag clear
              
              BCLR flag2,#BIT4                   ;clear the manNeg flag
              
              BRA key12_11_2              
              
key12_11_1:   BSET flag2,#BIT4                   ;set the manNeg flag

key12_11_2:   BCLR flag1,#BIT5                   ;clear the sub flag               
              
key12_11_3:   JMP Ente                           ;simulate "Enter" press
              
              ;************************************
              
key12_21:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key12_22         ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              BRA key12_6                                    
 
key12_22:     LDD usPointer
              CPD #$2000
              BNE key12_23                       ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackImag
              
              LDD usPointer
              ADDD #lenFPNBytes
              
key12_23:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              STD memAddr2
              
              PSHD       
              
              MOVW #m_com,memAddr1                  
              
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              PULD                               ;set imaginary part to 0->              
              ADDD #$1301                        
              
              TFR D,X                            ;X points to the corresponding imaginary part
              
              CLRA
              MOVB #lenFPNBytes,counter1
              
key12_24:     STAA 1,X+
              DEC counter1
              BNE key12_24                       ;<-
              
              BRA key12_12
              
key12_25:     JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key12_12                       ;branch if the user stack depth > 1
              LBRA key12_6                       ;return to scanKey subroutine as the user stack depth = 0 or 1
              
key12_12:                                        ;add/subtract real parts ->
              BRCLR flag1,#BIT5,key12_13         ;branch if sub flag is clear, i.e. "-" key was not pressed

              MOVW usPointer,memAddr1           
                            
              JSR negFPN                         ;otherwise negate FPN_1      

key12_13:     JSR cmpExp                         ;FPN_1/2 -> FPN_a/b (FPN with larger exponent copied to FPN_a)               

              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a              
              
              JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow (underflow impossible when adding two
                                                 ;FPN's)
              BRCLR flag2,#BIT5,key12_15         ;branch if oFlow flag was not set

              BRCLR flag1,#BIT5,key12_14         ;branch if sub flag is clear, i.e. "-" key was not pressed

              MOVW usPointer,memAddr1           
                            
              JSR negFPN                         ;otherwise negate FPN_1   

key12_14:     JSR dispError                      ;display "ERROR" on the status line and exit  
              LBRA key12_6                       
                                                
key12_15:     JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key12_16                       ;branch if FPN_a <> 0  
              CLR e_a                            ;otherwise clear e_a (for cases when algorithm returns e.g. 0 50)
              
key12_16:     MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_a = sum/difference of real parts copied to FPN_f
                                                 ;<-
                                                 
                                                 ;add/subtract imaginary parts ->
              LDD usPointer
              ADDD #$1301
                                                 
              BRCLR flag1,#BIT5,key12_17         ;branch if sub flag is clear, i.e. "-" key was not pressed

              STD memAddr1           
                            
              JSR negFPN                         ;otherwise negate FPN_1_imaginary      

key12_17:     JSR cmpExpIm                       ;FPN_1/2_imaginary -> FPN_a/b (FPN with larger exponent copied to 
                                                 ;FPN_a)               

              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a              
              
              JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow (underflow impossible when adding two
                                                 ;FPN's)
              BRCLR flag2,#BIT5,key12_19         ;branch if oFlow flag was not set

              BRCLR flag1,#BIT5,key12_18         ;branch if sub flag is clear, i.e. "-" key was not pressed

              LDD usPointer
              ADDD #$1301
              
              STD memAddr1            
                            
              JSR negFPN                         ;otherwise negate FPN_1_imaginary   

key12_18:     JSR dispError                      ;display "ERROR" on the status line and exit  
              LBRA key12_6                       
                                                
key12_19:     JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key12_20                       ;branch if FPN_a <> 0  
              CLR e_a                            ;otherwise clear e_a (for cases when algorithm returns e.g. 0 50)
                                                 ;<-
key12_20:     LDD usPointer
              ADDD #lenFPNBytes                  
              STD usPointer                      ;increment usPointer
              
              PSHD
              
              MOVW #m_f,memAddr1
              STD memAddr2                       ;memAddr2 = usPointer
              
              JSR copyFPN                        ;sum/difference of real parts -> usPointer
              
              PULD
              ADDD #$1301
              STD memAddr2
              
              MOVW #m_a,memAddr1
              
              JSR copyFPN                        ;sum/difference of imaginary parts -> usPointer + $1301
                        
              JSR clrComLMem                     ;clear command line memory
              
              LBRA key12_6
              
;Key 1: delete the rightmost character from the command line/drop one stack level
          
Dele:         LDAA noDigMan         
              LBEQ key15S_2                      ;DROP if the command line is empty
              
              BCLR flag4,#BIT7                   ;clear updtScreen flag            
                            
              BRCLR flag2,#BIT0,key15S_1         ;branch if exponent entry field not active
              
              CALL clrExp                        ;otherwise clear the exponent field and cursor            
              
              JMP keyHdlr_1                      ;return to scanKey subroutine                           
           
key15S_1:     LDAA Ycoord                        ;clear digit from mantissa
              SUBA #wFont
              STAA Ycoord
              STAA savedY           
              JSR setY
              
              CALL clrChar                       ;clear the character
              CALL clrChar                       ;clear the cursor
              
              MOVB savedY,Ycoord
              JSR setY
                            
              BRCLR flag4,#BIT0,key1_0           ;branch if bin flag clear
              
              BRSET flag5,#BIT7,key1_0           ;branch if 2-adic flag set
              
              CLC                                ;otherwise clear the carry
              
              MOVW #m_com,memAddr1
              JSR manROR                         ;ROR the current command line mantissa value
              
              DEC noDigMan
              
              BRA key15S_5                       ;return to scanKey subroutine
              
key1_0:       BRCLR flag2,#BIT1,key15S_1_2       ;branch if the decimal point/tick has not been pressed
                         
              TST noDigDp
              BNE key15S_1_1                     ;branch if digits have been entered after the decimal point/tick
              
              MOVW #m_com,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BEQ key15S_1_0                     ;branch if the command line = 0,i.e. entered value was 0./0' 
              
              BCLR flag2,#BIT1                   ;otherwise clear dpPressed flag and exit,as the decimal point has 
                                                 ;been pressed and no further digits entered              
              BRA key15S_5                       ;return to scanKey subroutine
              
key15S_1_0:   JSR clrComLMem                     ;clear flag2 and related variables

              CALL clrComL                       ;clear the entire command line and exit
                        
              BRA key15S_5                       ;return to scanKey subroutine                                        
                                                  
key15S_1_1:   DEC noDigDp             
              
key15S_1_2:   DEC noDigMan

              BRCLR flag5,#BIT7,key15S_6         ;branch if not in 2-adic mode
              
              CLC                                ;otherwise clear the carry
              
              MOVW #m_com,memAddr1
              JSR manROR                         ;ROR the current command line mantissa value
              
              BRA key15S_7 
              
key15S_6:     MOVW #m_com,memAddr1
              JSR divMan10                       ;divide m_com by 10
              
key15S_7:     LDAA noDigMan
              BNE key15S_5                       ;exit if there was more than one character on the command line
              
              JSR clrComLMem                     ;otherwise clear flag2 and related variables 

              CALL clrComL                       ;clear the entire command line and exit (deletes "-" if present)
              
              BRA key15S_5                       ;return to scanKey subroutine
              
key15S_2:     LDD usPointer
              CPD #ms_end
              BEQ key15S_5                       ;exit as the stack is empty
              
              ADDD #lenFPNBytes                  ;otherwise increment usPointer, i.e. drop one stack level
              STD usPointer              
              
key15S_5:     JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 2: decimal point;;;;;;;;;;;;;;;;;;;;;;;;;;;

DePo:         BRSET flag2,#BIT0,key2S_2          ;exit if expPressed or dpPressed set
              BRSET flag2,#BIT1,key2S_2
              
              BRSET flag5,#BIT7,key2S_3          ;branch if in 2-adic mode
              
              BRSET flag3,#BIT3,key2S_2          ;exit if in Hex/Bin mode

key2S_3:      BSET flag2,#BIT1                   ;set dpPressed
              BCLR flag2,#BIT2                   ;clear zf
              
              TST noDigMan                       ;noDigMan = 0 -> display "0"
              BNE key2S_1
              
              INC noDigMan
              
              BRSET flag3,#BIT7,key2S_2          ;do not display "0" or "." if in run mode   
               
              LDX #Digit
              MOVB #wFont,colNumber
              JSR sendData
              
key2S_1:      JSR dispDp

key2S_2:      BCLR flag4,#BIT7                   ;clear updtScreen flag     

              JMP keyHdlr_1                      ;return to scanKey subroutine              

;Key 3: 0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Zero:         BRCLR flag4,#BIT0,key3_0           ;branch if not in Bin mode

              LDAA noDigMan                      ;exit if noDigMan = 15
              CMPA #$0F
              BEQ key2_5         

              CLC                                ;clear the carry         

              MOVW #m_com,memAddr1
              JSR manROL                         ;ROL the current command line mantissa value
              
              INC noDigMan
              
              BRCLR flag2,#BIT1,key2_7           ;branch if tick not pressed in 2-adic mode
              
              INC noDigDp                        
              
key2_7:       BRA key2_4                         ;display "0" and exit 

key3_0:       BRCLR flag2,#BIT0,key2_1           ;branch to key2_1 if expPressed clear
           
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              LDAA noDigExp                      ;exit if noDigExp = maxLenExp
              CMPA #maxLenExp
              BEQ key2_5
              
              CMPA #$00                          ;exit if noDigExp = 0 (i.e first digit of exponent cannot be 0)
              BEQ key2_5
              
              INC noDigExp                       ;increment noDigExp if 0 is not the first digit
              MOVW #e_com,memAddr1
              JSR multBin10                      ;multiply the current command line exponent value by 10
              
              BRA key2_4
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;              
key2_1:       BRCLR flag3,#BIT2,key2_1_1         ;branch if not in Hex mode

              LDAA noDigMan                      ;exit if noDigMan = 13
              CMPA #$0D
              BEQ key2_5
              
              BRA key2_2 

key2_1_1:     LDAA noDigMan                      ;exit if noDigMan = maxLenMan
              CMPA #$0F
              BEQ key2_5
              
              BRCLR flag2,#BIT1,key2_2           ;branch to key2_2 if dpPressed clear
              INC noDigDp                           
              BRA key2_3
              
key2_2:       BRSET flag2,#BIT2,key2_5           ;exit if zf is set

              LDAA noDigMan                      ;branch to key2_3 if noDigMan <> 0
              BNE key2_3
              
              BSET flag2,#BIT2                   ;set zf as the first digit is 0 
              
key2_3:       INC noDigMan

              MOVW #m_com,memAddr1            
              JSR multMan10                      ;multiply the current command line mantissa value by 10
              
key2_4:       BRSET flag3,#BIT7,key2_6           ;do not display "0" if in run mode       

              LDX #Digit                         ;otherwise display "0"
              MOVB #$08,colNumber
              JSR sendData           

key2_5:       BCLR flag4,#BIT7                   ;clear updtScreen flag      

key2_6:       JMP keyHdlr_1                      ;return to scanKey subroutine
             
;Key 4: toggle "-" on the command line/user stack and set the appropriate flags.

PlMi:         TST noDigMan                       
              BEQ key8S_6                        ;negate FPN_1 if the command line is empty
              
              BCLR flag4,#BIT7                   ;clear updtScreen flag
             
              BRCLR flag3,#BIT3,key8S_0_0        ;branch if not in Bin/Hex mode
              
              LBRA key8S_7                       ;otherwise exit
              
key8S_0_0:    BRCLR flag2,#BIT0,key8S_3          ;if expPressed is clear then toggle sign of mantissa
              CALL moveCursor                    ;otherwise move cursor to position to display sign of exponent              
              BRCLR flag2,#BIT3,key8S_1          ;if expNeg clear display "-"
              LDX #Space                         ;otherwise erase "-"
              BCLR flag2,#BIT3
              BRA key8S_2
              
key8S_1:      LDX #Minus
              BSET flag2,#BIT3
              
key8S_2:      MOVB #wFont,colNumber
              JSR sendData
              
              MOVB savedY,Ycoord                 ;return cursor to initial position
              JSR setY
              
              BRA key8S_7                        ;exit
              
key8S_3:      MOVB Ycoord,savedY                 ;save position of cursor in mantissa 
              CLR Ycoord                         ;move cursor to beginning of line
              JSR setY
              
              BRCLR flag2,#BIT4,key8S_4          ;if manNeg clear display "-"
              LDX #Space                         ;otherwise erase "-"
              BCLR flag2,#BIT4
              BRA key8S_5
              
key8S_4:      LDX #Minus
              BSET flag2,#BIT4
              
key8S_5:      MOVB #wFont,colNumber
              JSR sendData
              
              MOVB savedY,Ycoord                 ;return cursor to initial position
              JSR setY
              
              BRA key8S_7                        ;exit
              
key8S_6:      JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              TSTA
              BEQ key8S_7                        ;exit if the user stack depth = 0

              MOVW usPointer,memAddr1                            
              JSR negFPN                         ;otherwise negate FPN_1
              
              BRCLR flag4,#BIT1,key8S_7          ;exit if not in complex number mode
              
              LDD usPointer
              ADDD #$1301
              STD memAddr1
              
              JSR negFPN                         ;otherwise negate FPN_1_imaginary
                            
key8S_7:      JMP keyHdlr_1                      ;return to scanKey subroutine  
              
;NOKEY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NOKEY:        JMP keyHdlr_1                      ;return to scanKey subroutine 
              
;Key 6: Subtraction;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

Minu:         BSET flag1,#BIT5                   ;set sub flag
              
              JMP Add                            ;jump to Addition code 
              
;Key 7: 3;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Thre:         BRCLR flag4,#BIT0,key7_1           ;continue if not in Bin mode        

              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag and exit
              
              BRA key7_2
              
key7_1:       MOVB #$03,keyValue                          

              JSR nzKey

key7_2:       JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key 8: 2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Two:          BRCLR flag4,#BIT0,key8_1           ;continue if not in Bin mode

              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag and exit
              
              BRA key8_2
              
key8_1:       MOVB #$02,keyValue                          

              JSR nzKey

key8_2:       JMP keyHdlr_1                      ;return to scanKey subroutine                         

;Key 9: 1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

One:          BRCLR flag4,#BIT0,key9_1           ;branch if not in Bin mode

              LDAA noDigMan                      ;exit if noDigMan = 15
              CMPA #$0F
              BEQ key9_0 

              SEC                                ;set the carry         

              MOVW #m_com,memAddr1
              JSR manROL                         ;ROL the current command line mantissa value
              
              INC noDigMan
              
              BRCLR flag2,#BIT1,key9_3           ;branch if tick not pressed in 2-adic mode
              
              INC noDigDp                        
              
key9_3:       BRSET flag3,#BIT7,key9_2           ;do not display "1" if in run mode      

              LDAB #wFont
              LDX #Digit
              ABX                                
              
              MOVB #wFont,colNumber              ;display "1"
              JSR sendData
              
key9_0:       BCLR flag4,#BIT7                   ;clear updtScreen flag              
              
              BRA key9_2                         ;exit        

key9_1:       MOVB #$01,keyValue                         

              JSR nzKey              

key9_2:       JMP keyHdlr_1                      ;return to scanKey subroutine            

;Key 10: displays the exponent entry field;;;;;;;;

ExpE:         BCLR flag4,#BIT7                   ;clear updtScreen flag     

              TST noDigMan                       
              BEQ ExpE_exit                      ;continue only if the command line is not empty
                                             
              BRSET flag3,#BIT3,ExpE_exit        ;exit if in Bin/Hex mode     

              BRSET flag2,#BIT0,ExpE_exit        ;exit if the exponent entry field is displayed 
              
              BSET flag2,#BIT0                   ;otherwise set expPressed flag
              
              CALL clrChar

ExpE_exit:    JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 12: Multiplication;;;;;;;;;;;;;;;;;;;;;;;;;;;

Mult:         BRSET flag4,#BIT2,key4_17          ;branch if in exact number mode        

              BRCLR flag4,#BIT1,key4_12_1        ;branch if not in complex number mode
              
              LBRA key4_16

key4_12_1:    LBRA key4_9

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;c   d :rational on stack level 1
                                                 ;a   b ;rational on stack level 2
key4_17:      TST noDigMan
              LBEQ key4_20                       ;branch if the command line is empty
              
              LDD usPointer
              CPD #ms_end
              BNE key4_23                        ;branch if the stack is non-empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag
              LBRA key4_8                        ;exit as the user stack depth = 0
              
key4_23:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key4_24          ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              LBRA key4_8                                    
 
key4_24:      LDD usPointer
              CPD #$2000
              BNE key4_25                        ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackDenom
              
              LDD usPointer
              ADDD #lenFPNBytes
              
key4_25:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer              
              STD memAddr2
              
              PSHD
              
              MOVW #m_com,memAddr1               
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              PULD
              PSHD
              
              ADDD #$13B5                        
              
              TFR D,X                            ;X points to FPN_1_denominator
              
              CLRA
              MOVB #lenManBBytes,counter1
              
key4_22:      STAA 1,X+                          ;set mantissa of denominator to 1 ->
              DEC counter1
              BNE key4_22
              
              MOVB #$01,0,X                      ;<-
              
              PULD
              PSHD              

              ADDD #lenManBytes                  
              TFR D,X                            ;X points to exponent of FPN_1_numerator
              
              LDAA 0,X                           ;A = exponent of FPN_1_numerator
              BPL key4_26                        ;if exponent of FPN_1_numerator >= 0 set exponent of 
                                                 ;FPN_1_denominator to 0
              
              CLR 0,X                            ;otherwise set exponent of FPN_1_numerator to 0 and exponent of 
                                                 ;FPN_1_denominator to NEGA
              NEGA              
              PSHA
              
              INS
              
              PULD
                            
              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              DES
              DES
              DES
              
              PULA
              
              INS
              INS
              
              STAA 0,X                           ;set exponent of FPN_1_denominator to NEGA
                            
              BRA key4_21  
              
key4_26:      PULD
              
              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              MOVB #$00,0,X                      ;set exponent of FPN_1_denominator to 0              
                             
              BRA key4_21               
              
key4_20:      JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key4_21                        ;branch if the user stack depth > 1
              LBRA key4_8                        ;return to scanKey subroutine as the user stack depth = 0 or 1
              
key4_21:      ;a/b * c/d ->
              
              LDD usPointer
              ADDD #$13B5
              STD memAddr1            
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;d -> FPN_a
                  
              LDD usPointer
              ADDD #$13BE
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;b -> FPN_b
              
              ;bd ->
              
              JSR chkExp                         ;check e_a + e_b for overflow/underflow
              
              BRCLR flag2,#BIT5,key4_27          ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key4_8                              
              
key4_27:      BRCLR flag2,#BIT6,key4_28          ;branch if the uFlow flag was not set
                            
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key4_8                                                                                                          
               
key4_28:      JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a

              BRCLR flag2,#BIT4,key4_29          ;branch if bd should be positive
              
              JSR negFPN                         ;otherwise negate it first

key4_29:      JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key4_30          ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key4_8         

key4_30:      BRCLR flag2,#BIT6,key4_31          ;branch if the uFlow flag was not set

              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key4_8      

key4_31:      JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key4_32                        ;branch if FPN_a <> 0 
               
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key4_8
              
              ;<- end bd               
              
key4_32:      MOVW #m_a,memAddr1
              MOVW #m_h,memAddr2
              JSR copyFPN                        ;bd -> FPN_h
              
              LDD usPointer
              ADDD #$09
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;a -> FPN_a
              
              LDD usPointer
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;c -> FPN_b
              
              ;ac ->
              
              JSR chkExp                         ;check e_a + e_b for overflow/underflow
              
              BRCLR flag2,#BIT5,key4_33          ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key4_8                              
              
key4_33:      BRCLR flag2,#BIT6,key4_34          ;branch if the uFlow flag was not set
                            
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key4_8
              ;increment usPointer and set numerator to 0, denominator to 1                                                                                                          
               
key4_34:      JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a
                            
              BRCLR flag2,#BIT4,key4_35          ;branch if product should be positive 
              JSR negFPN                         ;otherwise negate it first 

key4_35:      JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key4_36          ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key4_8         

key4_36:      BRCLR flag2,#BIT6,key4_37          ;branch if the uFlow flag was not set
                            
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key4_8
              ;increment usPointer and set numerator to 0, denominator to 1  

key4_37:      JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key4_38                        ;branch if FPN_a <> 0  
                                       
              ;otherwise increment usPointer and set numerator to 0, denominator to 1 ->
              
              LDD usPointer
              ADDD #$09
              STD usPointer
              TFR D,X
              
              CLRA              
              MOVB #$09,counter1
              
 key4_43:     STAA 1,X+                          ;set FPN_1_numerator = 0 ->
              DEC counter1
              BNE key4_43                        ;<-
              
              LDD usPointer
              ADDD #$13B5
              TFR D,X
              
              CLRA              
              MOVB #$07,counter1
              
 key4_44:     STAA 1,X+                          ;set FPN_1_denominator = 1 ->
              DEC counter1
              BNE key4_44
              
              MOVB #$01,1,X+
              
              STAA 0,X
               
              ;<-                                                
              
              LBRA key4_42                       ;exit
                                                               
              ;<- end ac 
              
key4_38:      MOVW #m_a,memAddr1
              MOVW #m_g,memAddr2
              JSR copyFPN                        ;ac -> FPN_g
              
              MOVW #m_h,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;bd -> FPN_b
              
              MOVW #m_b,memAddr1
              JSR tzFPN_b                        ;eliminate trailing zeros from FPN_b
              JSR absFPN                         ;set to absolute value if required
              
              MOVW #m_a,memAddr1
              JSR tzFPN                          ;eliminate trailing zeros from FPN_a
              JSR absFPN                         ;set to absolute value if required 
              
              JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b
                                                 
              MOVB e_b,power                     ;result will be multiplied by 10^power
              
              LDAA e_a                           ;divide FPN_a,b by 10^power
              SUBA e_b
              STAA e_a
              
              CLR e_b
                            
              JSR lzMan   
              
              LDAA noZero
              SUBA e_a
              DECA
              
              BPL key4_39
                                                 ;otherwise don't reduce fraction to simplest form as FPN_a is too
                                                 ;big to find GCD ->              
              MOVW #m_g,memAddr1              
              LDD usPointer
              ADDD #$09
              STD usPointer                      ;increment usPointer
              STD memAddr2
              JSR copyFPN                        ;ac (unsimplified) -> usPointer + 9 (previously a)
              
              MOVW #m_h,memAddr1              
              LDD usPointer
              ADDD #$13B5
              STD memAddr2
              JSR copyFPN                        ;bc (unsimplified) -> usPointer + 13B5 (previously b)
              
              BRA key4_42                        ;<-
                               
key4_39:      JSR GCDFPN_ab                      ;determine GCD of numerator and denominator and store BCD result
                                                 ;in FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;GCD(ac,bd) -> FPN_b
              
              MOVW #m_g,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;ac -> FPN_a 
              
              JSR divFPN                         ;ac/GCD(ac,bd) -> FPN_a
              
              BRCLR flag2,#BIT4,key4_40          ;branch if result should be positive
              
              JSR negFPN                         ;otherwise negate it first
              
key4_40:      MOVW #m_a,memAddr1              
              LDD usPointer
              ADDD #$09
              STD usPointer                      ;increment usPointer
              STD memAddr2
              JSR copyFPN                        ;simplified numerator -> usPointer + 9 (previously a) 
              
              MOVW #m_h,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;bd -> FPN_a 
              
              JSR divFPN                         ;bd/GCD(ac,bd) -> FPN_a
              
              BRCLR flag2,#BIT4,key4_41          ;branch if result should be positive
              
              MOVW usPointer,memAddr1              
              JSR negFPN                         ;otherwise negate simplified numerator to maintain equality 
              
key4_41:      MOVW #m_a,memAddr1              
              LDD usPointer
              ADDD #$13B5
              STD memAddr2
              JSR copyFPN                        ;simplified denominator -> usPointer + 13B5 (previously b)

key4_42:      JSR clrComLMem                     ;clear command line memory
              
              LBRA key4_8
              
              ;<- end a/b * c/d
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key4_16:      TST noDigMan
              BEQ key4_12                        ;branch if the command line is empty
              
              LDD usPointer
              CPD #ms_end
              BNE key4_10                        ;branch if the stack is non-empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag
              LBRA key4_8                        ;exit as the user stack depth = 0
              
key4_10:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key4_11          ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              LBRA key4_8                                    
 
key4_11:      LDD usPointer
              CPD #$2000
              BNE key4_14                        ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackImag
              
              LDD usPointer
              ADDD #lenFPNBytes
              
key4_14:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              STD memAddr2
              
              PSHD       
              
              MOVW #m_com,memAddr1                  
              
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              PULD                               ;set imaginary part to 0->              
              ADDD #$1301                        
              
              TFR D,X                            ;X points to the corresponding imaginary part
              
              CLRA
              MOVB #lenFPNBytes,counter1
              
key4_15:      STAA 1,X+
              DEC counter1
              BNE key4_15                        ;<-
              
              JSR clrComLMem                     ;command line memory cleared so that "->B" program instruction in 
                                                 ;CPXMulPrg program below copies FPN_1 instead of m_com to B, as
                                                 ;CPXMulPrg program assumes command line is empty
              
              BRA key4_13
              
key4_12:      JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key4_13                        ;branch if the user stack depth > 1
              LBRA key4_8                        ;return to scanKey subroutine as the user stack depth = 0 or 1
              
key4_13:      LDX prgCounter
              PSHX                   

              LDX #CPXMulPrg
              DEX
              STX prgCounter                     ;prgCounter = CPXMulPrg - 1
              
              JSR exePrg
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              LBRA key4_8
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;       

key4_9:       TST noDigMan
              BEQ key4_3                         ;branch if the command line is empty
              
              JSR calcDpt                        ;otherwise calculate the depth of the user stack and store it in A
              TSTA
              BNE key4_0
              JMP keyHdlr_1                      ;exit as the user stack depth = 0         
              
key4_0:       BRCLR flag3,#BIT3,key4_0_2         ;branch if not in Hex/Bin mode
              
              JSR cmdToBCD                       ;otherwise convert the command line value to BCD
              
              BRA key4_0_1 
              
key4_0_2:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key4_0_1         ;branch if oFlow flag was not set
              
              BRA key4_4_1                       ;otherwise display "ERROR" on the status line and exit
              
key4_0_1:     LDD usPointer
              CPD #$2000
              BNE key4_1                         ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key4_2                          
                                                  
key4_1:       SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key4_2:       MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack  
               
              BRA key4_4                       
              
key4_3:       JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key4_4                         ;branch if the user stack depth > 1
              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag
              LBRA key4_8                        ;return to scanKey subroutine as the user stack depth = 0 or 1
              
key4_4:       MOVW usPointer,memAddr1                                          
              MOVW #m_a,memAddr2              
              JSR copyFPN                        ;copy FPN_1 to FPN_a 
              
              LDD usPointer
              ADDD #lenFPNBytes                  ;D points to FPN_2
              
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;copy FPN_2 to FPN_b  

              JSR chkExp                         ;check e_2 + e_1 for overflow/underflow
              
              BRCLR flag2,#BIT5,key4_5           ;branch if the oFlow flag was not set
              
key4_4_1:     BRA key4_6_2                       ;otherwise display "ERROR" on the status line and exit       
              
key4_5:       BRCLR flag2,#BIT6,key4_6           ;branch if the uFlow flag was not set
                            
              JSR clrComLMem                     ;clear command line memory               
              BRA key4_8                         ;return to scanKey subroutine                                                                                                          
               
key4_6:       JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a

              ;MOVW #m_a,memAddr1
              
              BRCLR flag2,#BIT4,key4_6_1         ;branch if product should be positive 
              JSR negFPN                         ;otherwise negate it first               

key4_6_1:     JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key4_7           ;branch if the oFlow flag was not set
              
key4_6_2:     BRCLR flag2,#BIT7,key4_6_3         ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key4_6_3:     JSR dispError                      ;display "ERROR" on the status line and exit  
              BRA key4_8           

key4_7:       JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key4_7_1                       ;branch if FPN_a <> 0  
              CLR e_a                            ;otherwise clear e_a (for cases when algorithm returns e.g. 0 50)
              
key4_7_1:     LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;increment usPointer               
              
              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1 * FPN_2 -> FPN_1       
                            
              JSR clrComLMem                     ;clear command line memory
              
key4_8:       JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key 13: 6;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Six:          BRCLR flag4,#BIT0,key13_1          ;continue if not in Bin mode

              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag and exit
              
              BRA key13_2
              
key13_1:      MOVB #$06,keyValue                          

              JSR nzKey

key13_2:      JMP keyHdlr_1                      ;return to scanKey subroutine
                         
;Key 14: 5;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Five:         BRCLR flag4,#BIT0,key14_1          ;continue if not in Bin mode

              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag and exit
              
              BRA key14_2
              
key14_1:      MOVB #$05,keyValue                          

              JSR nzKey

key14_2:      JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 15: 4;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Four:         BRCLR flag4,#BIT0,key15_1          ;continue if not in Bin mode

              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag and exit
              
              BRA key15_2
              
key15_1:      MOVB #$04,keyValue                          

              JSR nzKey

key15_2:      JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key 16: Enter;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Ente:         BRCLR flag4,#BIT1,key3_4           ;branch if not in complex number mode

              LBRA key3_5        

key3_4:       BRCLR flag4,#BIT2,key3_18          ;branch if not in exact mode

              LBRA key3_19     

key3_18:      LDAA noDigMan
              BNE key3_2                         ;branch if the command line is not empty 
              LDD usPointer
              CPD #ms_end
              BNE key3_1                         ;branch if the calculator stack is not empty (DUP)
              BRA key3_9                         ;the command line and calculator stack are empty so return to 
                                                 ;scanKey subroutine
key3_1:       MOVW usPointer,memAddr1
              MOVW #m_com,memAddr2              
              JSR copyFPN                        ;copy FPN_1 to the command line in order to duplicate it
                                         
              BRA key3_6                       
              
key3_2:       BRCLR flag3,#BIT3,key3_3           ;branch if not in Bin/Hex mode

              JSR cmdToBCD                       ;otherwise convert the command line value to BCD
              BRA key3_6 

key3_3:       JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key3_6           ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              BRA key3_9                                    
 
key3_6:       LDD usPointer
              CPD #$2000
              BNE key3_7                         ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack, push
                                                 ;the command line value onto it, and return to scanKey subroutine            
              BRA key3_8                                                             
                                                 
key3_7:       SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer              
              
key3_8:       MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              JSR clrComLMem                     ;clear command line memory
              
key3_9:       JMP keyHdlr_1                      ;return to scanKey subroutine

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key3_5:       LDAA noDigMan
              BNE key3_10                        ;branch if the command line is not empty 
              LDD usPointer
              CPD #ms_end
              BNE key3_11                        ;branch if the calculator stack is not empty (DUP)
              LBRA key3_exit                     ;the command line and calculator stack are empty so return to
                                                 ;scanKey subroutine
key3_11:      CPD #$2000
              BNE key3_17                        ;branch if the top of the stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackImag
              
              LDD usPointer
              ADDD #lenFPNBytes
              
key3_17:      PSHD    

              STD memAddr1      

              SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              STD memAddr2
              
              JSR copyFPN                        ;FPN_1_real copied to FPN_2_real
              
              PULD                            
              ADDD #$1301                        ;D is equal to the address of FPN_1_imaginary
              
              STD memAddr1
              SUBD #lenFPNBytes                  ;D is equal to the address of FPN_2_imaginary
              
              STD memAddr2
              
              JSR copyFPN                        ;FPN_1_imaginary copied to FPN_2_imaginary
              
              LBRA key3_exit      
              
key3_10:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key3_12          ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              LBRA key3_exit                                    
 
key3_12:      LDD usPointer
              CPD #$2000
              BNE key3_13                        ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackImag
              
              LDD usPointer
              ADDD #lenFPNBytes                                         
                                                 
key3_13:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              STD memAddr2
              
              PSHD       
              
              MOVW #m_com,memAddr1                  
              
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              PULD                               ;set imaginary part to 0->              
              ADDD #$1301                        
              
              TFR D,X                            ;X points to the corresponding imaginary part
              
              CLRA
              MOVB #lenFPNBytes,counter1
              
key3_15:      STAA 1,X+
              DEC counter1
              BNE key3_15                        ;<-
              
              LBRA key3_30
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key3_19:      LDAA noDigMan
              BNE key3_22                        ;branch if the command line is not empty 
              LDD usPointer
              CPD #ms_end
              BNE key3_20                        ;branch if the calculator stack is not empty (DUP)
              LBRA key3_exit                     ;the command line and calculator stack are empty so return to
                                                 ;scanKey subroutine
key3_20:      CPD #$2000
              BNE key3_21                        ;branch if the top of the stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackDenom
              
              LDD usPointer
              ADDD #lenFPNBytes
              
key3_21:      PSHD    

              STD memAddr1      

              SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              STD memAddr2
              
              JSR copyFPN                        ;FPN_1_numerator copied to FPN_2_numerator
              
              PULD                            
              ADDD #$13B5                        ;D is equal to the address of FPN_1_denominator
              
              STD memAddr1
              SUBD #lenFPNBytes                  ;D is equal to the address of FPN_2_denominator
              
              STD memAddr2
              
              JSR copyFPN                        ;FPN_1_denominator copied to FPN_2_denominator
              
              LBRA key3_exit      
              
key3_22:      BRCLR flag5,#BIT7,key3_31          ;branch if not in 2-adic mode

              LDD usPointer
              CPD #$2000
              BNE key3_32                        ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackDenom
              
              LDD usPointer
              ADDD #lenFPNBytes                                         
                                                 
key3_32:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              
              PSHD
              
              BCLR flag3,#BIT0                   ;clear gFlag0
              
              JSR cmdToBCD2                      ;convert the command line value to BCD
              
              BRCLR flag3,#BIT0,key3_33          ;branch if gFlag0 was not set in cmdToBCD2 subroutine, 
                                                 ;i.e. if 2-adic number entered on command line <> 0
                                                 
              PULD
              
              LBRA key3_30                       ;otherwise exit       

key3_33:      LBRA key3_27

key3_31:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key3_23          ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              LBRA key3_exit                                    
 
key3_23:      LDD usPointer
              CPD #$2000
              BNE key3_24                        ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackDenom
              
              LDD usPointer
              ADDD #lenFPNBytes                                         
                                                 
key3_24:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              STD memAddr2
              
              PSHD
              
              MOVW #m_com,memAddr1               
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              PULD
              PSHD
              
              ADDD #$13B5                        
              
              TFR D,X                            ;X points to FPN_1_denominator

              CLRA
              MOVB #lenManBBytes,counter1
              
key3_25:      STAA 1,X+                          ;set mantissa of FPN_1_denominator to 1 ->
              DEC counter1
              BNE key3_25
              
              MOVB #$01,0,X                      ;<-
              
              PULD
              PSHD              
              
              STD memAddr1
                            
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key3_29                        ;branch if FPN_1_numerator <> 0
              
              PULD
              
              ADDD #$13BD                                                 
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              MOVB #$00,0,X                      ;set exponent of FPN_1_denominator to 0
              
              LBRA key3_30

key3_29:      MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1_numerator
              
              MOVW #m_a,memAddr1               
              JSR tzFPN                          ;eliminate any trailing zeros in FPN_M1 = FPN_a = FPN_1_numerator                                          
              
              PULD
              PSHD              

              ADDD #lenManBytes                  
              TFR D,X                            ;X points to exponent of FPN_1_numerator
              
              LDAA 0,X                           ;A = exponent of FPN_1_numerator
              BPL key3_26                        ;if exponent of FPN_1_numerator >= 0 set exponent of 
                                                 ;FPN_1_denominator to 0
              
              CLR 0,X                            ;otherwise set exponent of FPN_1_numerator to 0 and exponent of 
                                                 ;FPN_1_denominator to NEGA
              NEGA              
              PSHA
              
              INS
              
              PULD
              PSHD
              
              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              DES
              
              PULA
              
              STAA 0,X                           ;set exponent of FPN_1_denominator to NEGA
              
              PULD
              PSHD
              
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1_numerator copied to m_b
              
              MOVW #m_b,memAddr1              
              JSR absFPN                         ;set m_b to absolute value if required 
              
              PULD
              PSHD
              
              ADDD #$13B5
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to m_a              
              
              BRA key3_27    
              
key3_26:      MOVW #m_a,memAddr1              
              JSR absFPN                         ;set m_a to absolute value if required

              PULD
              PSHD

              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              MOVB #$00,0,X                      ;set exponent of FPN_1_denominator to 0
              
              SUBD #$0008                        ;D points to FPN_1_denominator
              
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to m_b
              
key3_27:     ;exit if e_a too big ->
              
              MOVB e_b,power                     ;result will be multiplied by 10^power
              
              LDAA e_a                           ;divide FPN_a,b by 10^power
              SUBA e_b
              STAA e_a
              
              CLR e_b
              
              MOVW #m_a,memAddr1
              
              JSR lzMan   
              
              LDAA noZero
              SUBA e_a
              DECA
              
              BPL key3_28
              
              PULD
              
              BRA key3_30                        ;otherwise don't reduce fraction to simplest form as FPN_a is too
                                                 ;big to find GCD
              ;<-

key3_28:      JSR GCDFPN_ab                      ;determine GCD of numerator and denominator and store BCD result
                                                 ;in FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;GCD copied to FPN_b
              
              PULD
              PSHD
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_numerator copied to FPN_a
              
              JSR divFPN                         ;FPN_1_numerator/GCD -> FPN_a
              
              BRCLR flag2,#BIT4,key3_34          ;branch if result should be positive              
             
              JSR negFPN                         ;otherwise negate m_a first 
              
key3_34:      PULD
              PSHD
              
              STD memAddr2              
              JSR copyFPN                        ;FPN_a = simplified numerator copied to FPN_1_numerator
              
              PULD
              PSHD
              
              ADDD #$13B5
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to FPN_a
              
              JSR divFPN                         ;FPN_1_denominator/GCD -> FPN_a
              
              PULD
                            
              ADDD #$13B5
              
              STD memAddr2
              MOVW #m_a,memAddr1
              JSR copyFPN                        ;FPN_a = simplified denominator copied to FPN_1_denominator

key3_30:      JSR clrComLMem                     ;clear command line memory
              
key3_exit:    JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 18: Division;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Divi:         BRSET flag4,#BIT2,key0_17          ;branch if in exact number mode        

              BRCLR flag4,#BIT1,key18_1          ;branch if not in complex number mode
              
              LBRA key0_10

key18_1:      LBRA key0_9

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;c   d :rational on stack level 1
                                                 ;a   b ;rational on stack level 2
key0_17:      TST noDigMan
              LBEQ key0_20                       ;branch if the command line is empty
              
              LDD usPointer
              CPD #ms_end
              BNE key0_23                        ;branch if the stack is non-empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag
              LBRA key0_8                        ;exit as the user stack depth = 0
              
key0_23:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key0_24          ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              LBRA key0_8                                    
 
key0_24:      LDD usPointer
              CPD #$2000
              BNE key0_25                        ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackDenom
              
              LDD usPointer
              ADDD #lenFPNBytes
              
key0_25:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer              
              STD memAddr2
              
              PSHD
              
              MOVW #m_com,memAddr1               
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              PULD
              PSHD
              
              ADDD #$13B5                        
              
              TFR D,X                            ;X points to FPN_1_denominator
              
              CLRA
              MOVB #lenManBBytes,counter1
              
key0_22:      STAA 1,X+                          ;set mantissa of denominator to 1 ->
              DEC counter1
              BNE key0_22
              
              MOVB #$01,0,X                      ;<-
              
              PULD
              PSHD              

              ADDD #lenManBytes                  
              TFR D,X                            ;X points to exponent of FPN_1_numerator
              
              LDAA 0,X                           ;A = exponent of FPN_1_numerator
              BPL key0_26                        ;if exponent of FPN_1_numerator >= 0 set exponent of 
                                                 ;FPN_1_denominator to 0
              
              CLR 0,X                            ;otherwise set exponent of FPN_1_numerator to 0 and exponent of 
                                                 ;FPN_1_denominator to NEGA
              NEGA              
              PSHA
              
              INS
              
              PULD
                            
              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              DES
              DES
              DES
              
              PULA
              
              INS
              INS
              
              STAA 0,X                           ;set exponent of FPN_1_denominator to NEGA
              
              BRA key0_21  
              
key0_26:      PULD
              
              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              MOVB #$00,0,X                      ;set exponent of FPN_1_denominator to 0
              
              BRA key0_21               
              
key0_20:      JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key0_21                        ;branch if the user stack depth > 1
              LBRA key0_8                        ;return to scanKey subroutine as the user stack depth = 0 or 1
              
key0_21:      MOVW usPointer,memAddr1            
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;c -> FPN_a
                  
              LDD usPointer
              ADDD #$13BE
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;b -> FPN_b
              
              ;bc ->
              
              JSR chkExp                         ;check e_a + e_b for overflow/underflow
              
              BRCLR flag2,#BIT5,key0_31          ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key0_8                              
              
key0_31:      BRCLR flag2,#BIT6,key0_32          ;branch if the uFlow flag was not set
                            
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key0_8                                                                                                          
               
key0_32:      JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a

              BRCLR flag2,#BIT4,key0_42          ;branch if bc should be positive
              
              JSR negFPN                         ;otherwise negate it first

key0_42:      JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key0_33          ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key0_8         

key0_33:      BRCLR flag2,#BIT6,key0_34          ;branch if the uFlow flag was not set

              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key0_8      

key0_34:      JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key0_35                        ;branch if FPN_a <> 0 
               
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key0_8
              
              ;<-               
              
key0_35:      MOVW #m_a,memAddr1
              MOVW #m_h,memAddr2
              JSR copyFPN                        ;bc -> FPN_h
              
              LDD usPointer
              ADDD #$09
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;a -> FPN_a
              
              LDD usPointer
              ADDD #$13B5
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;d -> FPN_b
              
              ;ad ->
              
              JSR chkExp                         ;check e_a + e_b for overflow/underflow
              
              BRCLR flag2,#BIT5,key0_36          ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key0_8                              
              
key0_36:      BRCLR flag2,#BIT6,key0_37          ;branch if the uFlow flag was not set
                            
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key0_8
              ;increment usPointer and set numerator to 0, denominator to 1                                                                                                          
               
key0_37:      JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a
                            
              BRCLR flag2,#BIT4,key0_40          ;branch if product should be positive 
              JSR negFPN                         ;otherwise negate it first 

key0_40:      JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key0_38          ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key0_8         

key0_38:      BRCLR flag2,#BIT6,key0_41          ;branch if the uFlow flag was not set
                            
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit              
              LBRA key0_8
              ;increment usPointer and set numerator to 0, denominator to 1  

key0_41:      JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key0_39                        ;branch if FPN_a <> 0  
              ;CLR e_a                            ;otherwise clear e_a (for cases when multiplication algorithm 
                                                 ;returns e.g. 0 50)                           
              LDD usPointer
              ADDD #$09
              STD usPointer                      ;increment usPointer
                                                               
              LBRA key0_19                       ;exit                                                 
              ;<- 
              
key0_39:      MOVW #m_a,memAddr1
              MOVW #m_g,memAddr2
              JSR copyFPN                        ;ad -> FPN_g
              
              MOVW #m_h,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;bc -> FPN_b
              
              MOVW #m_b,memAddr1
              JSR tzFPN_b                        ;eliminate trailing zeros from FPN_b
              JSR absFPN                         ;set to absolute value if required
              
              MOVW #m_a,memAddr1
              JSR tzFPN                          ;eliminate trailing zeros from FPN_a
              JSR absFPN                         ;set to absolute value if required 
              
              JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b
                                                 
              MOVB e_b,power                     ;result will be multiplied by 10^power
              
              LDAA e_a                           ;divide FPN_a,b by 10^power
              SUBA e_b
              STAA e_a
              
              CLR e_b
                            
              JSR lzMan   
              
              LDAA noZero
              SUBA e_a
              DECA
              
              BPL key0_18
                                                 ;otherwise don't reduce fraction to simplest form as FPN_a is too
                                                 ;big to find GCD ->              
              MOVW #m_g,memAddr1              
              LDD usPointer
              ADDD #$09
              STD usPointer                      ;increment usPointer
              STD memAddr2
              JSR copyFPN                        ;ad (unsimplified) -> usPointer + 9 (previously a)
              
              MOVW #m_h,memAddr1              
              LDD usPointer
              ADDD #$13B5
              STD memAddr2
              JSR copyFPN                        ;bc (unsimplified) -> usPointer + 13B5 (previously b)
              
              BRA key0_19                        ;<-
                               
key0_18:      JSR GCDFPN_ab                      ;determine GCD of numerator and denominator and store BCD result
                                                 ;in FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;GCD(ad,bc) -> FPN_b
              
              MOVW #m_g,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;ad -> FPN_a 
              
              JSR divFPN                         ;ad/GCD(ad,bc) -> FPN_a
              
              BRCLR flag2,#BIT4,key0_43          ;branch if result should be positive
              
              JSR negFPN                         ;otherwise negate it first
              
key0_43:      MOVW #m_a,memAddr1              
              LDD usPointer
              ADDD #$09
              STD usPointer                      ;increment usPointer
              STD memAddr2
              JSR copyFPN                        ;simplified numerator -> usPointer + 9 (previously a) 
              
              MOVW #m_h,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;bc -> FPN_a 
              
              JSR divFPN                         ;bc/GCD(ad,bc) -> FPN_a
              
              BRCLR flag2,#BIT4,key0_44          ;branch if result should be positive
              
              MOVW usPointer,memAddr1              
              JSR negFPN                         ;otherwise negate simplified numerator to maintain equality 
              
key0_44:      MOVW #m_a,memAddr1              
              LDD usPointer
              ADDD #$13B5
              STD memAddr2
              JSR copyFPN                        ;simplified denominator -> usPointer + 13B5 (previously b)

key0_19:      JSR clrComLMem                     ;clear command line memory
              
              LBRA key0_8                        ;return to scanKey subroutine
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key0_10:      TST noDigMan
              BEQ key0_15                        ;branch if the command line is empty
              
              LDD usPointer
              CPD #ms_end
              BNE key0_11                        ;branch if the stack is non-empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag
              LBRA key0_8                        ;exit as the user stack depth = 0
              
key0_11:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key0_12          ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              LBRA key0_8                                    
 
key0_12:      LDD usPointer
              CPD #$2000
              BNE key0_13                        ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackImag
              
              LDD usPointer
              ADDD #lenFPNBytes
              
key0_13:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              STD memAddr2
              
              PSHD       
              
              MOVW #m_com,memAddr1                  
              
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              PULD                               ;set imaginary part to 0->              
              ADDD #$1301                        
              
              TFR D,X                            ;X points to the corresponding imaginary part
              
              CLRA
              MOVB #lenFPNBytes,counter1
              
key0_14:      STAA 1,X+
              DEC counter1
              BNE key0_14                        ;<-              
              
              BRA key0_16
              
key0_15:      JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key0_16                        ;branch if the user stack depth > 1
              LBRA key0_8                        ;return to scanKey subroutine as the user stack depth = 0 or 1
              
key0_16:      LDX prgCounter
              PSHX                   

              LDX prgCounterStM1
              PSHX           

              LDX #CPXDivPrg
              DEX
              STX prgCounter                     ;prgCounter = CPXDivPrg - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              LBRA key0_8
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key0_9:       TST noDigMan
              BEQ key0_3                         ;branch if the command line is empty
              
              JSR calcDpt                        ;otherwise calculate the depth of the user stack and store it in A
              TSTA
              BNE key0_0
              BCLR flag4,#BIT7                   ;clear updtScreen flag
              JMP keyHdlr_1                      ;exit as the user stack depth = 0         
              
key0_0:       BRCLR flag3,#BIT3,key0_0_2         ;branch if not in Hex/Bin mode
              
              JSR cmdToBCD                       ;otherwise convert the command line value to BCD
              
              BRA key0_0_1

key0_0_2:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key0_0_1         ;branch if oFlow flag was not set
              
              BRA key0_4_2                       ;otherwise display "ERROR" on the status line and exit
              
key0_0_1:     LDD usPointer
              CPD #$2000
              BNE key0_1                         ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack
              BRA key0_2                                   
                                                  
key0_1:       SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key0_2:       MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack  
               
              BRA key0_4                       
              
key0_3:       JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key0_4
              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag
              JMP keyHdlr_1                      ;return to scanKey subroutine as the user stack depth = 0 or 1
                                                 ;and the command line is empty
key0_4:       MOVW usPointer,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key0_4_1                       ;branch if the divisor is not zero 
              
key0_4_2:     BRA key0_4_3                       ;otherwise display "ERROR" on the status line and exit              
              
key0_4_1:     MOVW #m_b,memAddr2              
              JSR copyFPN                        ;copy FPN_1 to FPN_b (i.e. FPN_b = divisor)
              
              LDD usPointer
              ADDD #lenFPNBytes                  ;D points to FPN_2
              
              STD memAddr1
              
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key0_4_4                       ;branch if the dividend is not zero
              
              MOVW memAddr1,usPointer            ;otherwise increment usPointer
              LDX usPointer               
              CLRA
              MOVB #lenFPNBytes,counter1
              
key0_4_5:     STAA 1,X+                          ;set FPN_1 to 0
              DEC counter1
              BNE key0_4_5
                          
              JSR clrComLMem                     ;clear command line memory               
              JMP keyHdlr_1                      ;return to scanKey subroutine               
              
key0_4_4:     MOVW #m_a,memAddr2
              JSR copyFPN                        ;copy FPN_2 to FPN_a (i.e. FPN_a = dividend)
              
              NEG e_b
              JSR chkExp                         ;check e_2 - e_1 for overflow/underflow
              NEG e_b
                            
              BRCLR flag2,#BIT5,key0_5           ;branch if the oFlow flag was not set
              
key0_4_3:     BRA key0_6_10                      ;otherwise display "ERROR" on the status line and exit      
                       
key0_5:       BRCLR flag2,#BIT6,key0_6           ;branch if the uFlow flag was not set

              JSR clrComLMem                     ;clear command line memory
              BRA key0_8                         ;return to scanKey subroutine   
              
key0_6:       JSR divFPN                         ;divide FPN_a by FPN_b and store the result in FPN_a       

              BRCLR flag2,#BIT4,key0_6_9         ;branch if quotient should be positive 
              JSR negFPN                         ;otherwise negate it first               

key0_6_9:     JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key0_7           ;branch if the oFlow flag was not set
              
key0_6_10:    BRCLR flag2,#BIT7,key0_6_11        ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key0_6_11:    JSR dispError                      ;display "ERROR" on the status line and exit  
              BRA key0_8            

key0_7:       JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key0_7_1                       ;branch if FPN_a <> 0  
              CLR e_a                            ;otherwise clear e_a (for cases when algorithm returns e.g. 0 50)
              
key0_7_1:     LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;increment usPointer               
              
              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1 / FPN_2 -> FPN_1       

              JSR clrComLMem                     ;clear command line memory
              
key0_8:       JMP keyHdlr_1                      ;return to scanKey subroutine			  
              
;Key 19: 9;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Nine:         BRCLR flag4,#BIT0,key19_1          ;continue if not in Bin mode

              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag and exit
              
              BRA key19_2
              
key19_1:      MOVB #$09,keyValue                          

              JSR nzKey

key19_2:      JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key 20: 8;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Eigh:         BRCLR flag4,#BIT0,key20_1          ;continue if not in Bin mode

              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag and exit
              
              BRA key20_2
              
key20_1:      MOVB #$08,keyValue                          

              JSR nzKey

key20_2:      JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key 21: 7;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Seve:         BRCLR flag4,#BIT0,key21_1          ;continue if not in Bin mode

              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag and exit
              
              BRA key21_2
              
key21_1:      MOVB #$07,keyValue                          

              JSR nzKey

key21_2:      JMP keyHdlr_1                      ;return to scanKey subroutine
			  
;Key 22: Shift;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Shif:         CALL key22SUB

              JMP keyHdlr_1       

;Key 24: 10^x/F;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TenPX:        BRCLR flag3,#BIT2,key24_0          ;branch if not in hex mode

              MOVB #$0F,keyValue
              JSR nzKey
              JMP keyHdlr_1                      ;otherwise update command line and return to scanKey subroutine        

key24_0:      LDAA noDigMan
              BNE key24S_1                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key24S_5                       ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key24S_7                      ;exit as the command line and stack are both empty
                                                
key24S_1:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key24S_2         ;branch if oFlow flag was not set
              
              LBRA key24S_6                      ;otherwise display "ERROR" on the status line and exit       

key24S_2:     LDD usPointer
              CPD #$2000
              BNE key24S_3                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key24S_4                         
                                                  
key24S_3:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key24S_4:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack         
                            
key24S_5:     MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1
              
              LDX #m_b                           ;FPN_b = 99.9999999999778 ->
              
              MOVB #$09,1,X+
              MOVB #$99,1,X+
              MOVB #$99,1,X+
              MOVB #$99,1,X+
              MOVB #$99,1,X+
              MOVB #$99,1,X+
              MOVB #$97,1,X+
              MOVB #$78,1,X+                     ;m_b = 09 99 99 99 99 99 97 78 
                                                 
              MOVB #$F3,0,X                      ;e_b = -13
                            
              JSR cmpFPN_GE                      ;sets ge flag if FPN_a >= FPN_b
                                                 ;i.e. if FPN_1 >= 99.9999999999778
              
              BRCLR flag5,#BIT0,key24S_5_2       ;branch if ge flag not set, i.e. if FPN_1 < 99.9999999999778
              
              BRCLR flag2,#BIT7,key24S_5_1       ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key24S_5_1:   BRA key24S_6                       ;display "ERROR" on the status line and exit   
              
key24S_5_2:   MOVW #log10Values,logValues
              MOVW #negLog10Values,negLogValues  ;store address of special values used in expFPN2 subroutine   

              MOVW usPointer,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_1 = X
              
              JSR expFPN2                        ;find 10^FPN_f and store the result in FPN_b 

              MOVW #m_b,memAddr1
              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_b -> FPN_1
              
              BRA key24S_7 

key24S_6:     JSR dispError                      ;display "ERROR" on the status line and exit
  
key24S_7:     JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine
			  
;Key 25; e^x/E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EPX:          BRCLR flag3,#BIT2,key25_0          ;branch if not in hex mode

              MOVB #$0E,keyValue
              JSR nzKey
              JMP keyHdlr_1                      ;otherwise update command line and return to scanKey subroutine         

key25_0:      LDAA noDigMan
              BNE key12S_1                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key12S_5                       ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key12S_7                      ;exit as the command line and stack are both empty
              
key12S_1:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key12S_2         ;branch if oFlow flag was not set
              
              LBRA key12S_6                      ;otherwise display "ERROR" on the status line and exit       

key12S_2:     LDD usPointer
              CPD #$2000
              BNE key12S_3                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key12S_4                         
                                                  
key12S_3:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key12S_4:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack         
                            
key12S_5:     MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1
              
              LDX #m_b                           ;FPN_b = 230.25850929934 ->
                                                 
              MOVB #$02,1,X+
              MOVB #$30,1,X+
              MOVB #$25,1,X+
              MOVB #$85,1,X+
              MOVB #$09,1,X+
              MOVB #$29,1,X+
              MOVB #$93,1,X+
              MOVB #$40,1,X+                     ;m_b = 02 30 25 85 09 29 93 40
              
              MOVB #$F4,0,X                      ;e_b = -12

              JSR cmpFPN_GE                      ;sets ge flag if FPN_a >= FPN_b
                                                 ;i.e. if FPN_1 >= 230.25850929934 
              
              BRCLR flag5,#BIT0,key12S_5_2       ;branch if ge flag not set, i.e. if FPN_1 < 230.25850929934
              
              BRCLR flag2,#BIT7,key12S_5_1       ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key12S_5_1:   BRA key12S_6                       ;display "ERROR" on the status line and exit   
              
key12S_5_2:   MOVW #logEValues,logValues
              MOVW #negLogEValues,negLogValues   ;store address of special values used in expFPN subroutine   

              MOVW usPointer,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_1 = X
              
              JSR expFPN                         ;find e^FPN_f and store the result in FPN_b 

              MOVW #m_b,memAddr1
              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_b -> FPN_1
              
              BRA key12S_7 

key12S_6:     JSR dispError                      ;display "ERROR" on the status line and exit
  
key12S_7:     JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine        

;Key 26; Push pi onto the stack/D;;;;;;;;;;;;;;;;;

PI:           BRCLR flag3,#BIT2,key130_0         ;branch if not in hex mode

              MOVB #$0D,keyValue
              JSR nzKey
              JMP keyHdlr_1                      ;otherwise update command line and return to scanKey subroutine         

key130_0:     LDD usPointer
              CPD #$2000
              BNE key130_1                       ;branch if the top of the stack has not yet been reached
                            
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack
                          
              BRA key130_2                                                            
                                                 
key130_1:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              
key130_2:     LDX usPointer

              BRSET flag4,#BIT2,key130_3         ;branch if in exact mode                       
              
              MOVB #$03,1,X+                     ;pi ->
              MOVB #$14,1,X+
              MOVB #$15,1,X+
              MOVB #$92,1,X+
              MOVB #$65,1,X+
              MOVB #$35,1,X+
              MOVB #$89,1,X+
              MOVB #$79,1,X+                                           
                                                 
              MOVB #$F2,0,X                      ;<-
              
              BRA key130_exit
              
key130_3:     MOVB #$03,1,X+                     ;pi x 10^14 ->
              MOVB #$14,1,X+
              MOVB #$15,1,X+
              MOVB #$92,1,X+
              MOVB #$65,1,X+
              MOVB #$35,1,X+
              MOVB #$89,1,X+
              MOVB #$79,1,X+                                           
                                                 
              MOVB #$00,0,X                      ;<-

              TFR X,D
              ADDD #$13AD
              TFR D,X                            ;X points to the denominator
              
              MOVB #$00,1,X+                     ;10^14 ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$01,1,X+
              
              MOVB #$0E,0,X                      ;<-                            
                            
key130_exit:  JMP keyHdlr_1              
			  
;Key 27; tan/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TanX:         BRCLR flag3,#BIT2,key27_0          ;branch if not in hex mode

              MOVB #$0C,keyValue
              JSR nzKey
              JMP keyHdlr_1                      ;otherwise update command line and return to scanKey subroutine         

key27_0:      LDAA noDigMan
              BNE key13T_1                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key13T_4_1                     ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key13T_7                      ;exit as the command line and stack are both empty
              
key13T_1:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key13T_2         ;branch if oFlow flag was not set
              
              LBRA key13T_6                      ;otherwise display "ERROR" on the status line and exit       

key13T_2:     LDD usPointer
              CPD #$2000
              BNE key13T_3                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key13T_4                         
                                                  
key13T_3:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key13T_4:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack
              
key13T_4_1:   MOVW usPointer,memAddr1                  
              MOVW #m_f,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_f
             
              BRCLR flag4,#BIT4,key13T_8         ;branch if not in radian mode
              LBRA key13T_4_1_1                  ;otherwise no conversion necessary
              
key13T_8:     BRSET flag1,#BIT6,key13T_9         ;branch if in gradian mode      
         
              MOVW #m_a,memAddr2                 ;otherwise convert FPN_f from degrees to radians
              JSR copyFPN                        ;FPN_1 -> FPN_a
              
              LDX #m_b
              MOVB #$01,1,X+
              MOVB #$74,1,X+
              MOVB #$53,1,X+
              MOVB #$29,1,X+
              MOVB #$25,1,X+
              MOVB #$19,1,X+
              MOVB #$94,1,X+
              MOVB #$33,1,X+
              MOVB #$F0,1,X+                     ;FPN_b = pi/180
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_a = FPN_1 * pi/180
              
              BRA key13T_4_1_1
              
key13T_9:     MOVW #m_a,memAddr2                 ;convert FPN_f from gradians to radians
              JSR copyFPN                        ;FPN_1 -> FPN_a
              
              LDX #m_b
              MOVB #$01,1,X+
              MOVB #$57,1,X+
              MOVB #$07,1,X+
              MOVB #$96,1,X+
              MOVB #$32,1,X+
              MOVB #$67,1,X+
              MOVB #$94,1,X+
              MOVB #$90,1,X+
              MOVB #$F0,1,X+                     ;FPN_b = pi/200
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                   
                            
key13T_4_1_1: MOVW #m_f,memAddr1   

              LDX #m_f
              LDAA 0,X
              ANDA #$F0              
              
              BEQ key13T_4_2                     ;branch if FPN_f >= 0
                            
              JSR negFPN                         ;otherwise negate it first
              BSET flag2,#BIT4                   ;set the manNeg flag
              
key13T_4_2:   JSR lzMan              
              LDAA #lenMan
              DECA
              SUBA noZero
              ADDA e_f                           ;A = e_f(s) = exponent of FPN_f when it is in scientific format
              
              CMPA #$0A
              BGE key13T_6                       ;display error and exit if e_f(s) >= 10                
      
              JSR tanFPN                         ;determine Y and X such that tan of FPN_1 = Y/X
                                                 ;FPN_a = Y and FPN_b = X
                                                 
              MOVW #m_b,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #$10
              BEQ key13T_6                       ;display "ERROR" on the status line and exit if X = 0 
              
              BRCLR flag2,#BIT4,key13T_5_0       ;branch if original angle was non-negative
              JSR negFPN                         ;otherwise negate FPN_b = X first                                   

key13T_5_0:   MOVW #m_a,memAddr1              
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BEQ key13T_7                       ;display "0" if FPN_a = 0, since divFPN subroutine requires non-zero
                                                 ;dividend
              
              JSR divFPN                         ;FPN_a / FPN_b -> FPN_a
                                                 ;i.e. Y / X -> FPN_a       
              
              BRCLR flag2,#BIT4,key13T_5_1       ;branch if quotient should be positive 
              JSR negFPN                         ;otherwise negate it first
              
key13T_5_1:   MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key13T_7             
             
key13T_6:     BRCLR flag2,#BIT7,key13T_6_1       ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key13T_6_1:   JSR dispError                      ;display "ERROR" on the status line 
              
key13T_7:     JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine         

;Key 28; cos/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CosX:         BRCLR flag3,#BIT2,key28_0          ;branch if not in hex mode

              MOVB #$0B,keyValue
              JSR nzKey
              JMP keyHdlr_1                      ;otherwise update command line and return to scanKey subroutine         

key28_0:      LDAA noDigMan
              BNE key14T_1                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key14T_5                       ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key14T_7                      ;exit as the command line and stack are both empty
              
key14T_1:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key14T_2         ;branch if oFlow flag was not set
              
              LBRA key14T_6                      ;otherwise display "ERROR" on the status line and exit       

key14T_2:     LDD usPointer
              CPD #$2000
              BNE key14T_3                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key14T_4                         
                                                  
key14T_3:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key14T_4:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack               
              
key14T_5:     MOVW usPointer,memAddr1                  
              MOVW #m_f,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_f
              
              BRCLR flag4,#BIT4,key14T_10        ;branch if not in radian mode
              LBRA key14T_8                      ;otherwise no conversion necessary
              
key14T_10:    BRSET flag1,#BIT6,key14T_11        ;branch if in gradian mode      
         
              MOVW #m_a,memAddr2                 ;otherwise convert FPN_f from degrees to radians
              JSR copyFPN                        ;FPN_1 -> FPN_a
              
              LDX #m_b
              MOVB #$01,1,X+
              MOVB #$74,1,X+
              MOVB #$53,1,X+
              MOVB #$29,1,X+
              MOVB #$25,1,X+
              MOVB #$19,1,X+
              MOVB #$94,1,X+
              MOVB #$33,1,X+
              MOVB #$F0,1,X+                     ;FPN_b = pi/180
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_a = FPN_1 * pi/180
              
              BRA key14T_8
              
key14T_11:    MOVW #m_a,memAddr2                 ;convert FPN_f from gradians to radians
              JSR copyFPN                        ;FPN_1 -> FPN_a
              
              LDX #m_b
              MOVB #$01,1,X+
              MOVB #$57,1,X+
              MOVB #$07,1,X+
              MOVB #$96,1,X+
              MOVB #$32,1,X+
              MOVB #$67,1,X+
              MOVB #$94,1,X+
              MOVB #$90,1,X+
              MOVB #$F0,1,X+                     ;FPN_b = pi/200
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN               
                            
key14T_8:     MOVW #m_f,memAddr1   

              LDX #m_f
              LDAA 0,X
              ANDA #$F0              
              
              BEQ key14T_9                       ;branch if FPN_f >= 0
                            
              JSR negFPN                         ;otherwise negate it first               
              
key14T_9:     JSR lzMan
              LDAA #lenMan
              DECA
              SUBA noZero
              ADDA e_f                           ;A = e_f(s) = exponent of FPN_f when it is in scientific format
              
              CMPA #$0A
              LBGE key14T_6                      ;display "ERROR" and exit if e_f(s) >= 10

              JSR tanFPN                         ;determine Y and X such that tan of FPN_1 = Y/X
                                                 ;FPN_a = Y and FPN_b = X
              MOVW #m_a,memAddr1                                                                                     
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBEQ key14T_6_2                    ;display "1" if FPN_a = 0, since divFPN subroutine requires non-zero
                                                 ;dividend               
              LDX #m_b
              LDAA 0,X
              ANDA #$F0
              PSHA                               ;the sign of FPN_b = X is pushed onto the stack

              JSR divFPN                         ;FPN_a / FPN_b -> FPN_a
                                                 ;i.e. |Y / X| -> FPN_a                                                 
              
key14T_5_1_1: MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = FPN_a  

              JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a
                                                 ;i.e. FPN_a ^ 2 -> FPN_a      
              
              LDX #m_b                           ;set FPN_b = 00 00 00 00 00 00 00 01 00 ->

              MOVB #lenManBytes,counter1
              DEC counter1
              CLRA 
              
key14T_5_1:   STAA 1,X+
              DEC counter1
              BNE key14T_5_1                      
              
              MOVB #$01,1,X+
              CLR 0,X                            ;<-
              
              JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b 
                                                              
              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a, i.e. 1 + (tan(FPN_1))^2 -> FPN_a
              
              JSR lzMan                          ;determine number of leading zeros in FPN_a
              
              LDAA #lenMan 
              
              JSR sqrtFPN                        ;find the square root of FPN_a and store the result in FPN_b
                                                 ;i.e. FPN_b = sqrt(1+(tan(FPN_1))^2) 
                           
              LDX #m_a                           ;set FPN_a = 00 00 00 00 00 00 00 01 00 ->

              MOVB #lenManBytes,counter1
              DEC counter1
              CLRA 
              
key14T_5_2:   STAA 1,X+
              DEC counter1
              BNE key14T_5_2                      
              
              MOVB #$01,1,X+
              CLR 0,X                            ;<- 
              
              JSR divFPN                         ;FPN_a / FPN_b -> FPN_a, i.e. FPN_a = cos(FPN_1)
                   
              PULA
              TSTA
              BEQ key14T_5_3                     ;cos(FPN_1) is positive
              
              JSR negFPN                         ;otherwise negate FPN_a first
              
key14T_5_3:   MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key14T_7 

key14T_6:     BRCLR flag2,#BIT7,key14T_6_1       ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key14T_6_1:   JSR dispError                      ;display "ERROR" on the status line and exit

              BRA key14T_7
              
key14T_6_2:   LDX usPointer                      ;set FPN_1 = 00 00 00 00 00 00 00 01 00 ->

              MOVB #lenManBytes,counter1
              DEC counter1
              CLRA 
              
key14T_6_3:   STAA 1,X+
              DEC counter1
              BNE key14T_6_3                      
              
              MOVB #$01,1,X+
              CLR 0,X                            ;<-
              
key14T_7:     JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine
			  
;Key 29; sin/A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SinX:         BRCLR flag3,#BIT2,key29_0          ;branch if not in hex mode

              MOVB #$0A,keyValue
              JSR nzKey
              JMP keyHdlr_1                      ;otherwise update command line and return to scanKey subroutine         

key29_0:      LDAA noDigMan
              BNE key15T_1                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key15T_5                       ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key15T_7                      ;exit as the command line and stack are both empty
              
key15T_1:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key15T_2         ;branch if oFlow flag was not set
              
              LBRA key15T_6                      ;otherwise display "ERROR" on the status line and exit       

key15T_2:     LDD usPointer
              CPD #$2000
              BNE key15T_3                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key15T_4                         
                                                  
key15T_3:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key15T_4:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack
              
key15T_5:     MOVW usPointer,memAddr1                  
              MOVW #m_f,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_f
              
              BRCLR flag4,#BIT4,key15T_12        ;branch if not in radian mode
              LBRA key15T_8                      ;otherwise no conversion necessary
              
key15T_12:    BRSET flag1,#BIT6,key15T_11        ;branch if in gradian mode      
         
              MOVW #m_a,memAddr2                 ;otherwise convert FPN_f from degrees to radians
              JSR copyFPN                        ;FPN_1 -> FPN_a
              
              LDX #m_b
              MOVB #$01,1,X+
              MOVB #$74,1,X+
              MOVB #$53,1,X+
              MOVB #$29,1,X+
              MOVB #$25,1,X+
              MOVB #$19,1,X+
              MOVB #$94,1,X+
              MOVB #$33,1,X+
              MOVB #$F0,1,X+                     ;FPN_b = pi/180
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_a = FPN_1 * pi/180
              
              BRA key15T_8
              
key15T_11:    MOVW #m_a,memAddr2                 ;convert FPN_f from gradians to radians
              JSR copyFPN                        ;FPN_1 -> FPN_a
              
              LDX #m_b
              MOVB #$01,1,X+
              MOVB #$57,1,X+
              MOVB #$07,1,X+
              MOVB #$96,1,X+
              MOVB #$32,1,X+
              MOVB #$67,1,X+
              MOVB #$94,1,X+
              MOVB #$90,1,X+
              MOVB #$F0,1,X+                     ;FPN_b = pi/200
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                         
                            
key15T_8:     MOVW #m_f,memAddr1   

              LDX #m_f
              LDAA 0,X
              ANDA #$F0              
              
              BEQ key15T_9                       ;branch if FPN_f >= 0
                            
              JSR negFPN                         ;otherwise negate it first and set the manNeg flag 
              BSET flag2,#BIT4                  
              
key15T_9:     JSR lzMan
              LDAA #lenMan
              DECA
              SUBA noZero
              ADDA e_f                           ;A = e_f(s) = exponent of FPN_f when it is in scientific format
              
              CMPA #$0A
              LBGE key15T_6                      ;display error and exit if e_f(s) >= 10                
              
              JSR tanFPN                         ;determine Y and X such that tan of FPN_1 = Y/X
                                                 ;FPN_a = Y and FPN_b = X                                                
              MOVW #m_a,memAddr1
              BRCLR flag2,#BIT4,key15T_10        ;branch if original angle was non-negative              
              JSR negFPN                         ;otherwise negate FPN_a = Y first                                   

key15T_10:    JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBEQ key15T_7                      ;display "0" if FPN_a = 0, since divFPN subroutine requires non-zero
                                                 ;dividend
              LDX #m_a
              LDAA 0,X
              ANDA #$F0
              PSHA                               ;the sign of FPN_a = Y is pushed onto the stack              
              
              JSR divFPN                         ;FPN_a / FPN_b -> FPN_a
                                                 ;i.e. |Y / X| -> FPN_a                                                 
              
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = FPN_a = |tan x|
              
              MOVW #m_f,memAddr2                 
              JSR copyFPN                        ;FPN_f = FPN_a = |tan x| 

              JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a
                                                 ;i.e. (tan x) ^ 2 -> FPN_a      
              
              LDX #m_b                           ;set FPN_b = 00 00 00 00 00 00 00 01 00 ->

              MOVB #lenManBytes,counter1
              DEC counter1
              CLRA 
              
key15T_5_1:   STAA 1,X+
              DEC counter1
              BNE key15T_5_1                      
              
              MOVB #$01,1,X+
              CLR 0,X                            ;<-
              
              JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b 
                                                              
              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a, i.e. 1 + (tan(FPN_1))^2 -> FPN_a
              
              JSR lzMan                          ;determine number of leading zeros in FPN_a
              
              LDAA #lenMan 
              
              JSR sqrtFPN                        ;find the square root of FPN_a and store the result in FPN_b
                                                 ;i.e. FPN_b = sqrt(1+(tan(FPN_1))^2) 
                           
              MOVW #m_f,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_f = |tan x|
              
              JSR divFPN                         ;FPN_a / FPN_b -> FPN_a, i.e. FPN_a = |sin(FPN_1)|
              
              PULA
              TSTA
              BEQ key15T_5_2                     ;sin(FPN_1) should be positive
              
              JSR negFPN                         ;otherwise negate FPN_a first
              
key15T_5_2:   MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key15T_7 

key15T_6:     BRCLR flag2,#BIT7,key15T_6_1       ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key15T_6_1:   JSR dispError                      ;display "ERROR" on the status line and exit
  
key15T_7:     JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key 30: 1/x;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

OneOX:        LDAA noDigMan
              BNE key0S_1                        ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              LBNE key0S_5                       ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag
              JMP keyHdlr_1                      ;exit as the command line and stack are both empty
              
key0S_1:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key0S_2          ;branch if oFlow flag was not set
              
              LBRA key0S_5_2                     ;otherwise display "ERROR" on the status line and exit       

key0S_2:      BRSET flag4,#BIT2,key0S_20         ;branch if in exact mode

              LBRA key0S_10

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key0S_20:     LDD usPointer
              CPD #$2000
              BNE key0S_11                       ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackDenom
              
              LDD usPointer
              ADDD #lenFPNBytes                                         
                                                 
key0S_11:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              STD memAddr2
              
              PSHD
              
              MOVW #m_com,memAddr1               
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              PULD
              PSHD
              
              ADDD #$13B5                        
              
              TFR D,X                            ;X points to FPN_1_denominator

              CLRA
              MOVB #lenManBBytes,counter1
              
key0S_12:     STAA 1,X+                          ;set mantissa of FPN_1_denominator to 1 ->
              DEC counter1
              BNE key0S_12
              
              MOVB #$01,0,X                      ;<-
              
              PULD
              PSHD              
              
              STD memAddr1
                            
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key0S_13                       ;branch if FPN_1_numerator <> 0
              
              PULD
              
              LBRA key0S_5_2                     ;display "ERROR" and exit

key0S_13:     MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1_numerator
              
              MOVW #m_a,memAddr1               
              JSR tzFPN                          ;eliminate any trailing zeros in FPN_M1 = FPN_a = FPN_1_numerator                                          
              
              PULD
              PSHD              

              ADDD #lenManBytes                  
              TFR D,X                            ;X points to exponent of FPN_1_numerator
              
              LDAA 0,X                           ;A = exponent of FPN_1_numerator
              BPL key0S_14                       ;if exponent of FPN_1_numerator >= 0 set exponent of 
                                                 ;FPN_1_denominator to 0
              
              CLR 0,X                            ;otherwise set exponent of FPN_1_numerator to 0 and exponent of 
                                                 ;FPN_1_denominator to NEGA
              NEGA              
              PSHA
              
              INS
              
              PULD
              PSHD
              
              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              DES
              
              PULA
              
              STAA 0,X                           ;set exponent of FPN_1_denominator to NEGA
              
              PULD
              PSHD
              
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1_numerator copied to m_b
              
              MOVW #m_b,memAddr1              
              JSR absFPN                         ;set m_b to absolute value if required 
              
              PULD
              PSHD
              
              ADDD #$13B5
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to m_a              
              
              BRA key0S_15    
              
key0S_14:     MOVW #m_a,memAddr1              
              JSR absFPN                         ;set m_a to absolute value if required

              PULD
              PSHD

              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              MOVB #$00,0,X                      ;set exponent of FPN_1_denominator to 0
              
              SUBD #$0008                        ;D points to FPN_1_denominator
              
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to m_b
              
key0S_15:     ;exit if e_a too big ->
              
              MOVB e_b,power                     ;result will be multiplied by 10^power
              
              LDAA e_a                           ;divide FPN_a,b by 10^power
              SUBA e_b
              STAA e_a
              
              CLR e_b
              
              MOVW #m_a,memAddr1
              
              JSR lzMan   
              
              LDAA noZero
              SUBA e_a
              DECA
              
              BPL key0S_17
              
              PULD
              
              MOVW usPointer,memAddr1
              
              LBRA key0S_19                      ;otherwise don't reduce fraction to simplest form as FPN_a is too
                                                 ;big to find GCD
              ;<-

key0S_17:     JSR GCDFPN_ab                      ;determine GCD of numerator and denominator and store BCD result
                                                 ;in FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;GCD copied to FPN_b
              
              PULD
              PSHD
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_numerator copied to FPN_a
              
              JSR divFPN                         ;FPN_1_numerator/GCD -> FPN_a
              
              BRCLR flag2,#BIT4,key0S_18         ;branch if result should be positive              
             
              JSR negFPN                         ;otherwise negate m_a first 
              
key0S_18:     PULD
              PSHD
              
              STD memAddr2              
              JSR copyFPN                        ;FPN_a = simplified numerator copied to FPN_1_numerator
              
              PULD
              PSHD
              
              ADDD #$13B5
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to FPN_a
              
              JSR divFPN                         ;FPN_1_denominator/GCD -> FPN_a
              
              PULD
                            
              ADDD #$13B5
              
              STD memAddr2
              MOVW #m_a,memAddr1
              JSR copyFPN                        ;FPN_a = simplified denominator copied to FPN_1_denominator
              
              MOVW usPointer,memAddr1
              
              BRA key0S_19

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      

key0S_10:     LDD usPointer
              CPD #$2000
              BNE key0S_3                        ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key0S_4                          
                                                  
key0S_3:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key0S_4:      MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack               
              
key0S_5:      MOVW usPointer,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key0S_5_1                      ;branch if the divisor is not zero 
              
key0S_5_2:    BRCLR flag2,#BIT7,key0S_5_3        ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key0S_5_3:    JSR dispError                      ;display "ERROR" on the status line and exit  
              LBRA key0S_8                        
              
key0S_5_1:    BRCLR flag4,#BIT2,key0S_9          ;branch if not in exact mode

key0S_19:     MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1_numerator
              
              LDD usPointer
              STD memAddr2 
              ADDD #$13B5
              PSHD
              STD memAddr1
              JSR copyFPN                        ;FPN_1_numerator = FPN_1_denominator
              
              MOVW #m_a,memAddr1
              PULD
              STD memAddr2
              JSR copyFPN                        ;FPN_2_denominator = original FPN_1_numerator
              
              LDX #m_a
              LDAA 0,X
              ANDA #$F0
              LBEQ key0S_16                      ;branch if original FPN_1_numerator >= 0
              
              MOVW usPointer,memAddr1
              JSR negFPN                         ;negate FPN_1_numerator
              
              LDD usPointer
              ADDD #$13B5
              STD memAddr1
              JSR negFPN                         ;negate FPN_1_denominator 
              
              BRA key0S_16

key0S_9:      CLRA                               ;set FPN_a = 1 ->
              LDX #m_a
              MOVB #lenManBytes,counter1
              DEC counter1
                                                 
key0S_6:      STAA 1,X+                          ;clear (lenManBytes - 1) bytes of m_a
              DEC counter1
              BNE key0S_6
              
              MOVB #$01,1,X+                     ;set LS byte of mantissa of FPN_a to 1
              
              CLR 0,X                            ;<- clear e_a                   

              MOVW usPointer,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1 -> FPN_b
              
              JSR divFPN                         ;1/FPN_1 -> FPN_a
              
              BRCLR flag2,#BIT4,key0S_7          ;branch if quotient should be positive 
              JSR negFPN                         ;otherwise negate it first
              
key0S_7:      JSR chkOFPN                        ;overflow not possible,but this subroutine must be called before
                                                 ;chkUFPN
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow                   

              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a = 1 / FPN_1 -> FPN_1
              
key0S_16:     JSR clrComLMem                     ;clear command line memory
                            
key0S_8:      JMP keyHdlr_1                      ;return to scanKey subroutine    

              ORG $FE8000

;Key 31; x^y;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

XPY:          TST noDigMan
              BEQ key7S_5                        ;branch if the command line is empty
              
              JSR calcDpt                        ;otherwise calculate the depth of the user stack and store it in A
              TSTA
              BNE key7S_1
              BCLR flag4,#BIT7                   ;clear updtScreen flag
              JMP keyHdlr_1                      ;exit as the user stack depth = 0         
              
key7S_1:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key7S_2          ;branch if oFlow flag was not set
              
              LBRA key7S_25                      ;otherwise display "ERROR" on the status line and exit
              
key7S_2:      LDD usPointer
              CPD #$2000
              BNE key7S_3                        ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack
              BRA key7S_4                                   
                                                  
key7S_3:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key7S_4:      MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2              
              JSR copyFPN                        ;command line value copied to the user stack  
               
              BRA key7S_6                       
              
key7S_5:      JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key7S_6                        ;continue if the depth is greater than 1
              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag
              JMP keyHdlr_1                      ;return to scanKey subroutine as the user stack depth = 0 or 1
                                                 ;and the command line is empty
              
key7S_6:      MOVW usPointer,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;m_f = x = FPN_1
              
              LDD usPointer
              ADDD #lenFPNBytes
              STD memAddr1                       ;memAddr1 = usPointer + 9
              
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;m_b = y = FPN_2
              
              MOVW #m_i,memAddr2
              JSR copyFPN                        ;m_i = y = FPN_2 (required since logFPN subroutine alters FPN_b) 
              
              LDX #m_f
              LDAA 0,X                           ;A = MS byte of x
              ANDA #$F0
              LBNE key7S_10                      ;branch if x < 0
              
              BCLR flag3,#BIT0                   ;clear gFlag0 as result will be non-negative  
              
              MOVW #m_f,memAddr1
              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              LBNE key7S_21                      ;branch if x <> 0 (x > 0)
              
              MOVW #m_b,memAddr1
              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              BNE key7S_7                        ;branch if y <> 0
              
              LBRA key7S_24                      ;display "ERROR" on the status line and exit since x = y = 0                       
               
key7S_7:      LDX #m_b
              LDAA 0,X                           ;A = MS byte of y
              ANDA #$F0
              BEQ key7S_8                        ;branch if y > 0
              
              LBRA key7S_24                      ;display "ERROR" on the status line and exit since x = 0 & y < 0    

key7S_8:      LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;usPointer is incremented
                            
              LDX usPointer
              
              MOVB #lenFPNBytes,counter1
              
key7S_9:      CLR 1,X+                           ;set FPN_1 = 0 since x = 0 and y > 0 ->
              DEC counter1
              BNE key7S_9                        ;<-
              
              LBRA key7S_26                      ;exit
              
key7S_10:     MOVW #m_f,memAddr1
              JSR negFPN                         ;FPN_f = |x|

              MOVW #m_b,memAddr1
              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              BNE key7S_11                       ;branch if y <> 0
              
              BCLR flag3,#BIT0                   ;clear gFlag0 as result will be 1                            
              LBRA key7S_21                      
                
key7S_11:     JSR tzFPN_b                        ;eliminate trailing zeros in FPN_b = y
              
              LDAA e_b                           ;A = exponent of y after trailing zeros have been eliminated
              
              LBPL key7S_19                      ;branch if e_b >= 0, i.e. if y is an integer
              
              CLRA                               ;set FPN_a = 1 ->
              LDX #m_a
              MOVB #lenManBytes,counter1
              DEC counter1
                                                 
key7S_12:     STAA 1,X+                          ;clear (lenManBytes - 1) bytes of m_a
              DEC counter1
              BNE key7S_12
              
              MOVB #$01,1,X+                     ;set LS byte of mantissa of FPN_a to 1
              
              CLR 0,X                            ;clear e_a <-                    

              JSR divFPN                         ;FPN_a/FPN_b = 1/y = z -> FPN_a
              
              BRCLR flag2,#BIT4,key7S_13         ;branch if z should be positive 
              JSR negFPN                         ;otherwise negate it first
              
key7S_13:     JSR chkOFPN                        ;overflow not possible,but this subroutine must be called before
                                                 ;chkUFPN
                                                 
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow (FPN_a set to 0 if underflow)
              
              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              BNE key7S_14                       ;branch if z <> 0
              
              LBRA key7S_24                      ;display "ERROR" on the status line and exit since x < 0 & z = 0
              
key7S_14:     JSR tzFPN                          ;eliminate trailing zeros in FPN_a = z
              
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = FPN_a = z
              
              MOVW #m_i,memAddr2
              JSR copyFPN                        ;FPN_i = FPN_a = z (required since logFPN subroutine alters FPN_b) 
              
              LDAA e_b                           ;A = exponent of z after trailing zeros have been eliminated
              
              BPL key7S_15                       ;branch if e_b >= 0, i.e. if z is an integer              
              
              LBRA key7S_24                      ;otherwise display "ERROR" on the status line and exit since 
                                                 ;x < 0 and z is not an integer
key7S_15:     LBNE key7S_24                      ;branch if e_b > 0 (z is even), i.e. display "ERROR" on the status 
                                                 ;line and exit since x < 0 & z is even
              
              LDX #e_b                         
              DEX                                ;X = address of e_b - 1 (LS byte of mantissa of z)
              
              LDAA 0,X                           ;A = LS byte of mantissa of z
              
              ASRA                               ;shift bit 0 of LS byte of mantissa of z into C
              
              LBCC key7S_24                      ;branch if z is even, i.e. display "ERROR" on the status line and
                                                 ;exit since x < 0 & z is even
              BSET flag3,#BIT0                   ;set gFlag0 as result is negative              
              
              MOVW #logEValues,logValues         ;store address of special values used in logFPN subroutine
              MOVW #logETen,logbTen 
              
              MOVW #m_f,memAddr1
              JSR lzMan
              LDAB noZero                        ;noZero is used in logFPN subroutine 
              
              JSR logFPN                         ;find the natural logarithm of FPN_f and store in FPN_a
              
              MOVW #m_i,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = z  
                                               
              JSR divFPN                         ;divide FPN_a by FPN_b and store the result in FPN_a
                                                 ;i.e. ln(x) / z -> FPN_a             

              BRCLR flag2,#BIT4,key7S_22         ;branch if manNeg flag clear, i.e. FPN_a should be positive

              JSR negFPN                         ;otherwise negate FPN_a first
              
              BRA key7S_22                                                              
                                                              
key7S_19:     BNE key7S_20                       ;branch if e_b > 0 (y is even)
         
              LDX #e_b                         
              DEX                                ;X = address of e_b - 1 (LS byte of mantissa of y)
              
              LDAA 0,X                           ;A = LS byte of mantissa of y
              
              ASRA                               ;shift bit 0 of LS byte of mantissa of y into C
              
              BCC key7S_20                       ;branch if y is even
              
              BSET flag3,#BIT0                   ;set gFlag0 as result is negative
              
              BRA key7S_21 
              
key7S_20:     BCLR flag3,#BIT0                   ;clear gFlag0 as result is positive      
              
key7S_21:     MOVW #logEValues,logValues         ;store address of special values used in logFPN subroutine
              MOVW #logETen,logbTen
              
              MOVW #m_f,memAddr1
              JSR lzMan
              LDAB noZero                        ;noZero is used in logFPN subroutine 
              
              JSR logFPN                         ;find the natural logarithm of FPN_f and store in FPN_a
                       
              MOVW #m_i,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = y
              
              JSR multFPN                        ;multiply FPN_a by FPN_b and store the result in FPN_a
                                                 ;i.e. ln(x) * y -> FPN_a             

              BRCLR flag2,#BIT4,key7S_22         ;branch if manNeg flag clear, i.e. FPN_a should be positive

              JSR negFPN                         ;otherwise negate FPN_a first          

key7S_22:     MOVW #m_f,memAddr2                 ;copy FPN_a to FPN_f as cmpFPN_GE subroutine below alters value of 
              JSR copyFPN                        ;FPN_a      

              LDX #m_b                           ;FPN_b = 230.25850929934 ->
                                                 
              MOVB #$02,1,X+
              MOVB #$30,1,X+
              MOVB #$25,1,X+
              MOVB #$85,1,X+
              MOVB #$09,1,X+
              MOVB #$29,1,X+
              MOVB #$93,1,X+
              MOVB #$40,1,X+                     ;m_b = 02 30 25 85 09 29 93 40
              
              MOVB #$F4,0,X                      ;e_b = -12

              JSR cmpFPN_GE                      ;sets ge flag if FPN_a >= FPN_b
                                                 ;i.e. if y * ln(x) or ln(x)/y >= 230.25850929934 
              
              BRSET flag5,#BIT0,key7S_24         ;display "ERROR" if ge flag set
              
              MOVW #negLogEValues,negLogValues   ;store address of special values used in expFPN subroutine              
              
              JSR expFPN                         ;find e^FPN_f and store the result in FPN_b
              
              LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;increment usPointer
              
              MOVW #m_b,memAddr1
              
              BRCLR flag3,#BIT0,key7S_23         ;branch as result should be positive 
              
              JSR negFPN                         ;otherwise negate FPN_b as result should be negative 

key7S_23:     MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_b -> FPN_1, i.e. x^y/x^(1/y) -> FPN_1
              
              BRA key7S_26                       ;exit
              
key7S_24:     BRCLR flag2,#BIT7,key7S_25         ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer first 
              ADDD #lenFPNBytes
              STD usPointer            

key7S_25:     JSR dispError                      ;display "ERROR" on the status line and exit

key7S_26:     JSR clrComLMem                     ;clear command line memory              

              JMP keyHdlr_1                      ;return to scanKey subroutine
			  
;Key 32: x^2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

XSQ:          BRCLR flag4,#BIT2,key11S_8         ;branch if not in exact mode
              
              LBRA key11S_9

key11S_8:     LDAA noDigMan
              BNE key11S_0                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key11S_0_4                     ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              JMP keyHdlr_1                      ;exit as the command line and stack are both empty
              
key11S_0:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key11S_0_1       ;branch if oFlow flag was not set
              
              BRA key11S_3                       ;otherwise display "ERROR" on the status line and exit       

key11S_0_1:   LDD usPointer
              CPD #$2000
              BNE key11S_0_2                     ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key11S_0_3                          
                                                  
key11S_0_2:   SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key11S_0_3:   MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack               
              
key11S_0_4:   MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1 -> FPN_a
              
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1 -> FPN_b
              
              JSR chkExp                         ;check 2 * e_1 for overflow/underflow
              
              BRCLR flag2,#BIT5,key11S_1         ;branch if the oFlow flag was not set
              
key11S_1:     BRCLR flag2,#BIT6,key11S_2         ;branch if the uFlow flag was not set
 
              JSR clrComLMem                     ;clear command line memory 
              BRA key11S_6                       ;return to scanKey subroutine                                                                      
               
key11S_2:     JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a
                                                 ;i.e. FPN_1 ^ 2 -> FPN_a

              JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key11S_4         ;branch if the oFlow flag was not set
              
key11S_3:     BRCLR flag2,#BIT7,key11S_7         ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key11S_7:     JSR dispError                      ;display "ERROR" on the status line and exit  
              BRA key11S_6          

key11S_4:     MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1 ^ 2 -> FPN_1
              
key11S_30:    JSR clrComLMem                     ;clear command line memory 
                           
key11S_6:     JMP keyHdlr_1                      ;return to scanKey subroutine

              ;exact mode ->
              
key11S_9:     LDAA noDigMan
              BNE key11S_10                      ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              LBNE key11S_18                     ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              JMP keyHdlr_1                      ;exit as the command line and stack are both empty 
              
key11S_10:    JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key11S_11        ;branch if oFlow flag was not set
              
              BRA key11S_3                       ;otherwise display "ERROR" on the status line and exit       

key11S_11:    LDD usPointer
              CPD #$2000
              BNE key11S_12                      ;if the top of the stack has not yet been reached,push the 
                                                 ;command line value onto it  
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack            
              JSR resetStackDenom
              
              LDD usPointer
              ADDD #lenFPNBytes                                         
                                                 
key11S_12:    SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              STD memAddr2
              
              PSHD
              
              MOVW #m_com,memAddr1               
              JSR copyFPN                        ;command line value copied to the calculator stack
              
              PULD
              PSHD
              
              ADDD #$13B5                        
              
              TFR D,X                            ;X points to FPN_1_denominator

              CLRA
              MOVB #lenManBBytes,counter1
              
key11S_13:    STAA 1,X+                          ;set mantissa of FPN_1_denominator to 1 ->
              DEC counter1
              BNE key11S_13
              
              MOVB #$01,0,X                      ;<-
              
              PULD
              PSHD              
              
              STD memAddr1                            
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1_numerator
              
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key11S_27                      ;branch if command line <> 0
              
              ;otherwise set numerator to 0, denominator to 1 ->
              
              PULD
              TFR D,X
              
              CLRA              
              MOVB #$09,counter1
              
 key11S_28:   STAA 1,X+                          ;set FPN_1_numerator = 0 ->
              DEC counter1
              BNE key11S_28                      ;<-
              
              LDD usPointer
              ADDD #$13B5
              TFR D,X
              
              CLRA              
              MOVB #$07,counter1
              
 key11S_29:   STAA 1,X+                          ;set FPN_1_denominator = 1 ->
              DEC counter1
              BNE key11S_29
              
              MOVB #$01,1,X+
              
              STAA 0,X
               
              ;<-                                                
              
              LBRA key11S_30                     ;exit
              
key11S_27:    MOVW #m_a,memAddr1               
              JSR tzFPN                          ;eliminate any trailing zeros in FPN_M1 = FPN_a = FPN_1_numerator                                          
              
              PULD
              PSHD              

              ADDD #lenManBytes                  
              TFR D,X                            ;X points to exponent of FPN_1_numerator
              
              LDAA 0,X                           ;A = exponent of FPN_1_numerator
              BPL key11S_14                      ;if exponent of FPN_1_numerator >= 0 set exponent of 
                                                 ;FPN_1_denominator to 0
              
              CLR 0,X                            ;otherwise set exponent of FPN_1_numerator to 0 and exponent of 
                                                 ;FPN_1_denominator to NEGA
              NEGA              
              PSHA
              
              INS
              
              PULD
              PSHD
              
              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              DES
              
              PULA
              
              STAA 0,X                           ;set exponent of FPN_1_denominator to NEGA
              
              PULD
              PSHD
              
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1_numerator copied to m_b
              
              MOVW #m_b,memAddr1              
              JSR absFPN                         ;set m_b to absolute value if required 
              
              PULD
              PSHD
              
              ADDD #$13B5
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to m_a              
              
              BRA key11S_15    
              
key11S_14:    MOVW #m_a,memAddr1              
              JSR absFPN                         ;set m_a to absolute value if required

              PULD
              PSHD

              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              MOVB #$00,0,X                      ;set exponent of FPN_1_denominator to 0
              
              SUBD #$0008                        ;D points to FPN_1_denominator
              
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to m_b
              
key11S_15:    ;exit if e_a too big ->
              
              MOVB e_b,power                     ;result will be multiplied by 10^power
              
              LDAA e_a                           ;divide FPN_a,b by 10^power
              SUBA e_b
              STAA e_a
              
              CLR e_b
              
              MOVW #m_a,memAddr1
              
              JSR lzMan   
              
              LDAA noZero
              SUBA e_a
              DECA
              
              BPL key11S_16
              
              PULD
              
              BRA key11S_18                      ;otherwise don't reduce fraction to simplest form as FPN_a is too
                                                 ;big to find GCD
              ;<-

key11S_16:    JSR GCDFPN_ab                      ;determine GCD of numerator and denominator and store BCD result
                                                 ;in FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;GCD copied to FPN_b
              
              PULD
              PSHD
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_numerator copied to FPN_a
              
              JSR divFPN                         ;FPN_1_numerator/GCD -> FPN_a
              
              BRCLR flag2,#BIT4,key11S_17        ;branch if result should be positive              
             
              JSR negFPN                         ;otherwise negate m_a first 
              
key11S_17:    PULD
              PSHD
              
              STD memAddr2              
              JSR copyFPN                        ;FPN_a = simplified numerator copied to FPN_1_numerator
              
              PULD
              PSHD
              
              ADDD #$13B5
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to FPN_a
              
              JSR divFPN                         ;FPN_1_denominator/GCD -> FPN_a
              
              PULD
                            
              ADDD #$13B5
              
              STD memAddr2
              MOVW #m_a,memAddr1
              JSR copyFPN                        ;FPN_a = simplified denominator copied to FPN_1_denominator
              
key11S_18:    MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_numerator -> FPN_a
              
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1_numerator -> FPN_b
              
              JSR chkExp                         ;check 2 * e_1 for overflow/underflow
              
              BRCLR flag2,#BIT5,key11S_19        ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" and exit
              LBRA key11S_6
              
key11S_19:    BRCLR flag2,#BIT6,key11S_20        ;branch if the uFlow flag was not set
 
              JSR clrComLMem                     ;otherwise clear command line memory 
              LBRA key11S_6                      ;return to scanKey subroutine                                                                      
               
key11S_20:    JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a
                                                 ;i.e. FPN_1_numerator ^ 2 -> FPN_a

              JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key11S_21        ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" and exit
              LBRA key11S_6
              
key11S_21:    BRCLR flag2,#BIT6,key11S_22        ;branch if the uFlow flag was not set
 
              JSR clrComLMem                     ;otherwise clear command line memory 
              LBRA key11S_6                      ;return to scanKey subroutine                                                                      
               
key11S_22:    MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1_numerator ^ 2 -> FPN_1
              
              LDD usPointer
              ADDD #$13B5
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_denominator -> FPN_a
              
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1_denominator -> FPN_b
              
              JSR chkExp                         ;check 2 * e_1 for overflow/underflow
              
              BRCLR flag2,#BIT5,key11S_23        ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" and exit
              LBRA key11S_6
              
key11S_23:    BRCLR flag2,#BIT6,key11S_24        ;branch if the uFlow flag was not set
 
              JSR dispError                      ;otherwise display "ERROR" and exit
              LBRA key11S_6                                                                     
               
key11S_24:    JSR multFPN                        ;multiply FPN_a with FPN_b and store the result in FPN_a
                                                 ;i.e. FPN_1_denominator ^ 2 -> FPN_a

              JSR chkOFPN                        ;check FPN_M1 = FPN_a for overflow 
              
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow
              
              BRCLR flag2,#BIT5,key11S_25        ;branch if the oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" and exit
              LBRA key11S_6
              
key11S_25:    BRCLR flag2,#BIT6,key11S_26        ;branch if the uFlow flag was not set
 
              JSR dispError                      ;otherwise display "ERROR" and exit
              LBRA key11S_6                                                                  
               
key11S_26:    LDD usPointer
              ADDD #$13B5   
              STD memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1_denominator ^ 2 -> FPN_1_denominator
              
              JSR clrComLMem                     ;clear command line memory 
              
              LBRA key11S_6
             
              ;<- end exact mode 
			  
;Key 33: Hex;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

HEX:          BSET flag3,#BIT2                   ;set hex flag
              BSET flag3,#BIT3                   ;set hex/bin flag

              BCLR flag4,#BIT2                   ;clear exact flag
              BCLR flag4,#BIT0                   ;clear bin flag              
              BCLR flag4,#BIT1                   ;clear cpx flag
              BCLR flag5,#BIT7                   ;clear 2-adic flag 
                                                                                                 
              JSR clrComLMem                     ;clear command line memory
              
              JMP keyHdlr_1                      ;return to scanKey subroutine
			  
;Key 34: Dec/Sci display format toggle key;;;;;;;;

DECI:         BCLR flag3,#BIT2                   ;clear hex flag
              BCLR flag4,#BIT2                   ;clear exact flag
              BCLR flag4,#BIT0                   ;clear bin flag              
              BCLR flag4,#BIT1                   ;clear the cpx flag               
              BCLR flag3,#BIT3                   ;clear hex/bin flag
              BCLR flag5,#BIT7                   ;clear 2-adic flag                 

              MOVB #$12,counter1                 ;determines how long the key must be held
              
key3S_1:      BRSET PTP,#BIT1,key3S_2            ;branch if PTP.1 = 1, i.e. if Key 34 has been released 
              JSR delay
              DEC counter1
              BNE key3S_1
              
              BSET flag1,#BIT3                   ;Key 34 was held so set sci flag
              BRA key3S_3

key3S_2:      BCLR flag1,#BIT3                   ;Key 34 was not held so clear sci flag      

key3S_3:      CLR menu      

              JSR clrComLMem                     ;clear command line memory
              
              JMP keyHdlr_1                      ;return to scanKey subroutine 
			  
;Key 35: Bin;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

BIN:          BSET flag4,#BIT0                   ;set bin flag
              BSET flag3,#BIT3                   ;set hex/bin flag
              BCLR flag3,#BIT2                   ;clear hex flag              
              BCLR flag4,#BIT1                   ;clear cpx flag

              MOVB #$12,counter1                 ;determines how long the key must be held
              
key35_1:      BRSET PTP,#BIT0,key35_2            ;branch if PTP.0 = 1, i.e. if Key 35 has been released 
              JSR delay
              DEC counter1
              BNE key35_1
              
              BSET flag5,#BIT7                   ;set 2-adic flag
              BSET flag4,#BIT2                   ;set exact flag
              CALL setDenomStk
              
              BRA key35_3 

key35_2:      BCLR flag5,#BIT7                   ;clear 2-adic flag     
              BCLR flag4,#BIT2                   ;clear exact flag
                                                                                                 
key35_3:      JSR clrComLMem                     ;clear command line memory
              
              JMP keyHdlr_1                      ;return to scanKey subroutine
			  
;Key 36: EXIT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EXIT:         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              LDAA noDigMan
              BEQ EXIT_cont                      ;branch if the command line is empty
              
              JMP mega                           ;otherwise simulate multiplication by 10^6 (mega) and "Enter" press
                                                 
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        

EXIT_cont:    CLRA

              LDAB menu
              ASLB                               

              LDX #EXITTable     

              JMP [D,X]

EXITTable     DC.W key36_exit                    ;menu0 
              DC.W key36_exitcplx                ;menu1 = CPLX1                           
              DC.W key36_exitcplx                ;menu2 = CPLX2 
              DC.W key36_rethome                 ;menu3 = ASM1 
              DC.W key36_rethome                 ;menu4 = ASM2               
              DC.W key36_rethome                 ;menu5 = NUM1 
              DC.W key36_rethome                 ;menu6 = NUM2  
              DC.W key36_rethome                 ;menu7 = POL1 
              DC.W key36_rethome                 ;menu8 = POL2  
              DC.W key36_rethome                 ;menu9 = CALC1 
              DC.W key36_rethome                 ;menu10 = CALC2  
              DC.W key36_rethome                 ;menu11 = OPR1 
              DC.W key36_rethome                 ;menu12 = OPR2  
              DC.W key36_rethome                 ;menu13 = FUNC1 
              DC.W key36_rethome                 ;menu14 = FUNC2 
              DC.W key36_rethome                 ;menu15 = FIN1 
              DC.W key36_rethome                 ;menu16 = FIN2  
              DC.W key36_rethome                 ;menu17 = PRO1
              DC.W key36_rethome                 ;menu18 = PRO2 
              DC.W key36_rethome                 ;menu19 = STA1 
              DC.W key36_rethome                 ;menu20 = STA2   
              DC.W key36_rethome                 ;menu21 = MAT1 
              DC.W key36_rethome                 ;menu22 = MAT2 
              DC.W key36_rethome                 ;menu23 = STAK1 
              DC.W key36_rethome                 ;menu24 = STAK2
              DC.W key36_rethome                 ;menu25 = GRPH1 
              DC.W key36_rethome                 ;menu26 = GRPH2 
              DC.W key36_rethome                 ;menu27 = APP1 
              DC.W key36_rethome                 ;menu28 = APP2  
              DC.W key36_rethomeSYS              ;menu29 = SYS1 
              DC.W key36_rethomeSYS              ;menu30 = SYS2  
              DC.W key36_rethome                 ;menu31 = MODE1 
              DC.W key36_rethome                 ;menu32 = MODE2 
              DC.W key36_rethome                 ;menu33 = EQN1 
              DC.W key36_rethome                 ;menu34 = EQN2  
              DC.W key36_rethome                 ;menu35 = BIN1 
              DC.W key36_rethome                 ;menu36 = BIN2 

key36_exitcplx:     
              BCLR flag4,#BIT1                   ;clear cplx flag
              
key36_rethome:CLR menu
              BRA key36_exit
              
key36_rethomeSYS:
              BRCLR flag4,#BIT1,key36_rethome_SYS_1  
                                                 ;branch if not in complex number mode

              MOVB #$01,menu
              BRA key36_exit

key36_rethome_SYS_1:
              CLR menu 
                            
key36_exit:   JMP keyHdlr_1             

;Key 37: DOWN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       
DOWN:         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              LDAA noDigMan
              BEQ DOWN_cont                      ;branch if the command line is empty
              
              JMP kilo                           ;otherwise simulate multiplication by 10^3 (kilo) and "Enter" press
                                                 
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;       

DOWN_cont:    BCLR flag4,#BIT7                   ;clear updtScreen flag

              LDAA screenNumber                  
              BEQ DOWN_exit                      ;exit if screen number = 0
              
              DECA
              STAA screenNumber                  ;otherwise decrement screen number              
              
              CALL updateStack                   ;update the stack
              JSR clrComLMem                     ;clear command line memory
              CALL clrComL                       ;clear the command line
                      
DOWN_exit:    JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 38: UP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

UP:           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              LDAA noDigMan
              BEQ UP_cont                        ;branch if the command line is empty
              
              JMP milli                          ;otherwise simulate multiplication by 10^-3 (milli) and "Enter" press
                                                 
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;          

UP_cont:      BCLR flag4,#BIT7                   ;clear updtScreen flag     

              JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              TSTA
              BEQ UP_exit                        ;exit if user stack depth = 0
              DECA
              TAB                                ;B = A
              CLRA              
              
              LDX #$0005
  
              IDIV                               ;D / X -> X, remainder -> D. i.e. if
                                                 ;B = 5q + r , q -> X, r -> D 
              
              TFR X,D                            ;B = total number of screens
              
              CMPB screenNumber
              
              BEQ UP_exit                        ;exit if B = screen number
              
              INC screenNumber                   ;otherwise increment screen number and update the stack  
              
              CALL updateStack                   ;update the stack 
              JSR clrComLMem                     ;clear command line memory
              CALL clrComL                       ;clear the command line

UP_exit:      JMP keyHdlr_1                      ;return to scanKey subroutine                         

;Key 39: RIGHT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RIGHT:        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              LDAA noDigMan
              BEQ key39_exit                     ;branch if the command line is empty
              
              JMP micro                          ;otherwise simulate multiplication by 10^-6 (micro) and "Enter" press
                                                 
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                   
              
key39_exit:   JMP keyHdlr_1                        

;Key 40: LEFT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LEFT:         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              LDAA noDigMan
              BEQ key40_exit                     ;branch if the command line is empty
              
              JMP nano                           ;otherwise simulate multiplication by 10^-9 (nano) and "Enter" press
                                                 
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                      
              
key40_exit:   JMP keyHdlr_1 
        
;Key 41; NEXT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NEXT:         MOVB #$12,counter1                 ;determines how long the key must be held
              
key41_loop:   BRSET PTP,#BIT0,key41_cont         ;branch if PTP.0 = 1, i.e. if Key 41 has been released 
              JSR delay
              DEC counter1
              BNE key41_loop
              
              BRA key41_exit                     ;PREV menu (future implementation)                           
              
key41_cont:   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              LDAA noDigMan
              BEQ key41_next                     ;branch if the command line is empty
              
              JMP pico                           ;otherwise simulate multiplication by 10^-12 (pico) and "Enter" press
                                                 
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key41_next:   LDAB menu      
              LDX #NxtMenu
              ABX                                ;X + menu -> X
              
              MOVB 0,X,menu                      ;select the new menu
              
key41_exit:   JMP keyHdlr_1          
              
;Key 42; MK6 user menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M6:           MOVB #$12,counter1                 ;determines how long the key must be held

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS6 set PTP.5=1 to simulate key released
              ;MOVB #$20,PTP
              ;CLR PTP                            ;otherwise set PTP.5=0 to simulate key held
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key42_loop:   BRSET PTP,#BIT5,key42_cont         ;branch if PTP.5 = 1, i.e. if Key 42 has been released 
              JSR delay
              DEC counter1
              BNE key42_loop
              
              LDAA menu
              BNE key42_exit                     ;exit if not in menu 0 
              
              ;JSR clrComLMem                     
              
              JMP Prg6Db                         ;otherwise debug program PRG6      

key42_cont:   CLRA

              LDAB menu
              ASLB                               

              LDX #MK6Table     

              JMP [D,X]

MK6Table      DC.W PRG6                          ;menu0 = key133 (execute PRG6)
              DC.W RECT                          ;menu1 = CPLX1 function 6 = polar to rectangular                          
              DC.W PRG6                          ;menu2 = CPLX2 function 6 = PRG6 
              DC.W key42_exit                    ;menu3 = ASM1 function 6
              DC.W key42_exit                    ;menu4 = ASM2 function 6               
              DC.W TWOPX                         ;menu5 = NUM1 function 6 = 2^x 
              DC.W key42_exit                    ;menu6 = NUM2 function 6 
              DC.W key42_exit                    ;menu7 = POL1 function 6
              DC.W key42_exit                    ;menu8 = POL2 function 6 
              DC.W key42_exit                    ;menu9 = CALC1 function 6
              DC.W key42_exit                    ;menu10 = CALC2 function 6 
              DC.W key42_exit                    ;menu11 = OPR1 function 6
              DC.W key42_exit                    ;menu12 = OPR2 function 6 
              DC.W ATANH                         ;menu13 = HYP1 function 6 = arctanh x
              DC.W key42_exit                    ;menu14 = HYP2 function 6 
              DC.W key42_exit                    ;menu15 = FIN1 function 6
              DC.W key42_exit                    ;menu16 = FIN2 function 6 
              DC.W key42_exit                    ;menu17 = PRO1 function 6
              DC.W key42_exit                    ;menu18 = PRO2 function 6 
              DC.W key42_exit                    ;menu19 = STA1 function 6
              DC.W key42_exit                    ;menu20 = STA2 function 6  
              DC.W key42_exit                    ;menu21 = MAT1 function 6
              DC.W key42_exit                    ;menu22 = MAT2 function 6 
              DC.W ENT4                          ;menu23 = STAK1 function 6 = ENTER4
              DC.W key42_exit                    ;menu24 = STAK2 function 6 
              DC.W key42_exit                    ;menu25 = GRPH1 function 6
              DC.W key42_exit                    ;menu26 = GRPH2 function 6 
              DC.W key42_exit                    ;menu27 = APP1 function 6
              DC.W key42_exit                    ;menu28 = APP2 function 6 
              DC.W key42_exit                    ;menu29 = S121 function 6
              DC.W ABOUT                         ;menu30 = S122 function 6 = ABOUT page 
              DC.W key42_exit                    ;menu31 = MODE1 function 6
              DC.W key42_exit                    ;menu32 = MODE2 function 6
              DC.W key42_exit                    ;menu33 = EQN1 function 6 
              DC.W key42_exit                    ;menu34 = EQN2 function 6
              DC.W key42_exit                    ;menu35 = BIN1 function 6 
              DC.W key42_exit                    ;menu36 = BIN2 function 6
                                          
key42_exit:   JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 43; MK5 user menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M5:           MOVB #$12,counter1                 ;determines how long the key must be held

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS7 set PTP.4=1 to simulate key released
              ;MOVB #$10,PTP
              ;CLR PTP                            ;otherwise set PTP.4=0 to simulate key held
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key43_loop:   BRSET PTP,#BIT4,key43_cont         ;branch if PTP.4 = 1, i.e. if Key 43 has been released 
              JSR delay
              DEC counter1
              BNE key43_loop
              
              LDAA menu
              BNE key43_exit                     ;exit if not in menu 0 
              
              ;JSR clrComLMem                     
              
              JMP Prg6Db                         ;otherwise debug program PRG5      

key43_cont:   CLRA

              LDAB menu
              ASLB                               

              LDX #MK5Table     

              JMP [D,X]

MK5Table      DC.W PRG6                          ;menu0 = key133 (execute PRG5)
              DC.W POLAR                         ;menu1 = CPLX1 function 5 = rectangular to polar                          
              DC.W PRG6                          ;menu2 = CPLX2 function 5 = PRG5
              DC.W key43_exit                    ;menu3 = ASM1 function 5
              DC.W key43_exit                    ;menu4 = ASM2 function 5              
              DC.W LoCM                          ;menu5 = NUM1 function 5 = LCM
              DC.W key43_exit                    ;menu6 = NUM2 function 5 
              DC.W key43_exit                    ;menu7 = POL1 function 5
              DC.W key43_exit                    ;menu8 = POL2 function 5
              DC.W key43_exit                    ;menu9 = CAL1 function 5
              DC.W key43_exit                    ;menu10 = CAL2 function 5
              DC.W key43_exit                    ;menu11 = OPR1 function 5
              DC.W key43_exit                    ;menu12 = OPR2 function 5
              DC.W ACOSH                         ;menu13 = HYP1 function 5 = arccosh x
              DC.W key43_exit                    ;menu14 = HYP2 function 5
              DC.W key43_exit                    ;menu15 = FIN1 function 5
              DC.W key43_exit                    ;menu16 = FIN2 function 5
              DC.W key43_exit                    ;menu17 = PRO1 function 5
              DC.W key43_exit                    ;menu18 = PRO2 function 5
              DC.W MEANX                         ;menu19 = STA1 function 5 = mean of x
              DC.W key43_exit                    ;menu20 = STA2 function 5
              DC.W key43_exit                    ;menu21 = MAT1 function 5
              DC.W key43_exit                    ;menu22 = MAT2 function 5
              DC.W ENT3                          ;menu23 = STAK1 function 5 = ENTER3
              DC.W key43_exit                    ;menu24 = STAK2 function 5
              DC.W key43_exit                    ;menu25 = GRPH1 function 5
              DC.W key43_exit                    ;menu26 = GRPH2 function 5
              DC.W key43_exit                    ;menu27 = APP1 function 5
              DC.W key43_exit                    ;menu28 = APP2 function 5
              DC.W key43_exit                    ;menu29 = S121 function 5
              DC.W key43_exit                    ;menu30 = S122 function 5
              DC.W key43_exit                    ;menu31 = MODE1 function 5
              DC.W key43_exit                    ;menu32 = MODE2 function 5
              DC.W key43_exit                    ;menu33 = EQN1 function 5 
              DC.W key43_exit                    ;menu34 = EQN2 function 5
              DC.W key43_exit                    ;menu35 = BIN1 function 5 
              DC.W key43_exit                    ;menu36 = BIN2 function 5
                            
key43_exit:   JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 44; MK4 user menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M4:           MOVB #$12,counter1                 ;determines how long the key must be held

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS8 set PTP.3=1 to simulate key released
              ;MOVB #$08,PTP
              ;CLR PTP                            ;otherwise set PTP.3=0 to simulate key held
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key44_loop:   BRSET PTP,#BIT3,key44_cont         ;branch if PTP.3 = 1, i.e. if Key 44 has been released 
              JSR delay
              DEC counter1
              BNE key44_loop
              
              LDAA menu
              BNE key44_exit                     ;exit if not in menu 0 
              
              ;JSR clrComLMem                     
              
              JMP Prg6Db                         ;otherwise debug program PRG4      

key44_cont:   CLRA

              LDAB menu
              ASLB                               

              LDX #MK4Table     

              JMP [D,X]

MK4Table      DC.W PRG6                          ;menu0 = key133 (execute PRG4)
              DC.W MODZ                          ;menu1 = CPLX1 function 4 = absolute value of Z                          
              DC.W PRG6                          ;menu2 = CPLX2 function 4 = PRG4 
              DC.W key44_exit                    ;menu3 = ASM1 function 4
              DC.W key44_exit                    ;menu4 = ASM2 function 4              
              DC.W GrCD                          ;menu5 = NUM1 function 4 = GCD
              DC.W key44_exit                    ;menu6 = NUM2 function 4 
              DC.W key44_exit                    ;menu7 = POL1 function 4
              DC.W key44_exit                    ;menu8 = POL2 function 4
              DC.W key44_exit                    ;menu9 = CAL1 function 4
              DC.W key44_exit                    ;menu10 = CAL2 function 4
              DC.W key44_exit                    ;menu11 = OPR1 function 4
              DC.W key44_exit                    ;menu12 = OPR2 function 4
              DC.W ASINH                         ;menu13 = HYP1 function 4 = arcsinh x
              DC.W key44_exit                    ;menu14 = HYP2 function 4
              DC.W key44_exit                    ;menu15 = FIN1 function 4
              DC.W key44_exit                    ;menu16 = FIN2 function 4
              DC.W key44_exit                    ;menu17 = PRO1 function 4
              DC.W key44_exit                    ;menu18 = PRO2 function 4
              DC.W key44_exit                    ;menu19 = STA1 function 4 = y(K)->
              DC.W key44_exit                    ;menu20 = STA2 function 4
              DC.W key44_exit                    ;menu21 = MAT1 function 4
              DC.W key44_exit                    ;menu22 = MAT2 function 4
              DC.W ENT2                          ;menu23 = STAK1 function 4 = ENTER2
              DC.W key44_exit                    ;menu24 = STAK2 function 4
              DC.W key44_exit                    ;menu25 = GRPH1 function 4
              DC.W key44_exit                    ;menu26 = GRPH2 function 4
              DC.W key44_exit                    ;menu27 = APP1 function 4
              DC.W key44_exit                    ;menu28 = APP2 function 4
              DC.W key44_exit                    ;menu29 = S121 function 4
              DC.W key44_exit                    ;menu30 = S122 function 4
              DC.W key44_exit                    ;menu31 = MODE1 function 4
              DC.W key44_exit                    ;menu32 = MODE2 function 4
              DC.W key44_exit                    ;menu33 = EQN1 function 4 
              DC.W key44_exit                    ;menu34 = EQN2 function 4
              DC.W key44_exit                    ;menu35 = BIN1 function 4 
              DC.W key44_exit                    ;menu36 = BIN2 function 4
                            
key44_exit:   JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 45; MK3 user menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M3:           MOVB #$12,counter1                 ;determines how long the key must be held

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS9 set PTP.2=1 to simulate key released
              ;MOVB #$04,PTP
              ;CLR PTP                            ;otherwise set PTP.2=0 to simulate key held
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key45_loop:   BRSET PTP,#BIT2,key45_cont         ;branch if PTP.2 = 1, i.e. if Key 45 has been released 
              JSR delay
              DEC counter1
              BNE key45_loop
              
              LDAA menu
              BNE key45_exit                     ;exit if not in menu 0 
              
              ;JSR clrComLMem                     
              
              JMP Prg6Db                         ;otherwise debug program PRG3      

key45_cont:   CLRA

              LDAB menu
              ASLB                               

              LDX #MK3Table     

              JMP [D,X]

MK3Table      DC.W PRG6                          ;menu0 = key133 (execute PRG3)
              DC.W COZ                           ;menu1 = CPLX1 function 3 = complement of Z                          
              DC.W PRG6                          ;menu2 = CPLX2 function 3 = PRG3 
              DC.W key45_exit                    ;menu3 = ASM1 function 3
              DC.W key45_exit                    ;menu4 = ASM2 function 3               
              DC.W CEIL                          ;menu5 = NUM1 function 3 = ceiling function
              DC.W key45_exit                    ;menu6 = NUM2 function 3 
              DC.W key45_exit                    ;menu7 = POL1 function 3
              DC.W key45_exit                    ;menu8 = POL2 function 3
              DC.W key45_exit                    ;menu9 = CAL1 function 3
              DC.W key45_exit                    ;menu10 = CAL2 function 3
              DC.W key45_exit                    ;menu11 = OPR1 function 3
              DC.W key45_exit                    ;menu12 = OPR2 function 3
              DC.W TANH                          ;menu13 = HYP1 function 3 = tanh x
              DC.W key45_exit                    ;menu14 = HYP2 function 4
              DC.W key45_exit                    ;menu15 = FIN1 function 3
              DC.W key45_exit                    ;menu16 = FIN2 function 3
              DC.W SETRand                       ;menu17 = PRO1 function 3 = set random number seed
              DC.W key45_exit                    ;menu18 = PRO2 function 3
              DC.W XKOUT                         ;menu19 = STA1 function 3 = x(K)->
              DC.W key45_exit                    ;menu20 = STA2 function 3
              DC.W key45_exit                    ;menu21 = MAT1 function 3
              DC.W key45_exit                    ;menu22 = MAT2 function 3
              DC.W OVER                          ;menu23 = STAK1 function 3 = OVER
              DC.W DEL3                          ;menu24 = STAK2 function 3 = DELETE3
              DC.W key45_exit                    ;menu25 = GRPH1 function 3
              DC.W key45_exit                    ;menu26 = GRPH2 function 3
              DC.W key45_exit                    ;menu27 = APP1 function 3
              DC.W key45_exit                    ;menu28 = APP2 function 3
              DC.W key45_exit                    ;menu29 = S121 function 3
              DC.W key45_exit                    ;menu30 = S122 function 3
              DC.W key45_exit                    ;menu31 = MODE1 function 3
              DC.W key45_exit                    ;menu32 = MODE2 function 3
              DC.W key45_exit                    ;menu33 = EQN1 function 3 
              DC.W key45_exit                    ;menu34 = EQN2 function 3
              DC.W key45_exit                    ;menu35 = BIN1 function 3 
              DC.W key45_exit                    ;menu36 = BIN2 function 3
                            
key45_exit:   JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 46; MK2 user menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M2:           MOVB #$12,counter1                 ;determines how long the key must be held

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS10 set PTP.1=1 to simulate key released
              ;MOVB #$02,PTP
              ;CLR PTP                            ;otherwise set PTP.1=0 to simulate key held
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key46_loop:   BRSET PTP,#BIT1,key46_cont         ;branch if PTP.1 = 1, i.e. if Key 46 has been released 
              JSR delay
              DEC counter1
              BNE key46_loop
              
              LDAA menu
              BNE key46_exit                     ;exit if not in menu 0 
              
              ;JSR clrComLMem                     
              
              JMP Prg6Db                         ;otherwise debug program PRG2      

key46_cont:   CLRA

              LDAB menu
              ASLB                               

              LDX #MK2Table     

              JMP [D,X]

MK2Table      DC.W PRG6                          ;menu0 = key133 (execute PRG2)
              DC.W CTOR                          ;menu1 = CPLX1 function 2 = complex to real                          
              DC.W PRG6                          ;menu2 = CPLX2 function 2 = PRG2 
              DC.W key46_exit                    ;menu3 = ASM1 function 2
              DC.W key46_exit                    ;menu4 = ASM2 function 2               
              DC.W FLOOR                         ;menu5 = NUM1 function 2 = floor function
              DC.W key46_exit                    ;menu6 = NUM2 function 2 
              DC.W key46_exit                    ;menu7 = POL1 function 2
              DC.W key46_exit                    ;menu8 = POL2 function 2
              DC.W key46_exit                    ;menu9 = CAL1 function 2
              DC.W key46_exit                    ;menu10 = CAL2 function 2
              DC.W key46_exit                    ;menu11 = OPR1 function 2
              DC.W key46_exit                    ;menu12 = OPR2 function 2
              DC.W COSH                          ;menu13 = HYP1 function 2 = cosh x
              DC.W key46_exit                    ;menu14 = HYP2 function 2
              DC.W key46_exit                    ;menu15 = FIN1 function 2
              DC.W key46_exit                    ;menu16 = FIN2 function 2
              DC.W COMBI                         ;menu17 = PRO1 function 2 = nCr
              DC.W key46_exit                    ;menu18 = PRO2 function 2
              DC.W key46_exit                    ;menu19 = STA1 function 2 = ->y(K)
              DC.W key46_exit                    ;menu20 = STA2 function 2
              DC.W key46_exit                    ;menu21 = MAT1 function 2
              DC.W key46_exit                    ;menu22 = MAT2 function 2
              DC.W UNROT                         ;menu23 = STAK1 function 2 = UNROTATE
              DC.W DEL2                          ;menu24 = STAK2 function 2 = DELETE2
              DC.W key46_exit                    ;menu25 = GRPH1 function 2
              DC.W key46_exit                    ;menu26 = GRPH2 function 2
              DC.W key46_exit                    ;menu27 = APP1 function 2
              DC.W key46_exit                    ;menu28 = APP2 function 2
              DC.W TIME                          ;menu29 = SYS1 function 2 = display TIME
              DC.W key46_exit                    ;menu30 = SYS2 function 2
              DC.W key46_exit                    ;menu31 = MODE1 function 2
              DC.W key46_exit                    ;menu32 = MODE2 function 2
              DC.W key46_exit                    ;menu33 = EQN1 function 2 
              DC.W key46_exit                    ;menu34 = EQN2 function 2
              DC.W key46_exit                    ;menu35 = BIN1 function 2 
              DC.W key46_exit                    ;menu36 = BIN2 function 2
                            
key46_exit:   JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 47; MK1 user menu;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M1:           MOVB #$12,counter1                 ;determines how long the key must be held

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS11 set PTP.0=1 to simulate key released
              ;MOVB #$01,PTP
              ;CLR PTP                            ;otherwise set PTP.0=0 to simulate key held
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key47_loop:   BRSET PTP,#BIT0,key47_cont         ;branch if PTP.0 = 1, i.e. if Key 47 has been released 
              JSR delay
              DEC counter1
              BNE key47_loop
              
              LDAA menu
              BNE key47_exit                     ;exit if not in menu 0 
              
              ;JSR clrComLMem                     
              
              JMP Prg6Db                         ;otherwise debug program PRG1      

key47_cont:   CLRA

              LDAB menu
              ASLB                               

              LDX #MK1Table     

              JMP [D,X]

MK1Table      DC.W PRG6                          ;menu0 = key133 (execute PRG1)
              DC.W RTOC                          ;menu1 = CPLX1 function 1 = real to complex                          
              DC.W PRG6                          ;menu2 = CPLX2 function 1 = PRG1  
              DC.W key47_exit                    ;menu3 = ASM1 function 1
              DC.W key47_exit                    ;menu4 = ASM2 function 1              
              DC.W MODX                          ;menu5 = NUM1 function 1 = modulus function
              DC.W LD                            ;menu6 = NUM2 function 1 = ld x
              DC.W key47_exit                    ;menu7 = POL1 function 1
              DC.W key47_exit                    ;menu8 = POL2 function 1
              DC.W key47_exit                    ;menu9 = CAL1 function 1
              DC.W key47_exit                    ;menu10 = CAL2 function 1
              DC.W key47_exit                    ;menu11 = OPR1 function 1
              DC.W key47_exit                    ;menu12 = OPR2 function 1
              DC.W SINH                          ;menu13 = HYP1 function 1 = sinh x
              DC.W key47_exit                    ;menu14 = HYP2 function 1
              DC.W key47_exit                    ;menu15 = FIN1 function 1
              DC.W key47_exit                    ;menu16 = FIN2 function 1
              DC.W PERMU                         ;menu17 = PRO1 function 1 = nPr
              DC.W key47_exit                    ;menu18 = PRO2 function 1
              DC.W TOXK                          ;menu19 = STA1 function 1 = ->x(K)
              DC.W key47_exit                    ;menu20 = STA2 function 1
              DC.W key47_exit                    ;menu21 = MAT1 function 1
              DC.W key47_exit                    ;menu22 = MAT2 function 1
              DC.W ROT                           ;menu23 = STAK1 function 1 = ROTATE
              DC.W DEPTH                         ;menu24 = STAK2 function 1 = DEPTH
              DC.W key47_exit                    ;menu25 = GRPH1 function 1
              DC.W key47_exit                    ;menu26 = GRPH2 function 1
              DC.W key47_exit                    ;menu27 = APP1 function 1
              DC.W key47_exit                    ;menu28 = APP2 function 1
              DC.W MEMO                          ;menu29 = SYS1 function 1 = display stack level 1 memory
              DC.W key47_exit                    ;menu30 = SYS2 function 1
              DC.W key47_exit                    ;menu31 = MODE1 function 1
              DC.W key47_exit                    ;menu32 = MODE2 function 1
              DC.W key47_exit                    ;menu33 = EQN1 function 1 
              DC.W key47_exit                    ;menu34 = EQN2 function 1
              DC.W key47_exit                    ;menu35 = BIN1 function 1 
              DC.W key47_exit                    ;menu36 = BIN2 function 1

key47_exit:   JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key 1S: clear the command line/entire stack;;;;;;

Clea:         LDAA noDigMan         
              BNE key14S_1                       ;clear the command line if it is not empty
              
              MOVW #ms_end,usPointer             ;otherwise clear the stack              
              
              BRA key14S_2
              
key14S_1:     BCLR flag4,#BIT7                   ;clear updtScreen flag 
              
              CALL clrComL                       ;clear the command line and reset Ycoord and Y
              JSR clrComLMem                     ;clear command line memory
                   
key14S_2:     JMP keyHdlr_1                      ;return to scanKey subroutine              
            
;Key 2S: generate random number;;;;;;;;;;;;;;;;;;;

Rand:         LDX #rnSeed

              MOVB #$08,counter1

key180_1:     LDAA 1,X+                          ;push the seed onto the stack 
              PSHA
              
              DEC counter1
              BNE key180_1
              
              DEX
              
              MOVB #$0D,counter1
              
key180_2:     MOVB #$07,counter2                 
              
              ASL 1,X-                           ;shift seed one bit to the left ->
              
key180_3:     ROL 1,X-
              DEC counter2
              BNE key180_3                       ;<-
              
              LDX #rnSeedEnd
              
              DEC counter1
              BNE key180_2                       ;shift seed a total of 13 bits to the left
              
              MOVB #$08,counter1
              
key180_4:     LDAA 0,X                           ;exclusive or seed value with shifted seed value and store result
              EORA 1,SP+                         ;in rnSeed ->
              STAA 1,X- 
              
              DEC counter1
              BNE key180_4                       ;<-
              
              INX
              
              MOVB #$08,counter1

key180_5:     LDAA 1,X+                          ;push the result onto the stack 
              PSHA
              
              DEC counter1
              BNE key180_5
              
              MOVB #$07,counter1
              
key180_6:     LDX #rnSeed    

              MOVB #$07,counter2

              CLC                 
              
              ROR 1,X+                           ;shift seed one bit to the right ->
              
key180_7:     ROR 1,X+
              DEC counter2
              BNE key180_7                       ;<-
              
              DEC counter1
              BNE key180_6                       ;shift seed a total of 7 bits to the right
              
              DEX
              
              MOVB #$08,counter1
              
key180_8:     LDAA 0,X                           ;exclusive or seed value with shifted seed value and store result
              EORA 1,SP+                         ;in rnSeed ->
              STAA 1,X- 
              
              DEC counter1
              BNE key180_8                       ;<-
              
              INX
              
              MOVB #$08,counter1

key180_9:     LDAA 1,X+                          ;push the result onto the stack 
              PSHA
              
              DEC counter1
              BNE key180_9
              
              DEX
              
              MOVB #$11,counter1
              
key180_10:    MOVB #$07,counter2                 
              
              ASL 1,X-                           ;shift seed one bit to the left ->
              
key180_11:    ROL 1,X-
              DEC counter2
              BNE key180_11                      ;<-
              
              LDX #rnSeedEnd
              
              DEC counter1
              BNE key180_10                      ;shift seed a total of 17 bits to the left
              
              MOVB #$08,counter1
              
key180_12:    LDAA 0,X                           ;exclusive or seed value with shifted seed value and store result
              EORA 1,SP+                         ;in rnSeed ->
              STAA 1,X- 
              
              DEC counter1
              BNE key180_12                      ;<-
              
              LDX #rnSeedEnd
              
              LDY #endm_e
              
              MOVB #$06,counter1
              
key180_13:    MOVB 1,X-,1,Y-                     ;copy rnSeed[0:6] (dividend) to m_e 
              DEC counter1
              BNE key180_13
              
              MOVB #$00,0,Y                      ;set MS byte of m_e to 0
              
              LDX #endm_c
              
              MOVB #$06,counter1
              
key180_14:    MOVB #$FF,1,X-                     ;set m_c (divisor) to FF FF FF FF FF FF 
              DEC counter1
              BNE key180_14
              
              MOVB #$00,0,X                      ;set MS byte of m_c to 0
              
              MOVB #$00,e_a                      ;set exponent of FPN_a to 0
              
              CLRA
              LDX #m_d
              MOVB #lenManBBytes,counter1
                                                     
key180_15:    STAA 1,X+                          ;clear m_d ->
              DEC counter1
              BNE key180_15                      ;<- 
              
              MOVB #$07,lenMemBytes              ;lenMemBytes = 7 for copyMem subroutine below
              
              JSR idivFPN                        ;divide m_e_bin by m_c_bin,quotient in m_e,remainder in m_d
              
              JSR BinToBCD2                      ;convert m_e to BCD and store in mantissa of FPN_a
              
              MOVW #m_a,memAddr1
              
              JSR lzMan                          ;determine the number of leading zeros in FPN_a
              
              LDAA noZero
              BEQ key180_19                      ;branch if FPN_a contains 10 significant figures
              CMPA #lenMan
              BNE key180_16                      ;branch if FPN_a <> 0
              BSET flag2,#BIT2                   ;otherwise set zf flag

key180_16:    MOVW #m_d,memAddr1
              MOVW #m_e,memAddr2
              JSR copyMem                        ;the remainder is copied to m_e
              
              MOVW #m_e,memAddr1
              JSR multBin10                      ;10 * remainder becomes the new dividend
              
              CLRA
              LDX #m_d
              MOVB #lenManBBytes,counter1
                            
key180_17:    STAA 1,X+                          ;clear m_d ->
              DEC counter1
              BNE key180_17                      ;<-
              
              JSR idivFPN
              
              DEC e_a                            ;decrement the exponent
                            
              LDX #m_e
              LDAB #lenManBBytes
              DECB
              ABX                                ;X points to LS byte of the quotient m_e
              
              LDAA 0,X
              BEQ key180_18                      ;branch if quotient = 0 (0 =< quotient <= 9)
              BCLR flag2,#BIT2                   ;otherwise clear zf flag
              
key180_18:    STAA keyValue                      ;quotient -> keyValue               
                            
              MOVW #m_a,memAddr1
              JSR multMan10add                   ;shift the mantissa of FPN_a one nibble to the left and add 
                                                 ;keyValue to obtain the next digit of the result
              
              BRSET flag2,#BIT2,key180_16        ;loop if there is no non-zero leading digit
              
              DEC noZero                         ;otherwise decrement noZero              
              BNE key180_16

key180_19:    LDX #m_d
              LDAB #lenManBBytes
              DECB
              ABX                                ;X points to LS byte of remainder m_d
              
              STAB counter1
              
              ASL 1,X-
              
key180_20:    ROL 1,X-
              DEC counter1
              BNE key180_20                      ;remainder m_d multiplied by 2
              
              LDX #m_d
              ABX                                ;X points to LS byte of m_d = 2 * remainder = 2r
              
              LDY #m_c
              ABY                                ;Y points to LS byte of divisor d = m_c
              
              STAB counter1
              
              LDAA 1,X-
              SUBA 1,Y-
                            
key180_21:    LDAA 1,X-
              SBCA 1,Y-
              DEC counter1
              BNE key180_21                      ;2r - d
              
              BCS key180_22                      ;branch if 2r - d < 0 (i.e. r/d < 1/2 -> no round-up)
              JSR incFPN                         ;otherwise increment mantissa of FPN_a first
              
key180_22:    LDX #m_a
              LDAA 0,X
              ANDA #$F0
              BEQ key180_23                      ;branch if the MS nibble of FPN_a = 0
              
              JSR divMan10                       ;otherwise shift the mantissa one nibble to the right              
              INC e_a                            ;increment e_a to maintain equality
              LDAB 0,X
              ANDB #$0F
              STAB 0,X                           ;set the MS nibble of FPN_a to 0  
              CMPA #$05
              BLT key180_23                      ;exit if A < 5
              JSR incFPN                         ;otherwise increment FPN_a before exiting
              
key180_23:    MOVB #$01,lenMemBytes              ;restore lenMemBytes  

              LDD usPointer
              CPD #$2000
              BNE key180_24                      ;branch if the top of the stack has not yet been reached
                            
              JSR resetStack                     ;otherwise copy the current values to the bottom of the stack
                          
              BRA key180_25                                                            
                                                 
key180_24:    SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              
key180_25:    MOVW #m_a,memAddr1
              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a = rnSeed[0:7] in BCD -> FPN_1       

              JMP keyHdlr_1
              
;Key 4S: PICK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Pick:         TST noDigMan
              LBEQ key4S_exit                    ;exit if the command line is empty
              
              JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key4S_1          ;branch if oFlow flag not set
              
              LBRA key4S_exit                    ;otherwise exit      

key4S_1:      MOVW #m_com,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;command line value copied to FPN_a
              
              LDX #m_a
              LDAA 0,X
              ANDA #$F0
              LBNE key4S_exit                    ;exit if FPN_a < 0 
              
              JSR lzMan                          ;determine the number of leading zeros in FPN_a
              LDAA #lenMan          
              CMPA noZero
              LBEQ key4S_exit                    ;exit if FPN_a = 0
              
              JSR tzFPN                          ;eliminate trailing zeros in FPN_a
              
              LDAA e_a                           ;A = exponent of FPN_a after trailing zeros have been eliminated
              
              LBMI key4S_exit                    ;exit if FPN_a is not an integer
              
              JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              
              CLRB                               ;B stores the 10's place digit of the stack depth
              
key4S_2:      SUBA #$0A                          ;subtract 10
              BCS key4S_3                        ;result < 0 -> exit loop and add 10
              INCB                               ;otherwise increment B and repeat
              BRA key4S_2                  
              
key4S_3:      PSHB                               ;10's place digit is pushed onto the stack      

              ADDA #$0A                          ;after adding 10 A is equal to the 1's place digit                          

              CLR e_b                            ;FPN_b = stack depth ->
              
              LDX #m_b                            
              CLRB
              MOVB #$07,counter1             
              
key4S_4:      STAB 1,X+                          ;clear first 7 bytes of mantissa of FPN_b 
              DEC counter1
              BNE key4S_4
              
              PULB
              
              ASLB
              ASLB
              ASLB
              ASLB
              
              ABA                                ;A + B -> A              
                             
              STAA 0,X                           ;<- LS byte of FPN_b is equal to the stack depth in BCD 
              
              JSR cmpFPN_LE                      ;sets le flag if FPN_a <= FPN_b
                          
              BRSET flag5,#BIT1,key4S_5          ;continue if FPN_a <= FPN_b, 
                                                 ;i.e. if command line value <= stack depth
              
              LBRA key4S_exit                    ;otherwise exit            
              
key4S_5:      LDX #m_comEnd                      ;X points to LS byte of mantissa of m_com    

              LDAA 0,X                           ;A = LS byte of mantissa of m_com
              
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F                          ;A = MS nibble of LS byte of mantissa of m_com
              
              ASLA
              TAB                                ;B = 2 * MS nibble
              
              ASLA             
              ASLA                               ;A = 8 * MS nibble
              
              ABA                                ;A + B -> A, i.e. A = 10 * MS nibble
              
              PSHA
              
              LDAB 0,X                           ;B = LS byte of mantissa of m_com
              ANDB #$0F                          ;B = LS nibble of LS byte of mantissa of m_com
              
              PULA
              
              ABA                                ;A + B -> A, i.e. A = pick stack level value in binary
              
              DECA              
              
              LDAB #lenFPNBytes
              MUL                                ;A = 0, B = (pick stack level - 1) * lenFPNBytes              
              ADDD usPointer                     ;D = address of the pick stack level
              
              PSHD
              
              LDX usPointer
              CPX #$2000
              BNE key4S_7                        ;branch if the end of the stack has not been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack 
              LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;increment usPointer              
              
              BRCLR flag4,#BIT1,key4S_6          ;branch if not in complex mode
              
              JSR resetStackImag                 ;otherwise copy the current imaginary values to the bottom of the 
                                                 ;user stack                                                  
              BRA key4S_7
              
key4S_6:      BRCLR flag4,#BIT2,key4S_7          ;branch if not in exact mode
              
              JSR resetStackDenom                ;otherwise copy the current denominator values to the bottom of the 
                                                 ;user stack                  
key4S_7:      LDD usPointer
              SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              
              TFR D,Y

              PULX                               ;X = address of the pick stack level
              PSHX
                                 
              ;copy FPN to FPN_1 
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X
              STAA 0,Y              
              ;<-
              
              BRSET flag4,#BIT1,key4S_8          ;branch if in complex mode
              
              BRA key4S_9
              
key4S_8:      LDD usPointer
              ADDD #$1301
              TFR D,Y                            ;Y is pointing to FPN_1_imaginary
              
              PULD
              ADDD #$1301
              TFR D,X     

              ;copy FPN_imaginary to FPN_1_imaginary
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X
              STAA 0,Y       
              ;<-
              
              BRA key4S_11
              
key4S_9:      BRSET flag4,#BIT2,key4S_10         ;branch if in exact mode

              INS
              INS
              
              BRA key4S_11 

key4S_10:     LDD usPointer
              ADDD #$13B5
              TFR D,Y                            ;Y is pointing to FPN_1_denominator
              
              PULD
              ADDD #$13B5
              TFR D,X      

              ;copy FPN_denominator to FPN_1_denominator
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X
              STAA 0,Y       
              ;<-
              
key4S_11:     JSR clrComLMem
              
key4S_exit:   JMP keyHdlr_1                      ;return to scanKey subroutine
 
;Key 10S: SWAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Swapp:        LDX usPointer
              CPX #ms_end
              LBEQ key10S_exit                   ;exit as stack is empty
              CPX #us_start
              LBEQ key10S_exit                   ;exit as stack depth = 1
               
              ;push FPN_1 onto the stack ->
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+                          ;X is now pointing to FPN_2
              PSHA
              ;<-
               
              LDY usPointer
              
              ;copy FPN_2 to FPN_1 ->
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X                           ;X is now pointing to FPN_2_exponent
              STAA 0,Y                          
              ;<-
               
              ;copy FPN_1 to FPN_2 ->
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 0,X                           ;X is now pointing to FPN_2
              ;<-
               
              BRCLR flag4,#BIT1,key10S_1         ;branch if not in complex mode
              
              ;push FPN_1_imaginary onto the stack ->
              TFR X,D
              ADDD #$12F8                        
              TFR D,X                            ;X is now pointing to FPN_1_imaginary
              
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+                          ;X is now pointing to FPN_2_imaginary
              PSHA
              ;<-
              
              TFR Y,D
              ADDD #$12F9                        
              TFR D,Y                            ;Y is now pointing to FPN_1_imaginary
              
              ;copy FPN_2_imaginary to FPN_1_imaginary ->
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X                           ;X is now pointing to FPN_2_imaginary_exponent
              STAA 0,Y                           
              
              ;copy FPN_1_imaginary to FPN_2_imaginary ->
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 0,X                           ;X is now pointing to FPN_2_imaginary
              ;<-
              
              BRA key10S_exit
               
key10S_1:     BRCLR flag4,#BIT2,key10S_exit      ;exit if not in exact mode

              ;push FPN_1_denominator onto the stack ->
              TFR X,D
              ADDD #$13AC                       
              TFR D,X                            ;X is now pointing to FPN_1_denominator
              
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+                          ;X is now pointing to FPN_2_denominator
              PSHA
              ;<-
              
              TFR Y,D
              ADDD #$13AD                        
              TFR D,Y                            ;Y is now pointing to FPN_1_denominator
              
              ;copy FPN_2_denominator to FPN_1_denominator ->
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X                           ;X is now pointing to FPN_2_denominator_exponent
              STAA 0,Y                           
              
              ;copy FPN_1_denominator to FPN_2_denominator ->
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 0,X                           ;X is now pointing to FPN_2_denominator
              ;<-

key10S_exit:  JSR clrComLMem	

              JMP keyHdlr_1                      ;return to scanKey subroutine
            

;Key 12S; RCL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RECL:         BCLR flag4,#BIT7                   ;clear update screen flag         

              LDX #Rcl                          
              MOVB #$12,colNumber
              CALL dispStatLI                    ;display "Rcl" in the status line
              
              BSET flag3,#BIT1                   ;set the rcl flag

			        JMP keyHdlr_1                      ;return to scanKey subroutine
			        
;Key 15S; DMS to decimal function;;;;;;;;;;;;;;;;;

DMSD:         LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX     

              LDX #DMSToPrg
              DEX
              STX prgCounter                     ;prgCounter = DMSToPrg - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1

;Key 18S; STO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

STO:          BCLR flag4,#BIT7                   ;clear update screen flag         

              LDX #Sto                          
              MOVB #$12,colNumber
              CALL dispStatLI                    ;display "STO" in the status line
              
              BSET flag3,#BIT4                   ;set the sto flag        

              JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 21S; decimal to DMS function;;;;;;;;;;;;;;;;;

DDMS:         LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX     

              LDX #ToDMSPrg
              DEX
              STX prgCounter                     ;prgCounter = ToDMSPrg - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1   				  
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key48:        BCLR flag4,#BIT7                   ;clear updtScreen flag 

              JMP keyHdlr_1                      ;return to scanKey subroutine

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key54:        BCLR flag4,#BIT7                   ;clear updtScreen flag 

              JMP keyHdlr_1                      ;return to scanKey subroutine

;undo SHIFT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

UShift:       BCLR flag4,#BIT7                   ;clear updtScreen flag 

              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key48Prg:     ;BCLR flag4,#BIT6                   ;clear updtPrgScreen flag 

              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key54Prg:     ;BCLR flag4,#BIT6                   ;clear updtPrgScreen flag 

              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

UShiftPrg:    JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 24S; log x;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LOGX:         LDAA noDigMan
              BNE key6S_1                        ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key6S_5                        ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key6S_7                       ;exit as the command line and stack are both empty
              
key6S_1:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key6S_2          ;branch if oFlow flag was not set
              
              LBRA key6S_6                       ;otherwise display "ERROR" on the status line and exit       

key6S_2:      LDD usPointer
              CPD #$2000
              BNE key6S_3                        ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key6S_4                         
                                                  
key6S_3:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key6S_4:      MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack      
              
key6S_5:      MOVW usPointer,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_1
              
              LDX usPointer
              LDAA 0,X                           ;A = MS byte of FPN_1
              ANDA #$F0
              LBNE key6S_6                       ;display "ERROR" on the status line and exit if FPN_1 < 0

              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              BEQ key6S_6                        ;display "ERROR" on the status line and exit if FPN_1 = 0
              
              MOVW #m_f,memAddr1              
              JSR tzFPN_f                        ;eliminate trailing zeros in FPN_f = FPN_1
              LDX #m_fEnd                                  
              LDAA 1,X+                          ;A = LS byte of FPN_f
              DECA
              BNE key6S_5_1                      ;branch if A <> 1
              LDAA 0,X
              BNE key6S_5_1                      ;branch if A <> 0
              
              LDX usPointer                      ;otherwise FPN_f = 1, so set FPN_1 to 0 and exit
              
              MOVB #lenFPNBytes,counter1
              
key6S_5_0:    CLR 1,X+                           ;set FPN_1 = 0 ->
              DEC counter1
              BNE key6S_5_0                      ;<-
              
              BRA key6S_7                        ;exit
              
key6S_5_1:    MOVW #log10Values,logValues        ;store address of special values used in logFPN2 subroutine
              
              JSR lzMan
              LDAB noZero                        ;require B = noZero in FPN_f before calling logFPN2 subroutine
              
              JSR logFPN2                        ;find the base 10 logarithm of FPN_f and store in FPN_a

              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key6S_7 

key6S_6:      BRCLR flag2,#BIT7,key6S_6_1        ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer first 
              ADDD #lenFPNBytes
              STD usPointer            

key6S_6_1:    JSR dispError                      ;display "ERROR" on the status line and exit
  
key6S_7:      JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine               

;Key 25S; ln x;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LNX:          LDAA noDigMan
              BNE key5S_1                        ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key5S_5                        ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key5S_7                       ;exit as the command line and stack are both empty
              
key5S_1:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key5S_2          ;branch if oFlow flag was not set
              
              LBRA key5S_6                       ;otherwise display "ERROR" on the status line and exit       

key5S_2:      LDD usPointer
              CPD #$2000
              BNE key5S_3                        ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key5S_4                         
                                                  
key5S_3:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key5S_4:      MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack      
              
key5S_5:      MOVW usPointer,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_1
             
              LDX usPointer
              LDAA 0,X                           ;A = MS byte of FPN_1
              ANDA #$F0
              LBNE key5S_6                       ;display "ERROR" on the status line and exit if FPN_1 < 0

              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              BEQ key5S_6                        ;display "ERROR" on the status line and exit if FPN_1 = 0
              
              MOVW #m_f,memAddr1              
              JSR tzFPN_f                        ;eliminate trailing zeros in FPN_f = FPN_1
              LDX #m_fEnd                      
              LDAA 1,X+                          ;A = LS byte of FPN_f
              DECA
              BNE key5S_5_1                      ;branch if A <> 1
              LDAA 0,X
              BNE key5S_5_1                      ;branch if A <> 0
              
              LDX usPointer                      ;otherwise FPN_f = 1, so set FPN_1 to 0 and exit
              
              MOVB #lenFPNBytes,counter1
              
key5S_5_0:    CLR 1,X+                           ;set FPN_1 = 0 ->
              DEC counter1
              BNE key5S_5_0                      ;<-               
             
              BRA key5S_7                        ;exit
              
key5S_5_1:    MOVW #logEValues,logValues         ;store address of special ln values used in logFPN subroutine
              MOVW #logETen,logbTen            
              
              JSR lzMan
              LDAB noZero                        ;require B = noZero in FPN_f before calling logFPN subroutine
              
              JSR logFPN                         ;find the logarithm of FPN_f and store in FPN_a

              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key5S_7 

key5S_6:      BRCLR flag2,#BIT7,key5S_6_1        ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer first 
              ADDD #lenFPNBytes
              STD usPointer            

key5S_6_1:    JSR dispError                      ;display "ERROR" on the status line and exit
  
key5S_7:      JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine              				  
        
;Key 26S; DRG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DRG:          CALL key129SUB                     ;toggle degree/radian/gradian angle measure

              JSR clrComLMem

              JMP keyHdlr_1
              
;Key 27S; arctan;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ATAN:         LDAA noDigMan
              BNE key9T_1                        ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key9T_5                        ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key9T_7                       ;exit as the command line and stack are both empty
              
key9T_1:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key9T_2          ;branch if oFlow flag was not set
              
              LBRA key9T_6                       ;otherwise display "ERROR" on the status line and exit       

key9T_2:      LDD usPointer
              CPD #$2000
              BNE key9T_3                        ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key9T_4                         
                                                  
key9T_3:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key9T_4:      MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack
              
key9T_5:      MOVW usPointer,memAddr1
              MOVW #m_h,memAddr2
              JSR copyFPN                        ;FPN_h = FPN_1 = Y
              
              LDX #m_h
              LDAA 0,X
              ANDA #$F0
              BEQ key9T_5_0                      ;branch if Y >= 0
              
              MOVW #m_h,memAddr1                 ;otherwise negate Y and set the manNeg flag 
              JSR negFPN
              BSET flag2,#BIT4                       

key9T_5_0:    JSR arctanFPN                      ;determine theta such that tan of theta = FPN_1 
                                                 ;FPN_f = theta
                                                 
              MOVW #m_f,memAddr1
                                                 
              BRCLR flag2,#BIT4,key9T_5_1        ;branch if Y was non-negative
                        
              JSR negFPN                         ;otherwise negate theta first

key9T_5_1:    BRCLR flag4,#BIT4,key9T_5_6        ;branch if not in radian mode

              LBRA key9T_5_3

key9T_5_6:    BRSET flag1,#BIT6,key9T_5_4        ;branch if in gradian mode

              MOVW #m_f,memAddr1                 ;otherwise in decimal mode
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_f -> FPN_a

              LDX #m_b

              MOVB #$05,1,X+                     ;FPN_b = 180/pi
              MOVB #$72,1,X+
              MOVB #$95,1,X+
              MOVB #$77,1,X+
              MOVB #$95,1,X+
              MOVB #$13,1,X+
              MOVB #$08,1,X+
              MOVB #$24,1,X+
              
              MOVB #$F3,0,X
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a, i.e. FPN_a converted to degrees
              
              ;MOVW #m_a,memAddr1
              
              BRCLR flag2,#BIT4,key9T_5_2        ;branch if product should be non-negative
                                                                                           
              JSR negFPN                         ;otherwise negate it first             
                  
key9T_5_2:    MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key9T_7
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key9T_5_4:    MOVW #m_f,memAddr1                 
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_f -> FPN_a

              LDX #m_b

              MOVB #$06,1,X+                     ;FPN_b = 200/pi
              MOVB #$36,1,X+
              MOVB #$61,1,X+
              MOVB #$97,1,X+
              MOVB #$72,1,X+
              MOVB #$36,1,X+
              MOVB #$75,1,X+
              MOVB #$82,1,X+
              
              MOVB #$F3,0,X
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a, i.e. FPN_a converted to gradians
              
              ;MOVW #m_a,memAddr1
              
              BRCLR flag2,#BIT4,key9T_5_5        ;branch if product should be non-negative
                                                                                           
              JSR negFPN                         ;otherwise negate it first             
                  
key9T_5_5:    MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key9T_7 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                 
              
key9T_5_3:    MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_f -> FPN_1
                            
              BRA key9T_7 

key9T_6:      BRCLR flag2,#BIT7,key9T_6_1        ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key9T_6_1:    JSR dispError                      ;display "ERROR" on the status line
  
key9T_7:      JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine 

;Key 28S; arccos;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ACOS:         LDAA noDigMan
              BNE key10T_1                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key10T_5                       ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key10T_7                      ;exit as the command line and stack are both empty
              
key10T_1:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key10T_2         ;branch if oFlow flag was not set
              
              LBRA key10T_6                      ;otherwise display "ERROR" on the status line and exit       

key10T_2:     LDD usPointer
              CPD #$2000
              BNE key10T_3                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key10T_4                         
                                                  
key10T_3:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key10T_4:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack
              
key10T_5:     MOVW usPointer,memAddr1
              MOVW #m_h,memAddr2
              JSR copyFPN                        ;FPN_h = FPN_1 
              
              MOVW #m_h,memAddr1
              
              LDX #m_h
              LDAA 0,X
              ANDA #$F0
              PSHA                               ;push the sign of FPN_h = FPN_1 onto the stack
              BEQ key10T_5_0                     ;branch if FPN_h = FPN_1 >= 0
                                             
              JSR negFPN                         ;otherwise negate FPN_h             
              
key10T_5_0:   MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = FPN_h = FPN_1
              
              MOVB #$07,counter1
              LDX #m_a
              
              CLRA
              
key10T_5_0_0: STAA 1,X+                          ;FPN_a = 1 ->
              DEC counter1
              BNE key10T_5_0_0
              
              MOVB #$01,1,X+                     
              
              CLR 0,X                            ;<-
              
              JSR cmpFPN_GE                      ;sets ge flag if FPN_a >= FPN_b
                                                 ;i.e. if 1 >= FPN_h = FPN_1 
              
              BRSET flag5,#BIT0,key10T_5_0_1     ;branch if ge flag set, i.e. if FPN_h = FPN_1 <= 1
              
              INS                                ;otherwise increment the stack due to the "PSHA" instruction above          
              LBRA key10T_6                      ;and display "ERROR" 
              
key10T_5_0_1: JSR arccosFPN                      ;determine theta such that cos of theta = FPN_h = FPN_1 
                                                 ;FPN_f = theta
              MOVW #m_f,memAddr1
                                                 
              PULA
              TSTA
              BEQ key10T_5_1                     ;branch if FPN_1 was non-negative
                        
              JSR negFPN                         ;otherwise set FPN_f = pi - theta ->
              
              MOVW #m_f,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b  = -theta
              
              LDX #m_a                           ;m_a = pi               
              MOVB #$03,1,X+
              MOVB #$14,1,X+
              MOVB #$15,1,X+
              MOVB #$92,1,X+
              MOVB #$65,1,X+
              MOVB #$35,1,X+
              MOVB #$89,1,X+
              MOVB #$79,1,X+                     ;m_a = 0314159265358979                                                 
              MOVB #$F2,0,X                      ;e_a = F2
              
              JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b 
              
              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a, i.e. pi - theta -> FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f  = pi - theta <-
              
key10T_5_1:   BRCLR flag4,#BIT4,key10T_5_6       ;branch if not in radian mode

              LBRA key10T_5_3

key10T_5_6:   BRSET flag1,#BIT6,key10T_5_4       ;branch if in gradian mode
              
              MOVW #m_f,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_f -> FPN_a

              LDX #m_b

              MOVB #$05,1,X+                     ;FPN_b = 180/pi
              MOVB #$72,1,X+
              MOVB #$95,1,X+
              MOVB #$77,1,X+
              MOVB #$95,1,X+
              MOVB #$13,1,X+
              MOVB #$08,1,X+
              MOVB #$24,1,X+
              
              MOVB #$F3,0,X
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a, i.e. FPN_a converted to degrees
              
key10T_5_2:   MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key10T_7
              
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key10T_5_4:   MOVW #m_f,memAddr1                 
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_f -> FPN_a

              LDX #m_b

              MOVB #$06,1,X+                     ;FPN_b = 200/pi
              MOVB #$36,1,X+
              MOVB #$61,1,X+
              MOVB #$97,1,X+
              MOVB #$72,1,X+
              MOVB #$36,1,X+
              MOVB #$75,1,X+
              MOVB #$82,1,X+
              
              MOVB #$F3,0,X
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a, i.e. FPN_a converted to gradians
              
              ;MOVW #m_a,memAddr1
              
              BRCLR flag2,#BIT4,key10T_5_5       ;branch if product should be non-negative
                                                                                           
              JSR negFPN                         ;otherwise negate it first             
                  
key10T_5_5:   MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key10T_7 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key10T_5_3:   MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_f -> FPN_1
              
              BRA key10T_7 
              
key10T_6:     BRCLR flag2,#BIT7,key10T_6_1       ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key10T_6_1:   JSR dispError                      ;display "ERROR" on the status line
              
key10T_7:     JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine				  
        
;Key 29S; arcsin;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASIN:         LDAA noDigMan
              BNE key11T_1                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key11T_5                       ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key11T_7                      ;exit as the command line and stack are both empty
              
key11T_1:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key11T_2         ;branch if oFlow flag was not set
              
              LBRA key11T_6                      ;otherwise display "ERROR" on the status line and exit       

key11T_2:     LDD usPointer
              CPD #$2000
              BNE key11T_3                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key11T_4                         
                                                  
key11T_3:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key11T_4:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack
              
key11T_5:     MOVW usPointer,memAddr1
              MOVW #m_h,memAddr2
              JSR copyFPN                        ;FPN_h = FPN_1 
              
              MOVW #m_h,memAddr1
              
              LDX #m_h
              LDAA 0,X
              ANDA #$F0
              PSHA                               ;push the sign of FPN_h = FPN_1 onto the stack
              BEQ key11T_5_0                     ;branch if FPN_h = FPN_1 >= 0
                                             
              JSR negFPN                         ;otherwise negate FPN_h
              
key11T_5_0:   MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = FPN_h = FPN_1
              
              MOVB #$07,counter1
              LDX #m_a
              
              CLRA
              
key11T_5_0_0: STAA 1,X+                          ;FPN_a = 1 ->
              DEC counter1
              BNE key11T_5_0_0
              
              MOVB #$01,1,X+                     
              
              CLR 0,X                            ;<-
              
              JSR cmpFPN_GE                      ;sets ge flag if FPN_a >= FPN_b
                                                 ;i.e. if 1 >= FPN_h = FPN_1 
              
              BRSET flag5,#BIT0,key11T_5_0_1     ;branch if ge flag set, i.e. if FPN_h = FPN_1 <= 1
         
              INS                                ;otherwise increment the stack due to the "PSHA" instruction above          
              LBRA key11T_6                      ;and display "ERROR"  
              
key11T_5_0_1: JSR arccosFPN                      ;determine theta such that cos of theta = FPN_h = FPN_1 
                                                 ;FPN_f = theta
              MOVW #m_f,memAddr1
                                                 
              PULA
              TSTA
              BEQ key11T_5_1                     ;branch if FPN_1 was non-negative             
                        
              JSR negFPN                         ;otherwise set FPN_f = pi - theta ->
              
              MOVW #m_f,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b  = -theta
              
              LDX #m_a                           ;m_a = pi               
              MOVB #$03,1,X+
              MOVB #$14,1,X+
              MOVB #$15,1,X+
              MOVB #$92,1,X+
              MOVB #$65,1,X+
              MOVB #$35,1,X+
              MOVB #$89,1,X+
              MOVB #$79,1,X+                     ;m_a = 0314159265358979                                                 
              MOVB #$F2,0,X                      ;e_a = F2
              
              JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b 
              
              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a, i.e. pi - theta -> FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f  = pi - theta <-
              
key11T_5_1:   LDX #m_a                           ;m_a = pi/2               
              MOVB #$01,1,X+
              MOVB #$57,1,X+
              MOVB #$07,1,X+
              MOVB #$96,1,X+
              MOVB #$32,1,X+
              MOVB #$67,1,X+
              MOVB #$94,1,X+
              MOVB #$90,1,X+                     ;m_a = 0157079632679490                                                 
              MOVB #$F2,0,X                      ;e_a = F2
              
              MOVW #m_f,memAddr1
              JSR negFPN                         ;FPN_f = -theta
              
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b  = -theta
              
              JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b 
              
              JSR addFPN                         ;FPN_a + FPN_b -> FPN_a, i.e. pi/2 - theta -> FPN_a
              
              MOVW #m_a,memAddr1
              
              BRSET flag4,#BIT4,key11T_5_2       ;branch if in radian mode
              
              BRSET flag1,#BIT6,key11T_5_3       ;branch if in gradian mode               

              LDX #m_b                           ;FPN_b = 180/pi 
              MOVB #$05,1,X+                     
              MOVB #$72,1,X+
              MOVB #$95,1,X+
              MOVB #$77,1,X+
              MOVB #$95,1,X+
              MOVB #$13,1,X+
              MOVB #$08,1,X+
              MOVB #$24,1,X+              
              MOVB #$F3,0,X
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a, i.e. FPN_a converted to degrees
              
              BRCLR flag2,#BIT4,key11T_5_2       ;branch if product should be non-negative
                                                                                           
              JSR negFPN                         ;otherwise negate it first
              
              BRA key11T_5_2 
              
key11T_5_3:   LDX #m_b                           ;FPN_b = 200/pi 
              MOVB #$06,1,X+                     
              MOVB #$36,1,X+
              MOVB #$61,1,X+
              MOVB #$97,1,X+
              MOVB #$72,1,X+
              MOVB #$36,1,X+
              MOVB #$75,1,X+
              MOVB #$82,1,X+              
              MOVB #$F3,0,X
              
              JSR multFPN                        ;FPN_a * FPN_b -> FPN_a, i.e. FPN_a converted to gradians
              
              BRCLR flag2,#BIT4,key11T_5_2       ;branch if product should be non-negative
              
              JSR negFPN                         ;otherwise negate it first
              
key11T_5_2:   MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key11T_7             

key11T_6:     BRCLR flag2,#BIT7,key11T_6_1       ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key11T_6_1:   JSR dispError                      ;display "ERROR" on the status line
              
key11T_7:     JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine 

;Key 30S: factorial;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FACT:       LDAA noDigMan
              BNE key9S_0                        ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key9S_0_4                      ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              JMP keyHdlr_1                      ;exit as the command line and stack are both empty
              
key9S_0:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key9S_0_1        ;branch if oFlow flag was not set
              
              LBRA key9S_1_3                     ;otherwise display "ERROR" on the status line and exit 
              
key9S_0_1:    LDD usPointer
              CPD #$2000
              BNE key9S_0_2                      ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key9S_0_3                          
                                                  
key9S_0_2:    SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key9S_0_3:    MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack               
              
key9S_0_4:    MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1             
                            
              CLR e_b                            ;FPN_b = 70 ->
              
              LDX #m_b                            
              CLRA
              MOVB #lenManBytes,counter1
              DEC counter1
              
key9S_0_4_1:  STAA 1,X+                          ;clear first (lenManBytes - 1) bytes of mantissa of FPN_b 
              DEC counter1
              BNE key9S_0_4_1
              
              MOVB #$70,0,X                      ;LS byte of FPN_b = 70 <-
              
              MOVW #m_a,memAddr1
              
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key9S_0_4_3                    ;continue if FPN_1 <> 0
              
key9S_0_4_2:  LDX #e_b                           ;otherwise...
              DEX                                ;X points to LS byte of mantissa of FPN_b
              
              LDAA #$01
              STAA 0,X                           ;FPN_b = 1
              
              MOVW #m_b,memAddr1
              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_b -> FPN_1
              
              LBRA key9S_5                       ;update the user stack and exit 
              
key9S_0_4_3:  JSR tzFPN                          ;eliminate any trailing zeros for integer test below
              
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_a after trailing zeros eliminated
              
              LDAA e_a
              BPL key9S_0_5                      ;branch if exponent >= 0, i.e. if FPN_1 is an integer
              
              BRA key9S_1_3                      ;otherwise display "ERROR" on the status line and exit  

key9S_0_5:    LDX usPointer
              LDAA 0,X                           ;A = MS byte of FPN_1
              ANDA #$F0
              BEQ key9S_1_1                      ;continue if FPN_1 > 0
              
              BRA key9S_1_3                      ;otherwise display "ERROR" on the status line and exit 
              
key9S_1_1:    LDX #m_aEnd                        
              LDAA 1,X+                          ;A = LS byte of FPN_a
              DECA
              BNE key9S_1_1_1                    ;branch if A <> 1, i.e. if FPN_a <> 1
              LDAA 0,X
              BNE key9S_1_1_1                    ;branch if A <> 0, i.e. if FPN_a <> 1 
              
              BRA key9S_0_4_2                    ;otherwise FPN_a = 1, so set FPN_1 to 1 and exit   

key9S_1_1_1:  JSR cmpFPN_GE                      ;sets ge flag if FPN_a >= FPN_b
                                                 ;i.e. if FPN_1 >= 70 
              
              BRCLR flag5,#BIT0,key9S_1_5        ;branch if ge flag not set, i.e. if FPN_1 <= 69
              
key9S_1_3:    BRCLR flag2,#BIT7,key9S_1_4        ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key9S_1_4:    JSR dispError                      ;display "ERROR" on the status line and exit  
              JMP keyHdlr_1                      ;return to scanKey subroutine
                      
key9S_1_5:    LDX #m_d                           ;clear m_d ->
              MOVB #$07,counter1
              CLRA
              
key9S_1_5_1:  STAA 1,X+
              DEC counter1
              BNE key9S_1_5_1                    ;<-   

              MOVB #lenManBBytes,lenMemBytes     ;lenMemBytes = lenManBBytes for BCDToBin subroutine
              
              MOVW #m_f,memAddr1
             
              TST e_f
              BEQ key9S_1_5_3                    ;branch if e_f = 0 (FPN_f is in integer form)
              
key9S_1_5_2:  JSR multMan10                      ;multiply FPN_f by 10
              DEC e_f                            ;decrement e_f to maintain equality
              BNE key9S_1_5_2                    ;repeat until e_f = 0 (FPN_f is in integer form)
              
key9S_1_5_3:  MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2 

              JSR BCDToBin                       ;converts the mantissa of FPN_M2 to binary and stores the result in 
                                                 ;FPN_M1, i.e. FPN_f is converted to binary and the result stored in 
                                                 ;FPN_a
              LDX #m_a
              LDAB #lenManBBytes
              DECB
              ABX                                ;X points to 7th byte of mantissa of FPN_a
              
              LDAA 0,X                           ;2 =< A = FPN_1 <= 69
              
              CLRB
              PSHB                               ;index pushed onto the stack
              
              LDAB #$41                          ;B = 65
              
key9S_1_6:    CBA                                ;compare accumulators (A - B)
              BPL key9S_1_7                      ;branch if FPN_1 >= B
              
              SUBB #$05                          ;otherwise subtract 5 from B and push the result onto the stack
              PSHB
              
              INS                                ;increment the index ->
              LDAB 0,SP
              INCB
              STAB 0,SP
              DES                                ;<-
              
              PULB                               ;restore B and compare again 
              BRA key9S_1_6 
              
key9S_1_7:    SBA                                ;A - B -> A
              LBEQ key9S_4_5                     ;branch if A = B
              
              DECA
              BEQ key9S_4_3                      ;branch if A = B + 1
              
              STAA counter3                      ;otherwise counter3 = A - B - 1
              
              MOVB #$07,counter4                 ;FPN_a -> m_c ->
              
              LDX #m_a
              LDY #m_c
                            
key9S_2:      MOVB 1,X+,1,Y+
              
              DEC counter4
              BNE key9S_2                        ;<- 
              
key9S_3:      LDX #m_aEnd                        ;decrement FPN_a ->
              DEX
              LDAA 0,X
              DECA
              STAA 0,X                           ;<-
              
              MOVB #$07,counter4                 ;FPN_a -> m_e ->
              
              LDX #m_a
              LDY #m_e
                            
key9S_4:      MOVB 1,X+,1,Y+
              
              DEC counter4
              BNE key9S_4                        ;<-
              
              JSR shftAdd                        ;multiply m_c with m_e, result is 13-byte
                                                 ;binary value with the LS byte at the end of m_e
              
              MOVB #$07,counter4                 ;m_e -> m_c ->
              
              LDX #m_e
              LDY #m_c
                            
key9S_4_1:    MOVB 1,X+,1,Y+
              
              DEC counter4
              BNE key9S_4_1                      ;<- 
              
              DEC counter3
              BNE key9S_3               
              
key9S_4_1_1:  LDX #Fact
	            PULB                               ;B  = index
              ASLB
              LDX B,X                            ;X points to n!
              
              MOVB #$07,counter4                 ;mantissa of n! -> m_e ->
              
              LDY #m_e
                            
key9S_4_2:    MOVB 1,X+,1,Y+
              
              DEC counter4
              BNE key9S_4_2                      ;<-
              
              MOVB 0,X,e_a                       ;exponent of n! to e_a
              
              JSR shftAdd                        ;multiply m_c with m_e, result is 13-byte
                                                 ;binary value with the LS byte at the end of m_e
                                                               
              JSR BinToBCD                       ;convert the 13-byte binary product to BCD
              
              JSR shFPN30dig                     ;set the 30-digit BCD result to an equivalent 15-digit result and 
                                                 ;copy to m_a                                                 
              BRA key9S_4_7
                               
key9S_4_3:    MOVB #$07,counter4                 ;FPN_a -> m_c (case FPN_a = B + 1) ->
              
              LDX #m_a
              LDY #m_c
                            
key9S_4_4:    MOVB 1,X+,1,Y+
              
              DEC counter4
              BNE key9S_4_4                      ;<-
              
              BRA key9S_4_1_1
              
key9S_4_5:    LDX #m_c                           ;case FPN_a = B
              
              MOVB #$06,counter4
              
              CLRA                               ;set m_c = 1              
key9S_4_6:    STAA 1,X+
              DEC counter4
              BNE key9S_4_6
              
              MOVB #$01,0,X     

              BRA key9S_4_1_1
              
key9S_4_7:    MOVW #m_a,memAddr1
              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_1 = FPN_a
                              
              MOVB #lenExpBytes,lenMemBytes      ;lenMemBytes = lenExpBytes to update value of exponent when entering
                                                 ;values on the command line after the multiplication is performed                                  
              
key9S_5:      JSR clrComLMem                     ;clear command line memory 
              JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 31S; y^(1/x), x on level 2, y on level 1;;;;;

XPOY:         TST noDigMan
              BEQ key31S_5                       ;branch if the command line is empty
              
              JSR calcDpt                        ;otherwise calculate the depth of the user stack and store it in A
              TSTA
              BNE key31S_1
              BCLR flag4,#BIT7                   ;clear updtScreen flag
              JMP keyHdlr_1                      ;exit as the user stack depth = 0         
              
key31S_1:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key31S_2         ;branch if oFlow flag was not set
              
              LBRA key31S_25                     ;otherwise display "ERROR" on the status line and exit
              
key31S_2:     LDD usPointer
              CPD #$2000
              BNE key31S_3                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack
              BRA key31S_4                                   
                                                  
key31S_3:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key31S_4:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2              
              JSR copyFPN                        ;command line value copied to the user stack  
               
              BRA key31S_6                       
              
key31S_5:     JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key31S_6                       ;continue if the depth is greater than 1
              BCLR flag4,#BIT7                   ;otherwise clear updtScreen flag
              JMP keyHdlr_1                      ;return to scanKey subroutine as the user stack depth = 0 or 1
                                                 ;and the command line is empty
              
key31S_6:     MOVW usPointer,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;m_f = x = FPN_1
              
              LDD usPointer
              ADDD #lenFPNBytes
              STD memAddr1                       ;memAddr1 = usPointer + 9
              
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;m_b = y = FPN_2
              
              MOVW #m_i,memAddr2
              JSR copyFPN                        ;m_i = y = FPN_2 (required since logFPN subroutine alters FPN_b)
              
              LDX #m_f
              LDAA 0,X                           ;A = MS byte of x
              ANDA #$F0
              LBNE key31S_10                     ;branch if x < 0
              
              BCLR flag3,#BIT0                   ;clear gFlag0 as result will be non-negative  
              
              MOVW #m_f,memAddr1
              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              LBNE key31S_21                     ;branch if x <> 0 (x > 0)
              
              MOVW #m_b,memAddr1
              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              BNE key31S_7                       ;branch if y <> 0
              
              LBRA key31S_24                     ;display "ERROR" on the status line and exit since x = y = 0                       
               
key31S_7:     LDX #m_b
              LDAA 0,X                           ;A = MS byte of y
              ANDA #$F0
              BEQ key31S_8                       ;branch if y > 0
              
              LBRA key31S_24                     ;display "ERROR" on the status line and exit since x = 0 & y < 0    

key31S_8:     LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;usPointer is incremented
                            
              LDX usPointer
              
              MOVB #lenFPNBytes,counter1
              
key31S_9:     CLR 1,X+                           ;set FPN_1 = 0 since x = 0 and y > 0 ->
              DEC counter1
              BNE key31S_9                       ;<-
            
              LBRA key31S_26                     ;exit
              
key31S_10:    MOVW #m_f,memAddr1
              JSR negFPN                         ;FPN_f = |x|

              MOVW #m_b,memAddr1
              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              BNE key31S_11                      ;branch if y <> 0
                            
              LBRA key31S_24                     ;display "ERROR" on the status line and exit since x < 0 & y = 0
                
key31S_11:    JSR tzFPN_b                        ;eliminate trailing zeros in FPN_b = y
              
              LDAA e_b                           ;A = exponent of y after trailing zeros have been eliminated
              
              LBPL key31S_19                     ;branch if e_b >= 0, i.e. if y is an integer
              
              CLRA                               ;set FPN_a = 1 ->
              LDX #m_a
              MOVB #lenManBytes,counter1
              DEC counter1
                                                 
key31S_12:    STAA 1,X+                          ;clear (lenManBytes - 1) bytes of m_a
              DEC counter1
              BNE key31S_12
              
              MOVB #$01,1,X+                     ;set LS byte of mantissa of FPN_a to 1
              
              CLR 0,X                            ;clear e_a <-                    

              JSR divFPN                         ;FPN_a/FPN_b = 1/y = z -> FPN_a
              
              BRCLR flag2,#BIT4,key31S_12_1      ;branch if z should be positive 
              JSR negFPN                         ;otherwise negate it first
              
key31S_12_1:  JSR chkOFPN                        ;overflow not possible,but this subroutine must be called before
                                                 ;chkUFPN
                                                 
              JSR chkUFPN                        ;check FPN_M1 = FPN_a for underflow (FPN_a set to 0 if underflow)
              
              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              BNE key31S_14                      ;branch if z <> 0
              
              LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;usPointer is incremented
                            
              LDX usPointer
              
              MOVB #lenManBytes,counter1
              DEC counter1
              
key31S_13:    CLR 1,X+                           ;set FPN_1 = 1 ->
              DEC counter1
              BNE key31S_13                 
              
              MOVB #$01,1,X+
              
              CLR 0,X                            ;<-
              
              LBRA key31S_26                     ;exit
              
key31S_14:    JSR tzFPN                          ;eliminate trailing zeros in FPN_a = z
              
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = FPN_a = z
              
              MOVW #m_i,memAddr2
              JSR copyFPN                        ;FPN_i = FPN_a = z (required since logFPN subroutine alters FPN_b)
              
              LDAA e_b                           ;A = exponent of z after trailing zeros have been eliminated
              
              BPL key31S_15                      ;branch if e_b >= 0, i.e. if z is an integer              
              
              LBRA key31S_24                     ;otherwise display "ERROR" on the status line and exit since 
                                                 ;x < 0 and z is not an integer
key31S_15:    BNE key31S_16                      ;branch if e_b > 0 (z is even)
              
              LDX #e_b                         
              DEX                                ;X = address of e_b - 1 (LS byte of mantissa of z)
              
              LDAA 0,X                           ;A = LS byte of mantissa of z
              
              ASRA                               ;shift bit 0 of LS byte of mantissa of z into C
              
              BCC key31S_16                      ;branch if z is even
              
              BSET flag3,#BIT0                   ;set gFlag0 as result is negative 
              
              BRA key31S_17
              
key31S_16:    BCLR flag3,#BIT0                   ;clear gFlag0 as result is non-negative
              
key31S_17:    MOVW #logEValues,logValues         ;store address of special values used in logFPN subroutine
              MOVW #logETen,logbTen 
              
              MOVW #m_f,memAddr1
              JSR lzMan
              LDAB noZero                        ;noZero is used in logFPN subroutine 
              
              JSR logFPN                         ;find the natural logarithm of FPN_f and store in FPN_a
              
              MOVW #m_i,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = z
                                               
              JSR multFPN                        ;multiply FPN_a by FPN_b and store the result in FPN_a
                                                 ;i.e. ln(x) * z -> FPN_a             

              BRCLR flag2,#BIT4,key31S_22        ;branch if manNeg flag clear, i.e. FPN_a should be positive

              JSR negFPN                         ;otherwise negate FPN_a first
              
              BRA key31S_22                                                              
                                                              
key31S_19:    LBNE key31S_24                     ;branch if e_b > 0 (y is even), i.e. display "ERROR" on the status 
                                                 ;line and exit since x < 0 & y is even              
              LDX #e_b                         
              DEX                                ;X = address of e_b - 1 (LS byte of mantissa of y)
              
              LDAA 0,X                           ;A = LS byte of mantissa of y
              
              ASRA                               ;shift bit 0 of LS byte of mantissa of y into C
              
              LBCC key31S_24                     ;branch if y is even, i.e. display "ERROR" on the status line and
                                                 ;exit since x < 0 & y is even
              
              BSET flag3,#BIT0                   ;set gFlag0 as result is negative 
              
key31S_21:    MOVW #m_b,memAddr1
              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              BNE key31S_21_1                    ;branch if y <> 0
              
              LBRA key31S_24                     ;display "ERROR" on the status line and exit since x > 0 and y = 0    

key31S_21_1:  MOVW #logEValues,logValues         ;store address of special values used in logFPN subroutine
              MOVW #logETen,logbTen 
              
              MOVW #m_f,memAddr1
              JSR lzMan
              LDAB noZero                        ;noZero is used in logFPN subroutine 
              
              JSR logFPN                         ;find the natural logarithm of FPN_f and store in FPN_a
              
              MOVW #m_i,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = y
                       
              JSR divFPN                         ;divide FPN_a by FPN_b and store the result in FPN_a
                                                 ;i.e. ln(x)/y -> FPN_a             

              BRCLR flag2,#BIT4,key31S_22        ;branch if manNeg flag clear, i.e. FPN_a should be positive

              JSR negFPN                         ;otherwise negate FPN_a first          

key31S_22:    MOVW #m_f,memAddr2                 ;copy FPN_a to FPN_f as cmpFPN_GE subroutine below alters value of 
              JSR copyFPN                        ;FPN_a      

              LDX #m_b                           ;FPN_b = 230.25850929934 ->
                                                 
              MOVB #$02,1,X+
              MOVB #$30,1,X+
              MOVB #$25,1,X+
              MOVB #$85,1,X+
              MOVB #$09,1,X+
              MOVB #$29,1,X+
              MOVB #$93,1,X+
              MOVB #$40,1,X+                     ;m_b = 02 30 25 85 09 29 93 40
              
              MOVB #$F4,0,X                      ;e_b = -12

              JSR cmpFPN_GE                      ;sets ge flag if FPN_a >= FPN_b
                                                 ;i.e. if y * ln(x) or ln(x)/y >= 230.25850929934 
              
              BRSET flag5,#BIT0,key31S_24        ;display "ERROR" if ge flag set
              
              MOVW #negLogEValues,negLogValues   ;store address of special values used in expFPN subroutine              
              
              JSR expFPN                         ;find e^FPN_f and store the result in FPN_b
              
              LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;increment usPointer
              
              MOVW #m_b,memAddr1
              
              BRCLR flag3,#BIT0,key31S_23        ;branch as result should be positive 
              
              JSR negFPN                         ;otherwise negate FPN_b as result should be negative 

key31S_23:    MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_b -> FPN_1, i.e. x^y/x^(1/y) -> FPN_1
              
              BRA key31S_26                      ;exit
              
key31S_24:    BRCLR flag2,#BIT7,key31S_25        ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer first 
              ADDD #lenFPNBytes
              STD usPointer            

key31S_25:    JSR dispError                      ;display "ERROR" on the status line and exit

key31S_26:    JSR clrComLMem                     ;clear command line memory              

              JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 32S: x^(1/2);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SQRT:         LDAA noDigMan
              BNE key32_1                        ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key10S_5                       ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              JMP keyHdlr_1                      ;exit as the command line and stack are both empty
              
key32_1:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key32_2          ;branch if oFlow flag was not set
              
              BRA key10S_6                       ;otherwise display "ERROR" on the status line and exit       

key32_2:      LDD usPointer
              CPD #$2000
              BNE key10S_3                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key10S_4                         
                                                  
key10S_3:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key10S_4:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack               
              
key10S_5:     MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1
              
              LDX #m_a
              LDAA 0,X
              ANDA #$F0
              BEQ key10S_8                       ;continue if FPN_1 >= 0 
              
key10S_6:     BRCLR flag2,#BIT7,key10S_7         ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key10S_7:     JSR dispError                      ;display "ERROR" on the status line and exit  
              JMP keyHdlr_1                      ;return to scanKey subroutine               

key10S_8:     JSR lzMan                          ;determine the number of leading zeros in FPN_1
              LDAA #lenMan          
              CMPA noZero
              BNE key10S_9                       ;continue if FPN_1 <> 0
              
              JMP key10S_27                      ;otherwise display 0 and exit          
              
key10S_9:     JSR sqrtFPN                        ;
                                               
              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_1 = FPN_b 
                  
key10S_27:    JSR clrComLMem                     ;clear command line memory 
              JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 34S; CPLX folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CPLX:         MOVB #$01,menu

              BSET flag4,#BIT1                   ;set cpx flag
              
              JSR clrComLMem          

              JMP keyHdlr_1                      ;return to scanKey subroutine			  

;Key 35S; Approximate/Exact toggle;;;;;;;;;;;;;;;;

AET:          CALL key132SUB

              JSR clrComLMem          

              JMP keyHdlr_1                      ;return to scanKey subroutine                        

;Key 36S; User SYS folder;;;;;;;;;;;;;;;;;;;;;;;;;

SYS:          MOVB #$1D,menu

              JSR clrComLMem          

              JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 37S: User MODE folder;;;;;;;;;;;;;;;;;;;;;;;;

MODEF:        MOVB #$1F,menu

              CALL setToDec 

              JSR clrComLMem         

              JMP keyHdlr_1                      ;return to scanKey subroutine
			  
;Key 38S; APP folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

APP:          MOVB #$1B,menu

              CALL setToDec 

              JSR clrComLMem          

              JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 85: ASM folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ASM:          MOVB #$03,menu

              CALL setToDec 

              JSR clrComLMem           

              JMP keyHdlr_1

;Key 39S: EQN folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EQN:          MOVB #$21,menu

              CALL setToDec 

              JSR clrComLMem         

              JMP keyHdlr_1                      ;return to scanKey subroutine
			  
;Key 40S: GRPH folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GRPH:         MOVB #$19,menu

              CALL setToDec 

              JSR clrComLMem        

              JMP keyHdlr_1                      ;return to scanKey subroutine
			  
;CALC folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CALC:         MOVB #$09,menu

              CALL setToDec

              JSR clrComLMem         

              JMP keyHdlr_1

;NUMB folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NUMB:         MOVB #$05,menu

              CALL setToDec

              JSR clrComLMem         

              JMP keyHdlr_1

;PROB folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROB:         MOVB #$11,menu

              CALL setToDec

              JSR clrComLMem         

              JMP keyHdlr_1

;OPRE folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

OPRE:         MOVB #$0B,menu

              CALL setToDec

              JSR clrComLMem         

              JMP keyHdlr_1

;STAT folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

STAT:         MOVB #$13,menu

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-> set K to -1
              
              LDX #m_K                           ;X points to MS byte of mantissa of K
                           
              LDAA #$99
              LDAB #$08 
                            
STAT_1:       STAA 1,X+
              
              DECB
              BNE STAT_1
              
              CLRA
              STAA 0,X                    
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<-
              
              CALL setToDec

              JSR clrComLMem         

              JMP keyHdlr_1

;FINANCIAL folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FINA:         MOVB #$0F,menu

              CALL setToDec 

              JSR clrComLMem        

              JMP keyHdlr_1

;FUNCTION folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FUNC:         MOVB #$0D,menu

              CALL setToDec

              JSR clrComLMem         

              JMP keyHdlr_1

;MATRICES folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MATR:         MOVB #$15,menu

              CALL setToDec

              JSR clrComLMem         

              JMP keyHdlr_1

;POLYNOMIAL folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

POLY:         MOVB #$07,menu

              CALL setToDec

              JSR clrComLMem 

              JMP keyHdlr_1

;Key 41S: STAK folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

STAK:         MOVB #$17,menu 

              JSR clrComLMem        

              JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 42S: MK6 Shift;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M6S:          LDAA noDigMan
              BEQ keyM6S_1                       ;branch if the command line is empty
              
              BRA keyM6S_exit                    ;otherwise exit      

keyM6S_1:     LDAB menu
              ASLB                              

              LDX #SMK6Table     

              JMP [D,X]

SMK6Table     DC.W Prg6Ed                        ;menu0 = enter program 6 edit mode                         
              DC.W keyM6S_exit                   ;menu1 = 
              DC.W Prg6Ed                        ;menu2 = CPX2 function 6S = enter program 6 edit mode
              DC.W keyM6S_exit                   ;menu3 =  
              DC.W keyM6S_exit                   ;menu4 = 
              DC.W keyM6S_exit                   ;menu5 = 
              DC.W keyM6S_exit                   ;menu6 = 
              DC.W keyM6S_exit                   ;menu7 = 
              DC.W keyM6S_exit                   ;menu8 =
              DC.W keyM6S_exit                   ;menu9 = 
              DC.W keyM6S_exit                   ;menu10 = 
              DC.W keyM6S_exit                   ;menu11 = 
              DC.W keyM6S_exit                   ;menu12 = 
              DC.W keyM6S_exit                   ;menu13 = 
              DC.W keyM6S_exit                   ;menu14 = 
              DC.W keyM6S_exit                   ;menu15 = 
              DC.W keyM6S_exit                   ;menu16 = 
              DC.W keyM6S_exit                   ;menu17 = 
              DC.W keyM6S_exit                   ;menu18 = 
              DC.W keyM6S_exit                   ;menu19 = 
              DC.W keyM6S_exit                   ;menu20 = 
              DC.W keyM6S_exit                   ;menu21 = 
              DC.W keyM6S_exit                   ;menu22 = 
              DC.W keyM6S_exit                   ;menu23 = 
              DC.W keyM6S_exit                   ;menu24 = 
              DC.W keyM6S_exit                   ;menu25 = 
              DC.W keyM6S_exit                   ;menu26 = 
              DC.W keyM6S_exit                   ;menu27 = 
              DC.W keyM6S_exit                   ;menu28 = 
              DC.W keyM6S_exit                   ;menu29 = 
              DC.W keyM6S_exit                   ;menu30 = 
              DC.W keyM6S_exit                   ;menu31 = 
              DC.W keyM6S_exit                   ;menu32 =
              DC.W keyM6S_exit                   ;menu33 = 
              DC.W keyM6S_exit                   ;menu34 = 
              DC.W keyM6S_exit                   ;menu35 = 
              DC.W keyM6S_exit                   ;menu36 =                     

keyM6S_exit:  JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 43S: MK5 Shift;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M5S:          LDAA noDigMan
              BEQ keyM5S_1                       ;branch if the command line is empty
              
              BRA keyM5S_exit                    ;otherwise exit      

keyM5S_1:     LDAB menu
              ASLB                              

              LDX #SMK5Table     

              JMP [D,X]

SMK5Table     DC.W Prg5Ed                        ;menu0 = enter program 5 edit mode                         
              DC.W keyM5S_exit                   ;menu1 = 
              DC.W Prg5Ed                        ;menu2 = CPX2 function 5S = enter program 5 edit mode
              DC.W keyM5S_exit                   ;menu3 =  
              DC.W keyM5S_exit                   ;menu4 = 
              DC.W keyM5S_exit                   ;menu5 = 
              DC.W keyM5S_exit                   ;menu6 = 
              DC.W keyM5S_exit                   ;menu7 = 
              DC.W keyM5S_exit                   ;menu8 =
              DC.W keyM5S_exit                   ;menu9 = 
              DC.W keyM5S_exit                   ;menu10 = 
              DC.W keyM5S_exit                   ;menu11 = 
              DC.W keyM5S_exit                   ;menu12 = 
              DC.W keyM5S_exit                   ;menu13 = 
              DC.W keyM5S_exit                   ;menu14 = 
              DC.W keyM5S_exit                   ;menu15 = 
              DC.W keyM5S_exit                   ;menu16 = 
              DC.W keyM5S_exit                   ;menu17 = 
              DC.W keyM5S_exit                   ;menu18 = 
              DC.W keyM5S_exit                   ;menu19 = 
              DC.W keyM5S_exit                   ;menu20 = 
              DC.W keyM5S_exit                   ;menu21 = 
              DC.W keyM5S_exit                   ;menu22 = 
              DC.W keyM5S_exit                   ;menu23 = 
              DC.W keyM5S_exit                   ;menu24 = 
              DC.W keyM5S_exit                   ;menu25 = 
              DC.W keyM5S_exit                   ;menu26 = 
              DC.W keyM5S_exit                   ;menu27 = 
              DC.W keyM5S_exit                   ;menu28 = 
              DC.W keyM5S_exit                   ;menu29 = 
              DC.W keyM5S_exit                   ;menu30 = 
              DC.W keyM5S_exit                   ;menu31 = 
              DC.W keyM5S_exit                   ;menu32 = 
              DC.W keyM5S_exit                   ;menu33 = 
              DC.W keyM5S_exit                   ;menu34 = 
              DC.W keyM5S_exit                   ;menu35 = 
              DC.W keyM5S_exit                   ;menu36 =                     

keyM5S_exit:  JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 44S: MK4 Shift;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M4S:          LDAA noDigMan
              BEQ keyM4S_1                       ;branch if the command line is empty
              
              BRA keyM4S_exit                    ;otherwise exit      

keyM4S_1:     LDAB menu
              ASLB                              

              LDX #SMK4Table     

              JMP [D,X]

SMK4Table     DC.W Prg4Ed                        ;menu0 = enter program 4 edit mode                         
              DC.W keyM4S_exit                   ;menu1 = 
              DC.W Prg4Ed                        ;menu2 = CPX2 function 4S = enter program 4 edit mode
              DC.W keyM4S_exit                   ;menu3 =  
              DC.W keyM4S_exit                   ;menu4 = 
              DC.W keyM4S_exit                   ;menu5 = 
              DC.W keyM4S_exit                   ;menu6 = 
              DC.W keyM4S_exit                   ;menu7 = 
              DC.W keyM4S_exit                   ;menu8 =
              DC.W keyM4S_exit                   ;menu9 = 
              DC.W keyM4S_exit                   ;menu10 = 
              DC.W keyM4S_exit                   ;menu11 = 
              DC.W keyM4S_exit                   ;menu12 = 
              DC.W keyM4S_exit                   ;menu13 = 
              DC.W keyM4S_exit                   ;menu14 = 
              DC.W keyM4S_exit                   ;menu15 = 
              DC.W keyM4S_exit                   ;menu16 = 
              DC.W keyM4S_exit                   ;menu17 = 
              DC.W keyM4S_exit                   ;menu18 = 
              DC.W keyM4S_exit                   ;menu19 = 
              DC.W keyM4S_exit                   ;menu20 = 
              DC.W keyM4S_exit                   ;menu21 = 
              DC.W keyM4S_exit                   ;menu22 = 
              DC.W keyM4S_exit                   ;menu23 = 
              DC.W keyM4S_exit                   ;menu24 = 
              DC.W keyM4S_exit                   ;menu25 = 
              DC.W keyM4S_exit                   ;menu26 = 
              DC.W keyM4S_exit                   ;menu27 = 
              DC.W keyM4S_exit                   ;menu28 = 
              DC.W keyM4S_exit                   ;menu29 = 
              DC.W keyM4S_exit                   ;menu30 = 
              DC.W keyM4S_exit                   ;menu31 = 
              DC.W keyM4S_exit                   ;menu32 = 
              DC.W keyM4S_exit                   ;menu33 = 
              DC.W keyM4S_exit                   ;menu34 = 
              DC.W keyM4S_exit                   ;menu35 = 
              DC.W keyM4S_exit                   ;menu36 =                      

keyM4S_exit:  JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 45S: MK3 Shift;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M3S:          LDAA noDigMan
              BEQ keyM3S_1                       ;branch if the command line is empty
              
              BRA keyM3S_exit                    ;otherwise exit      

keyM3S_1:     LDAB menu
              ASLB                              

              LDX #SMK3Table     

              JMP [D,X]
                       
SMK3Table     DC.W Prg3Ed                        ;menu0 = enter program 3 edit mode                         
              DC.W keyM3S_exit                   ;menu1 = 
              DC.W Prg3Ed                        ;menu2 = CPX2 function 3S = enter program 3 edit mode
              DC.W keyM3S_exit                   ;menu3 =  
              DC.W keyM3S_exit                   ;menu4 = 
              DC.W keyM3S_exit                   ;menu5 = 
              DC.W keyM3S_exit                   ;menu6 = 
              DC.W keyM3S_exit                   ;menu7 = 
              DC.W keyM3S_exit                   ;menu8 =
              DC.W keyM3S_exit                   ;menu9 = 
              DC.W keyM3S_exit                   ;menu10 = 
              DC.W keyM3S_exit                   ;menu11 = 
              DC.W keyM3S_exit                   ;menu12 = 
              DC.W keyM3S_exit                   ;menu13 = 
              DC.W keyM3S_exit                   ;menu14 = 
              DC.W keyM3S_exit                   ;menu15 = 
              DC.W keyM3S_exit                   ;menu16 = 
              DC.W keyM3S_exit                   ;menu17 = 
              DC.W keyM3S_exit                   ;menu18 = 
              DC.W keyM3S_exit                   ;menu19 = 
              DC.W keyM3S_exit                   ;menu20 = 
              DC.W keyM3S_exit                   ;menu21 = 
              DC.W keyM3S_exit                   ;menu22 = 
              DC.W keyM3S_exit                   ;menu23 = 
              DC.W keyM3S_exit                   ;menu24 = 
              DC.W keyM3S_exit                   ;menu25 = 
              DC.W keyM3S_exit                   ;menu26 = 
              DC.W keyM3S_exit                   ;menu27 = 
              DC.W keyM3S_exit                   ;menu28 = 
              DC.W keyM3S_exit                   ;menu29 = 
              DC.W keyM3S_exit                   ;menu30 = 
              DC.W keyM3S_exit                   ;menu31 = 
              DC.W keyM3S_exit                   ;menu32 = 
              DC.W keyM3S_exit                   ;menu33 = 
              DC.W keyM3S_exit                   ;menu34 = 
              DC.W keyM3S_exit                   ;menu35 = 
              DC.W keyM3S_exit                   ;menu36 =                     

keyM3S_exit:  JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 46S: MK2 Shift;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M2S:          LDAA noDigMan
              BEQ keyM2S_1                       ;branch if the command line is empty
              
              BRA keyM2S_exit                    ;otherwise exit      

keyM2S_1:     LDAB menu
              ASLB                              

              LDX #SMK2Table     

              JMP [D,X]

SMK2Table     DC.W Prg2Ed                        ;menu0 = enter program 2 edit mode                         
              DC.W keyM2S_exit                   ;menu1 = 
              DC.W Prg2Ed                        ;menu2 = CPX2 function 2S = enter program 2 edit mode
              DC.W keyM2S_exit                   ;menu3 =  
              DC.W keyM2S_exit                   ;menu4 = 
              DC.W keyM2S_exit                   ;menu5 = 
              DC.W keyM2S_exit                   ;menu6 = 
              DC.W keyM2S_exit                   ;menu7 = 
              DC.W keyM2S_exit                   ;menu8 =
              DC.W keyM2S_exit                   ;menu9 = 
              DC.W keyM2S_exit                   ;menu10 = 
              DC.W keyM2S_exit                   ;menu11 = 
              DC.W keyM2S_exit                   ;menu12 = 
              DC.W keyM2S_exit                   ;menu13 = 
              DC.W keyM2S_exit                   ;menu14 = 
              DC.W keyM2S_exit                   ;menu15 = 
              DC.W keyM2S_exit                   ;menu16 = 
              DC.W keyM2S_exit                   ;menu17 = 
              DC.W keyM2S_exit                   ;menu18 = 
              DC.W keyM2S_exit                   ;menu19 = 
              DC.W keyM2S_exit                   ;menu20 = 
              DC.W keyM2S_exit                   ;menu21 = 
              DC.W keyM2S_exit                   ;menu22 = 
              DC.W keyM2S_exit                   ;menu23 = 
              DC.W keyM2S_exit                   ;menu24 = 
              DC.W keyM2S_exit                   ;menu25 = 
              DC.W keyM2S_exit                   ;menu26 = 
              DC.W keyM2S_exit                   ;menu27 = 
              DC.W keyM2S_exit                   ;menu28 = 
              DC.W keyM2S_exit                   ;menu29 = 
              DC.W keyM2S_exit                   ;menu30 = 
              DC.W keyM2S_exit                   ;menu31 = 
              DC.W keyM2S_exit                   ;menu32 =
              DC.W keyM2S_exit                   ;menu33 = 
              DC.W keyM2S_exit                   ;menu34 = 
              DC.W keyM2S_exit                   ;menu35 = 
              DC.W keyM2S_exit                   ;menu36 =                      

keyM2S_exit:  JMP keyHdlr_1                      ;return to scanKey subroutine

;Key 47S: MK1 Shift;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

M1S:          LDAA noDigMan
              BEQ keyM1S_1                       ;branch if the command line is empty
              
              BRA keyM1S_exit                    ;otherwise exit      

keyM1S_1:     LDAB menu
              ASLB                              

              LDX #SMK1Table     

              JMP [D,X]

SMK1Table     DC.W Prg1Ed                        ;menu0 = enter program 1 edit mode                         
              DC.W keyM1S_exit                   ;menu1 = 
              DC.W Prg1Ed                        ;menu2 = CPX2 function 1S = enter program 1 edit mode
              DC.W keyM1S_exit                   ;menu3 =  
              DC.W keyM1S_exit                   ;menu4 = 
              DC.W keyM1S_exit                   ;menu5 = 
              DC.W keyM1S_exit                   ;menu6 = 
              DC.W keyM1S_exit                   ;menu7 = 
              DC.W keyM1S_exit                   ;menu8 =
              DC.W keyM1S_exit                   ;menu9 = 
              DC.W keyM1S_exit                   ;menu10 = 
              DC.W keyM1S_exit                   ;menu11 = 
              DC.W keyM1S_exit                   ;menu12 = 
              DC.W keyM1S_exit                   ;menu13 = 
              DC.W keyM1S_exit                   ;menu14 = 
              DC.W keyM1S_exit                   ;menu15 = 
              DC.W keyM1S_exit                   ;menu16 = 
              DC.W keyM1S_exit                   ;menu17 = 
              DC.W keyM1S_exit                   ;menu18 = 
              DC.W keyM1S_exit                   ;menu19 = 
              DC.W keyM1S_exit                   ;menu20 = 
              DC.W keyM1S_exit                   ;menu21 = 
              DC.W keyM1S_exit                   ;menu22 = 
              DC.W keyM1S_exit                   ;menu23 = 
              DC.W keyM1S_exit                   ;menu24 = 
              DC.W keyM1S_exit                   ;menu25 = 
              DC.W keyM1S_exit                   ;menu26 = 
              DC.W keyM1S_exit                   ;menu27 = 
              DC.W keyM1S_exit                   ;menu28 = 
              DC.W keyM1S_exit                   ;menu29 = 
              DC.W keyM1S_exit                   ;menu30 = 
              DC.W keyM1S_exit                   ;menu31 = 
              DC.W keyM1S_exit                   ;menu32 = 
              DC.W keyM1S_exit                   ;menu33 = 
              DC.W keyM1S_exit                   ;menu34 = 
              DC.W keyM1S_exit                   ;menu35 = 
              DC.W keyM1S_exit                   ;menu36 =                    

keyM1S_exit:  JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key0T: Push the FPN stored in ms_end (Z) onto the stack

ZOUT:         CLR keyNumber

              JSR rclFPN                         ;copy the FPN stored in Z to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine 
              
;Key1T: Push the FPN stored in ms_end + 9 (Y) onto the stack

YOUT:         MOVB #$01,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in Y to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key2T: Push the FPN stored in ms_end + 18 (X) onto the stack

XOUT:         MOVB #$02,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in X to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key3T: Push the FPN stored in ms_end + 27 (W) onto the stack

WOUT:        MOVB #$03,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in W to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key4T: Push the FPN stored in ms_end + 36 (V) onto the stack

VOUT:        MOVB #$04,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in V to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine

              
;Key6T: Push the FPN stored in ms_end + 45 (U) onto the stack

UOUT:        MOVB #$05,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in U to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key7T: Push the FPN stored in ms_end + 54 (T) onto the stack

TOUT:        MOVB #$06,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in T to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key8T: Push the FPN stored in ms_end + 63 (S) onto the stack

SOUT:        MOVB #$07,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in S to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key9T: Push the FPN stored in ms_end + 72 (R) onto the stack

ROUT:        MOVB #$08,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in R to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine

;Key10T: Push the FPN stored in ms_end + 81 (Q) onto the stack

QOUT:       MOVB #$09,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in Q to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key12T: Push the FPN stored in ms_end + 90 (P) onto the stack

POUT:       MOVB #$0A,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in P to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key13T: Push the FPN stored in ms_end + 99 (O) onto the stack

OOUT:       MOVB #$0B,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in O to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key14T: Push the FPN stored in ms_end + 108 (N) onto the stack

NOUT:       MOVB #$0C,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in N to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key15T: Push the FPN stored in ms_end + 117 (M) onto the stack

MOUT:       MOVB #$0D,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in M to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key16T: Push the FPN stored in ms_end + 126 (L) onto the stack

LOUT:       MOVB #$0E,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in L to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key18T: Push the FPN stored in ms_end + 135 (K) onto the stack

KOUT:       MOVB #$0F,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in K to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key19T: Push the FPN stored in ms_end + 144 (J) onto the stack

JOUT:       MOVB #$10,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in J to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key20T: Push the FPN stored in ms_end + 153 (I) onto the stack

IOUT:       MOVB #$11,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in I to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key21T: Push the FPN stored in ms_end + 162 (H) onto the stack

HOUT:       MOVB #$12,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in H to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key22T: Push the FPN stored in ms_end + 171 (G) onto the stack

GOUT:       MOVB #$13,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in G to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key24T: Push the FPN stored in ms_end + 180 (F) onto the stack

FOUT:       MOVB #$14,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in F to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key25T: Push the FPN stored in ms_end + 189 (E) onto the stack

EOUT:       MOVB #$15,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in E to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine

;Key26T: Push the FPN stored in ms_end + 198 (D) onto the stack

DOUT:       MOVB #$16,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in D to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key27T: Push the FPN stored in ms_end + 207 (C) onto the stack

COUT:       MOVB #$17,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in C to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key28T: Push the FPN stored in ms_end + 216 (B) onto the stack

BOUT:       MOVB #$18,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in B to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key29T: Push the FPN stored in ms_end + 225 (A) onto the stack

AOUT:       MOVB #$19,keyNumber
              
              JSR rclFPN                         ;copy the FPN stored in A to the user stack    
        
              JMP keyHdlr_1                      ;return to scanKey subroutine
              
;Key126: terminates program execution;;;;;;;;;;;;;

PRGEND:       INS                                ;return to scanKey subroutine 
              INS
              
              RTS
              
;Key127: starts the timer;;;;;;;;;;;;;;;;;;;;;;;;;

TON:          BCLR CRGINT,#BIT7                  ;disable RTI       

              CLI                                ;unmask interrupts to make RTI interruptible

              MOVB #$81,TIM_TSCR2                ;TIM_TSCR2 = 1000 0001
                                                 ;timer set with interrupt & prescale factor = 2
              
              MOVW TIM_TCNT,tcntRegStart         ;store counter register start value  
              
              CLRA
              CLRB
              STD tcntOvrflw                     ;clear tcntOvrflw, which records the number of times the timer 
                                                 ;overflows
              
              STD tcntOvrflw2                    ;clear tcntOvrflw2, which records the number of times tcntOvrflw 
                                                 ;overflows
              
              MOVB #$80,TIM_TSCR1                ;TIM_TSCR1 = 1000 0000,timer started
              
              JMP keyHdlr_1
              
;key128: stops the timer;;;;;;;;;;;;;;;;;;;;;;;;;;

TOF:          SEI                                ;set the I mask bit to make RTI uninterruptible 

              CLR TIM_TSCR1                      ;TSCR1 = 0000 0000,timer stopped

              MOVB #$01,TIM_TSCR2                ;TSCR2 = 0000 0001
                                                 ;timer set with no interrupt & prescale factor = 2
              
              MOVW TIM_TCNT,tcntRegEnd           ;store counter register end value
              
              BSET CRGINT,#BIT7                  ;enable RTI

              JMP keyHdlr_1                 
              
;key131: modulus of complex number;;;;;;;;;;;;;;;;

MODZ:         LDD usPointer
              CPD #ms_end
              BEQ key131_exit                    ;exit if the stack is empty
              
              LDX prgCounter
              PSHX                   

              LDX #CPXModPrg
              DEX
              STX prgCounter                     ;prgCounter = CPXModPrg - 1
              
              JSR exePrg
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag                      

key131_exit:  JMP keyHdlr_1
            
;key133: Execute program 6;;;;;;;;;;;;;;;;;;;;;;;;

PRG6:         MOVW #ms_start_LS,prgCounter       ;first instruction is at ms_start_LS + 1

key133_1:     LDX prgCounter
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions                 

              CALL clrChar                       ;delete the cursor (so that command line is clear when program 
                                                 ;halted)                                                               
              
              BCLR PTH,#BIT0                     ;A0 = 0, send command	

			        LDAA #$B0                          ;page 0  
              JSR sendByte                       ;set the page

              MOVB #$1B,Ycoord
              JSR setY                           ;Y = 27
              
              LDX #R
              MOVB #wFontSL,colNumber
              JSR sendData2                      ;display "R" to show calculator is in run mode
              
              JSR exePrg
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
                            
              JSR clrComLMem                     ;clear command line memory

              JMP keyHdlr_1
 
;key135: display the user stack level memory contents/return to user stack display

MEMO:         CALL key135SUB       

              JMP keyHdlr_1

;key136: display the elapsed time/return to user stack display

TIME:         CALL key136SUB      

              JMP keyHdlr_1

;key137: R->Z;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RTOC:         LDAA noDigMan
              BNE key137_1                       ;branch if the command line is not empty
              
              JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key137_3                       ;branch if the user stack depth > 1
              BRA key137_exit                    ;return to scanKey subroutine as the user stack depth = 0 or 1
              
key137_3:     LDD usPointer                      ;FPN_2,FPN_1 -> Z = FPN_2 + FPN_1i
              STD memAddr1
              
              ADDD #lenFPNBytes
              STD usPointer
              ADDD #$1301                        ;D points to the imaginary number stack
                       
              STD memAddr2
              JSR copyFPN
              
              BRA key137_exit             

key137_1:     LDD usPointer
              CPD #ms_end
              BEQ key137_exit                    ;exit if the stack is empty     

              JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key137_2         ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              BRA key137_exit                                    
 
key137_2:     LDD usPointer
              ADDD #$1301                        ;D points to the imaginary number stack             
              
              MOVW #m_com,memAddr1                  
              STD memAddr2
              
              JSR copyFPN                        ;command line value copied to the imaginary number stack
              
              JSR clrComLMem                     ;clear command line memory 
              
key137_exit:  JMP keyHdlr_1                      ;return to scanKey subroutine              

;key138: conjugate of Z;;;;;;;;;;;;;;;;;;;;;;;;;;;

COZ:          JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              TSTA
              BEQ key138_exit                    ;exit if the user stack depth = 0      

              LDD usPointer
              ADDD #$1301                        ;D points to the imaginary number stack
              
              STD memAddr1                                          
              JSR negFPN                         ;negate the imaginary part
                            
key138_exit:  JMP keyHdlr_1                      ;return to scanKey subroutine       
              
;Enter program 1 edit mode;;;;;;;;;;;;;;;;;;;;;;;;

Prg1Ed:       CALL key139SUB

              JMP keyHdlr_1

;Enter program 2 edit mode;;;;;;;;;;;;;;;;;;;;;;;;

Prg2Ed:       CALL key139SUB

              JMP keyHdlr_1

;Enter program 3 edit mode;;;;;;;;;;;;;;;;;;;;;;;;

Prg3Ed:       CALL key139SUB

              JMP keyHdlr_1

;Enter program 4 edit mode;;;;;;;;;;;;;;;;;;;;;;;;

Prg4Ed:       CALL key139SUB

              JMP keyHdlr_1

;Enter program 5 edit mode;;;;;;;;;;;;;;;;;;;;;;;;

Prg5Ed:       CALL key139SUB

              JMP keyHdlr_1

;Enter program 6 edit mode;;;;;;;;;;;;;;;;;;;;;;;;

Prg6Ed:       CALL key139SUB

              JMP keyHdlr_1 
   
;key140: Enter program debug mode to single step through program 6 starting at $219E

Prg6Db:       MOVW #ms_start_LS,prgCounter       ;prgCounter initialised
                            
key140_start: MOVW prgCounter,prgCounterSt       ;prgCounterSt is used to determine the program step number in 
                                                 ;subroutine dispPrgIstr
              JSR dbgProg
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
                            
              JSR clrComLMem                     ;clear command line memory

              JMP keyHdlr_1

;key141: SPC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PrgCt:        JMP keyHdlr_1

;key142: ABOUT page;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ABOUT:        CALL key142SUB       

              JMP keyHdlr_1
              
;key143: PICK program instruction;;;;;;;;;;;;;;;;; 

PickPrg:      LDD prgCounter                     
              ADDD #$0002
              STD prgCounter                     ;D = address of byte equal to stack level in binary
              
              LDX prgCounter
              LDAA 0,X                           ;A = pick stack level in binary
              DECA
              
              LDAB #lenFPNBytes
              MUL                                ;A = 0, B = (pick stack level - 1) * lenFPNBytes              
              ADDD usPointer                     ;D = address of the pick stack level
              
              STD memAddr1
              MOVW #m_com,memAddr2              
              JSR copyFPN                        ;copy the FPN to the command line in order to duplicate it
                                         
              JMP key3_6                         ;simulate "Enter" press
              
;key144: ->Z program instruction;;;;;;;;;;;;;;;;;;

STOZ:         MOVW #ms_end,memAddr2              ;ms_end = ms26 corresponds to the letter "Z" 
              
              JSR stoFPN2
              
              JMP keyHdlr_1

;key145: ->Y program instruction;;;;;;;;;;;;;;;;;;

STOY:       LDD #ms_end                        ;ms_end + 9 = ms25 corresponds to the letter "Y"
              ADDD #$0009      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key146: ->X program instruction;;;;;;;;;;;;;;;;;;

STOX:       LDD #ms_end                        ;ms_end + 18 = ms24 corresponds to the letter "X"
              ADDD #$0012      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1

;key147: ->W program instruction;;;;;;;;;;;;;;;;;;

STOW:       LDD #ms_end                        ;ms_end + 27 = ms23 corresponds to the letter "W"
              ADDD #$001B      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1

;key148: ->V program instruction;;;;;;;;;;;;;;;;;;

STOV:       LDD #ms_end                        ;ms_end + 36 = ms22 corresponds to the letter "V"
              ADDD #$0024      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1

;key149: ->U program instruction;;;;;;;;;;;;;;;;;;

STOU:       LDD #ms_end                        ;ms_end + 45 = ms21 corresponds to the letter "U"
              ADDD #$002D      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key150: ->T program instruction;;;;;;;;;;;;;;;;;;

STOT:       LDD #ms_end                        ;ms_end + 54 = ms20 corresponds to the letter "T"
              ADDD #$0036      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key151: ->S program instruction;;;;;;;;;;;;;;;;;;

STOS:       LDD #ms_end                        ;ms_end + 63 = ms19 corresponds to the letter "S"
              ADDD #$003F      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key152: ->R program instruction;;;;;;;;;;;;;;;;;;

STOR:       LDD #ms_end                        ;ms_end + 72 = ms18 corresponds to the letter "R"
              ADDD #$0048      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key153: ->Q program instruction;;;;;;;;;;;;;;;;;;

STOQ:       LDD #ms_end                        ;ms_end + 81 = ms17 corresponds to the letter "Q"
              ADDD #$0051      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key154: ->P program instruction;;;;;;;;;;;;;;;;;;

STORP:       LDD #ms_end                        ;ms_end + 90 = ms16 corresponds to the letter "P"
              ADDD #$005A      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key155: ->O program instruction;;;;;;;;;;;;;;;;;;

STOO:       LDD #ms_end                        ;ms_end + 99 = ms15 corresponds to the letter "O"
              ADDD #$0063      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key156: ->N program instruction;;;;;;;;;;;;;;;;;;

STON:       LDD #ms_end                        ;ms_end + 108 = ms14 corresponds to the letter "N"
              ADDD #$006C      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key157: ->M program instruction;;;;;;;;;;;;;;;;;;

STOM:       LDD #ms_end                        ;ms_end + 117 = ms13 corresponds to the letter "M"
              ADDD #$0075      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key158: ->L program instruction;;;;;;;;;;;;;;;;;;

STOL:       LDD #ms_end                        ;ms_end + 126 = ms12 corresponds to the letter "L"
              ADDD #$007E      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key159: ->K program instruction;;;;;;;;;;;;;;;;;;

STOK:       LDD #ms_end                        ;ms_end + 135 = ms11 corresponds to the letter "K"
              ADDD #$0087      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key160: ->J program instruction;;;;;;;;;;;;;;;;;;

STOJ:       LDD #ms_end                        ;ms_end + 144 = ms10 corresponds to the letter "J"
              ADDD #$0090      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key161: ->I program instruction;;;;;;;;;;;;;;;;;;

STOI:       LDD #ms_end                        ;ms_end + 153 = ms9 corresponds to the letter "I"
              ADDD #$0099      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key162: ->H program instruction;;;;;;;;;;;;;;;;;;

STOH:       LDD #ms_end                        ;ms_end + 162 = ms8 corresponds to the letter "H"
              ADDD #$00A2      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key163: ->G program instruction;;;;;;;;;;;;;;;;;;

STOG:       LDD #ms_end                        ;ms_end + 171 = ms7 corresponds to the letter "G"
              ADDD #$00AB      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key164: ->F program instruction;;;;;;;;;;;;;;;;;;

STOF:       LDD #ms_end                        ;ms_end + 180 = ms6 corresponds to the letter "F"
              ADDD #$00B4      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key165: ->E program instruction;;;;;;;;;;;;;;;;;;

STOE:       LDD #ms_end                        ;ms_end + 189 = ms5 corresponds to the letter "E"
              ADDD #$00BD      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key166: ->D program instruction;;;;;;;;;;;;;;;;;;

STOD:       LDD #ms_end                        ;ms_end + 198 = ms4 corresponds to the letter "D"
              ADDD #$00C6      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key167: ->C program instruction;;;;;;;;;;;;;;;;;;

STOC:       LDD #ms_end                        ;ms_end + 207 = ms3 corresponds to the letter "C"
              ADDD #$00CF      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key168: ->B program instruction;;;;;;;;;;;;;;;;;;

STOB:       LDD #ms_end                        ;ms_end + 216 = ms2 corresponds to the letter "B"
              ADDD #$00D8      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key169: ->A program instruction;;;;;;;;;;;;;;;;;;

STOA:       LDD #ms_end                        ;ms_end + 225 = ms1 corresponds to the letter "A"
              ADDD #$00E1      
              STD memAddr2                  
              
              JSR stoFPN2
              
              JMP keyHdlr_1
              
;key170: rotate the stack;;;;;;;;;;;;;;;;;;;;;;;;;

ROT:          JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              CMPA #$03
              BHS key170_1                       ;branch if the user stack is at least 3 levels deep 
              
              LBRA key170_exit                   ;otherwise exit        

key170_1:     LDX usPointer
              LDAB #$12
              ABX                                ;X = usPointer + 18, i.e X is pointing to FPN_3
                            
              ;push FPN_3 onto the stack ->
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 0,X                           ;X is now pointing to FPN_3_exponent
              PSHA
              ;<-
               
              LDY usPointer
              LDAB #$11
              ABY                                ;Y = usPointer + 17, i.e Y is pointing to FPN_2_exponent
              
              ;copy FPN_2 to FPN_3 ->
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 0,Y                           ;Y is now pointing to FPN_2
              STAA 0,X                          
              ;<-
              
              LDX usPointer
              
              ;copy FPN_1 to FPN_2 ->
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X                           ;X is now pointing to FPN_1_exponent
              STAA 0,Y                          
              ;<-
               
              ;copy FPN_3 to FPN_1 ->
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 0,X                           ;X is now pointing to FPN_1
              ;<-
               
              BRSET flag4,#BIT1,key170_1_1       ;branch if in complex mode
              
              LBRA key170_2
              
key170_1_1:   LDD usPointer
              ADDD #$1313
              TFR D,X                            ;X is pointing to FPN_3_imaginary
              
              ;push FPN_3_imaginary onto the stack ->
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 0,X                           ;X is now pointing to FPN_3_imaginary_exponent
              PSHA
              ;<-
               
              LDD usPointer
              ADDD #$1312
              TFR D,Y                            ;Y is pointing to FPN_2_imaginary_exponent                                              
              
              ;copy FPN_2_imaginary to FPN_3_imaginary ->
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 0,Y                           ;Y is now pointing to FPN_2_imaginary
              STAA 0,X                          
              ;<-
              
              LDD usPointer
              ADDD #$1301
              TFR D,X                            ;X is pointing to FPN_1_imaginary
              
              ;copy FPN_1_imaginary to FPN_2_imaginary ->
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X                           ;X is now pointing to FPN_1_imaginary_exponent
              STAA 0,Y                          
              ;<-
               
              ;copy FPN_3_imaginary to FPN_1_imaginary ->
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 0,X                           ;X is now pointing to FPN_1
              ;<-
              
              LBRA key170_exit
               
key170_2:     BRSET flag4,#BIT2,key170_2_1       ;branch if in exact mode

              LBRA key170_exit     

key170_2_1:   LDD usPointer
              ADDD #$13C7
              TFR D,X                            ;X is pointing to FPN_3_denominator
              
              ;push FPN_3_denominator onto the stack ->
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 0,X                           ;X is now pointing to FPN_3_denominator_exponent
              PSHA
              ;<-
               
              LDD usPointer
              ADDD #$13C6
              TFR D,Y                            ;Y is pointing to FPN_2_denominator_exponent                                              
              
              ;copy FPN_2_denominator to FPN_3_denominator ->
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 0,Y                           ;Y is now pointing to FPN_2_denominator
              STAA 0,X                          
              ;<-
              
              LDD usPointer
              ADDD #$13B5
              TFR D,X                            ;X is pointing to FPN_1_denominator
              
              ;copy FPN_1_denominator to FPN_2_denominator ->
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X                           ;X is now pointing to FPN_1_denominator_exponent
              STAA 0,Y                          
              ;<-
               
              ;copy FPN_3_denominator to FPN_1_denominator ->
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 0,X                           ;X is now pointing to FPN_1_denominator
              ;<-

key170_exit:  JMP keyHdlr_1                      ;return to scanKey subroutine

;key171: delete FPN_1 and FPN_2;;;;;;;;;;;;;;;;;;;

DEL2:         JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              CMPA #$02
              BHS key171_1                       ;branch if the user stack is at least 2 levels deep 
              
              BRA key171_2                       ;otherwise exit        

key171_1:     LDD usPointer
              ADDD #$0012
              STD usPointer                      ;usPointer drops two user stack levels              
              
key171_2:     JMP keyHdlr_1
              
;key172: unrotate the stack;;;;;;;;;;;;;;;;;;;;;;;

UNROT:        JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              CMPA #$03
              BHS key172_1                       ;branch if the user stack is at least 3 levels deep 
              
              LBRA key172_exit                   ;otherwise exit        

key172_1:     LDX usPointer
                                          
              ;push FPN_1 onto the stack ->
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 0,X                           ;X is now pointing to FPN_1_exponent
              PSHA
              ;<-
               
              LDY usPointer
              LDAB #$11
              ABY                                ;Y = usPointer + 17, i.e Y is pointing to FPN_2_exponent
              
              ;copy FPN_2 to FPN_1 ->
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 0,Y                           ;Y is now pointing to FPN_2
              STAA 0,X                          
              ;<-
              
              LDX usPointer
              LDAB #$12
              ABX                                ;X = usPointer + 18, i.e X is pointing to FPN_3
              
              ;copy FPN_3 to FPN_2 ->
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X                           ;X is now pointing to FPN_3_exponent
              STAA 0,Y                          
              ;<-
               
              ;copy FPN_1 to FPN_3 ->
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 0,X                           ;X is now pointing to FPN_3
              ;<-
               
              BRSET flag4,#BIT1,key172_1_1       ;branch if in complex mode
              
              LBRA key172_2
              
key172_1_1:   LDD usPointer
              ADDD #$1301
              TFR D,X                            ;X is pointing to FPN_1_imaginary
              
              ;push FPN_1_imaginary onto the stack ->
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 0,X                           ;X is now pointing to FPN_1_imaginary_exponent
              PSHA
              ;<-
               
              LDD usPointer
              ADDD #$1312
              TFR D,Y                            ;Y is pointing to FPN_2_imaginary_exponent                                              
              
              ;copy FPN_2_imaginary to FPN_1_imaginary ->
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 0,Y                           ;Y is now pointing to FPN_2_imaginary
              STAA 0,X                          
              ;<-
              
              LDD usPointer
              ADDD #$1313
              TFR D,X                            ;X is pointing to FPN_3_imaginary
              
              ;copy FPN_3_imaginary to FPN_2_imaginary ->
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X                           ;X is now pointing to FPN_3_imaginary_exponent
              STAA 0,Y                          
              ;<-
               
              ;copy FPN_1_imaginary to FPN_3_imaginary ->
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 0,X                           ;X is now pointing to FPN_3
              ;<-
              
              LBRA key172_exit
               
key172_2:     BRSET flag4,#BIT2,key172_2_1       ;branch if in exact mode

              LBRA key172_exit

key172_2_1:   LDD usPointer
              ADDD #$13B5
              TFR D,X                            ;X is pointing to FPN_1_denominator
              
              ;push FPN_1_denominator onto the stack ->
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 1,X+
              PSHA
              LDAA 0,X                           ;X is now pointing to FPN_1_denominator_exponent
              PSHA
              ;<-
               
              LDD usPointer
              ADDD #$13C6
              TFR D,Y                            ;Y is pointing to FPN_2_denominator_exponent                                              
              
              ;copy FPN_2_denominator to FPN_1_denominator ->
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 1,Y-
              STAA 1,X-
              LDAA 0,Y                           ;Y is now pointing to FPN_2_denominator
              STAA 0,X                          
              ;<-
              
              LDD usPointer
              ADDD #$13C7
              TFR D,X                            ;X is pointing to FPN_3_denominator
              
              ;copy FPN_3_denominator to FPN_2_denominator ->
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 1,X+
              STAA 1,Y+
              LDAA 0,X                           ;X is now pointing to FPN_3_denominator_exponent
              STAA 0,Y                          
              ;<-
               
              ;copy FPN_1_denominator to FPN_3_denominator ->
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 1,X-
              PULA
              STAA 0,X                           ;X is now pointing to FPN_3_denominator
              ;<-

key172_exit:  JMP keyHdlr_1                      ;return to scanKey subroutine

;key173: delete FPN_1,FPN_2 and FPN_3;;;;;;;;;;;;;

DEL3:         JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              CMPA #$03
              BHS key173_1                       ;branch if the user stack is at least 3 levels deep 
              
              BRA key173_2                       ;otherwise exit        

key173_1:     LDD usPointer
              ADDD #$001B
              STD usPointer                      ;usPointer drops three user stack levels
              
key173_2:     JMP keyHdlr_1
              
;key174: push FPN_1 and FPN_2 onto the stack;;;;;;

ENT2:         JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              CMPA #$02
              BHS key174_1                       ;branch if the user stack is at least 2 levels deep 
              
              LBRA key174_exit                   ;otherwise exit        

key174_1:     CMPA #$12
              BLS key174_2                       ;branch if the user stack is at most 18 levels deep
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack 
              LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              
              BRCLR flag4,#BIT1,key174_1_1       ;branch if not in complex mode
              
              JSR resetStackImag                 ;otherwise copy the current imaginary values to the bottom of the 
                                                 ;user stack                                                  
              BRA key174_2
              
key174_1_1:   BRCLR flag4,#BIT2,key174_2         ;branch if not in exact mode
              
              JSR resetStackDenom                ;otherwise copy the current denominator values to the bottom of the 
                                                 ;user stack                  
key174_2:     LDX usPointer
              LDAB #$11
              ABX                                ;X is pointing to FPN_2_exponent
              
              LDY usPointer
              DEY
              
              ;copy FPN_1 and FPN_2 
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<-
               
              BRSET flag4,#BIT1,key174_2_1       ;branch if in complex mode
              
              LBRA key174_3
              
key174_2_1:   LDD usPointer
              ADDD #$1312
              TFR D,X                            ;X is pointing to FPN_2_imaginary_exponent
              
              LDD usPointer
              ADDD #$1300
              TFR D,Y      

              ;copy FPN_1_imaginary and FPN_2_imaginary 
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<-
              
              TFR Y,D
              SUBD #$1301
              TFR D,Y
              
              LBRA key174_4
              
key174_3:     BRSET flag4,#BIT2,key174_3_1       ;branch if in exact mode

              LBRA key174_4 

key174_3_1:   LDD usPointer
              ADDD #$13C6
              TFR D,X                            ;X is pointing to FPN_2_denominator_exponent
              
              LDD usPointer
              ADDD #$13B4
              TFR D,Y      

              ;copy FPN_1_denominator and FPN_2_denominator
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<- 
              
              TFR Y,D
              SUBD #$13B5
              TFR D,Y
              
key174_4:     STY usPointer                                     
              
key174_exit:  JMP keyHdlr_1

;key175: over;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

OVER:         JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              CMPA #$02
              BHS key175_1                       ;branch if the user stack is at least 2 levels deep 
              
              LBRA key175_exit                   ;otherwise exit        

key175_1:     CMPA #$13
              BLS key175_2                       ;branch if the user stack is at most 19 levels deep
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack 
              LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              
              BRCLR flag4,#BIT1,key175_1_1       ;branch if not in complex mode
              
              JSR resetStackImag                 ;otherwise copy the current imaginary values to the bottom of the 
                                                 ;user stack                                                  
              BRA key175_2
              
key175_1_1:   BRCLR flag4,#BIT2,key175_2         ;branch if not in exact mode
              
              JSR resetStackDenom                ;otherwise copy the current denominator values to the bottom of the 
                                                 ;user stack                  
key175_2:     LDX usPointer
              LDAB #$11
              ABX                                ;X is pointing to FPN_2_exponent
              
              LDY usPointer
              DEY
              
              ;copy FPN_2 
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y              
              ;<-
               
              BRSET flag4,#BIT1,key175_2_1       ;branch if in complex mode
              
              BRA key175_3
              
key175_2_1:   LDD usPointer
              ADDD #$1312
              TFR D,X                            ;X is pointing to FPN_2_imaginary_exponent
              
              LDD usPointer
              ADDD #$1300
              TFR D,Y      

              ;copy FPN_2_imaginary 
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<-
              
              TFR Y,D
              SUBD #$1301
              TFR D,Y
              
              BRA key175_4
              
key175_3:     BRSET flag4,#BIT2,key175_3_1       ;branch if in exact mode

              BRA key175_4 

key175_3_1:   LDD usPointer
              ADDD #$13C6
              TFR D,X                            ;X is pointing to FPN_2_denominator_exponent
              
              LDD usPointer
              ADDD #$13B4
              TFR D,Y      

              ;copy FPN_2_denominator
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<- 
              
              TFR Y,D
              SUBD #$13B5
              TFR D,Y
              
key175_4:     STY usPointer         

key175_exit:  JMP keyHdlr_1

;key176: polar form of Z;;;;;;;;;;;;;;;;;;;;;;;;;;

POLAR:        LDD usPointer
              CPD #ms_end
              BEQ key176_exit                    ;exit if the stack is empty
              
              LDX prgCounter
              PSHX                   

              LDX prgCounterStM1
              PSHX           

              LDX #CPXPlrPrg
              DEX
              STX prgCounter                     ;prgCounter = CPXPlrPrg - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag                      

key176_exit:  JMP keyHdlr_1 
              
;key177: push FPN_1, FPN_2 and FPN_3 onto the stack

ENT3:         JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              CMPA #$03
              BHS key177_1                       ;branch if the user stack is at least 3 levels deep 
              
              LBRA key177_exit                   ;otherwise exit        

key177_1:     CMPA #$11
              BLS key177_2                       ;branch if the user stack is at most 17 levels deep
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack 
              LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              
              BRCLR flag4,#BIT1,key177_1_1       ;branch if not in complex mode
              
              JSR resetStackImag                 ;otherwise copy the current imaginary values to the bottom of the 
                                                 ;user stack                                                  
              BRA key177_2
              
key177_1_1:   BRCLR flag4,#BIT2,key177_2         ;branch if not in exact mode
              
              JSR resetStackDenom                ;otherwise copy the current denominator values to the bottom of the 
                                                 ;user stack                  
key177_2:     LDX usPointer
              LDAB #$1A
              ABX                                ;X is pointing to FPN_3_exponent
              
              LDY usPointer
              DEY      

              ;copy FPN_1, FPN_2 and FPN_3 
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-              
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<-         
               
              BRSET flag4,#BIT1,key177_2_1       ;branch if in complex mode
              
              LBRA key177_3
              
key177_2_1:   LDD usPointer
              ADDD #$131B
              TFR D,X                            ;X is pointing to FPN_3_imaginary_exponent
              
              LDD usPointer
              ADDD #$1300
              TFR D,Y      

              ;copy FPN_1_imaginary, FPN_2_imaginary and FPN_3_imaginary 
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-              
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<-
              
              TFR Y,D
              SUBD #$1301
              TFR D,Y
              
              LBRA key177_4
              
key177_3:     BRSET flag4,#BIT2,key177_3_1       ;branch if in exact mode

              LBRA key177_4 

key177_3_1:   LDD usPointer
              ADDD #$13CF
              TFR D,X                            ;X is pointing to FPN_3_denominator_exponent
              
              LDD usPointer
              ADDD #$13B4
              TFR D,Y      

              ;FPN_1_denominator, FPN_2_denominator and FPN_3_denominator
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-              
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<-               
                            
              TFR Y,D
              SUBD #$13B5
              TFR D,Y
              
key177_4:     STY usPointer                                     
              
key177_exit:  JMP keyHdlr_1

;key178: push the stack depth onto the stack;;;;;;

DEPTH:        JSR calcDpt
              TAB                                ;B = depth of the stack       

              LDX #KeyNO              
              ABX                                
              LDAA 0,X                           ;A = BCD value of the stack depth
              
              LDY #m_comEnd
              
              STAA 0,Y                           ;LS byte of m_com = BCD value of the stack depth 
              
              MOVB #$02,noDigMan
              
              JMP Ente                           ;simulate "Enter" press
              
;key179: push FPN_1,FPN_2,FPN_3 and FPN_4 onto the stack

ENT4:         JSR calcDpt                        ;calculate the depth of the user stack and store it in A
              CMPA #$04
              BHS key179_1                       ;branch if the user stack is at least 4 levels deep 
              
              LBRA key179_exit                   ;otherwise exit        

key179_1:     CMPA #$10
              BLS key179_2                       ;branch if the user stack is at most 16 levels deep
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack 
              LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              
              BRCLR flag4,#BIT1,key179_1_1       ;branch if not in complex mode
              
              JSR resetStackImag                 ;otherwise copy the current imaginary values to the bottom of the 
                                                 ;user stack                                                  
              BRA key179_2
              
key179_1_1:   BRCLR flag4,#BIT2,key179_2         ;branch if not in exact mode
              
              JSR resetStackDenom                ;otherwise copy the current denominator values to the bottom of the 
                                                 ;user stack                  
key179_2:     LDX usPointer
              LDAB #$23
              ABX                                ;X is pointing to FPN_4_exponent
              
              LDY usPointer
              DEY      

              ;copy FPN_1, FPN_2, FPN_3 and FPN_4 
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-              
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<-       
               
              BRSET flag4,#BIT1,key179_2_1       ;branch if in complex mode
              
              LBRA key179_3
              
key179_2_1:   LDD usPointer
              ADDD #$1324
              TFR D,X                            ;X is pointing to FPN_4_imaginary_exponent 
              
              LDD usPointer
              ADDD #$1300
              TFR D,Y     

              ;copy FPN_1_imaginary, FPN_2_imaginary, FPN_3_imaginary and FPN_4_imaginary 
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-              
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<-              
              
              TFR Y,D
              SUBD #$1301
              TFR D,Y
              
              LBRA key179_4
              
key179_3:     BRSET flag4,#BIT2,key179_3_1       ;branch if in exact mode

              LBRA key179_4 

key179_3_1:   LDD usPointer
              ADDD #$13D8
              TFR D,X                            ;X is pointing to FPN_4_denominator_exponent
              
              LDD usPointer
              ADDD #$13B4
              TFR D,Y      

              ;copy FPN_1_denominator, FPN_2_denominator, FPN_3_denominator and FPN_4_denominator
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-              
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 1,X-
              STAA 1,Y-
              LDAA 0,X
              STAA 0,Y
              ;<-              
              
              TFR Y,D
              SUBD #$13B5
              TFR D,Y
              
key179_4:     STY usPointer                                     
              
key179_exit:  JMP keyHdlr_1

;key181: copy FPN_1 to xK;;;;;;;;;;;;;;;;;;;;;;;;;

TOXK:         BCLR flag4,#BIT7                   ;clear update screen flag

              JSR calcDpt
              TSTA
              BNE key181_1                       ;branch if the stack is not empty
              BRA key181_exit                    ;exit as the command line and stack are both empty               

key181_1:     JSR incK                           ;increment K 

              LDY #m_KEnd                        ;convert LS byte of K to binary and store in A ->                  

              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #$0A
              
              MUL                                ;10 * A -> A:B = 0:B since A <= 9 -> 10 * A <= 90 <= 255 
              
              LDAA 0,Y
              ANDA #$0F
              
              ABA                                ;A + B -> A, A <= 99 <-
              
              LDAB #$09
              
              MUL                                ;9 * A -> A:B, 9 * A <= 891
              
              ADDD #x0                           ;D = x0 + LS byte of K * 9
              
              MOVW usPointer,memAddr1
              STD memAddr2
              
              JSR copyFPN                        ;FPN_1 -> xK
              
key181_exit:  JMP keyHdlr_1

;key182: push xK onto the stack;;;;;;;;;;;;;;;;;;;

XKOUT:        LDD usPointer
              CPD #$2000
              BNE key182_1                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack
              
              BRA key182_2              
                   
key182_1:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
                     
key182_2:     LDY #m_KEnd                        ;convert LS byte of K to binary and store in A ->                  

              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #$0A
              
              MUL                                ;10 * A -> A:B = 0:B since A <= 9 -> 10 * A <= 90 <= 255 
              
              LDAA 0,Y
              ANDA #$0F
              
              ABA                                ;A + B -> A, A <= 99 <-
              
              LDAB #$09
              
              MUL                                ;9 * A -> A:B, 9 * A <= 891
              
              ADDD #x0                           ;D = x0 + LS byte of K * 9
              
              STD memAddr1
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;xK -> FPN_1
              
              JMP keyHdlr_1

;key183:INC K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;INCK:         JSR incK       

              ;JMP keyHdlr_1

;key184:DEC K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;DECK:         JSR decK       

              ;JMP keyHdlr_1

;key185: HALT program instruction;;;;;;;;;;;;;;;;;

HALT:         CALL key185SUB       

              JMP keyHdlr_1

;key186: DELAYK program instruction;;;;;;;;;;;;;;;

DLYK:         MOVW #m_K,memAddr1
              MOVW #m_a,memAddr2
              JSR copyMan                        ;m_a = m_K       

key186_1:     LDX #m_aEnd                        ;X points to LS byte of mantissa of m_a
              MOVB #$08,counter1

key186_2:     LDAA 1,X-
              BNE key186_3                       ;branch if m_a <> 0
              
              DEC counter1
              BNE key186_2
              
              BRA key186_exit                    ;m_a = 0 so exit
              
key186_3:     JSR delay                          ;delay K times
              JSR decFPN_a
              
              BRA key186_1
              
key186_exit:  JMP keyHdlr_1

;key187: BUSY ON program instruction;;;;;;;;;;;;;;

BUON:         ;BCLR PORTE,#BIT0                   ;turn on BUSY LED on pin PE0 
              ;BCLR PORTD,#BIT0                   ;turn on BUSY LED on pin PD0 (prototype) 

              JMP keyHdlr_1

;key188: BUSY OFF program instruction;;;;;;;;;;;;;

BUOFF:        ;BSET PORTE,#BIT0                   ;turn off BUSY LED on pin PE0
              ;BSET PORTD,#BIT0                   ;turn off BUSY LED on pin PD0 (prototype)       

              JMP keyHdlr_1

;key189: ERROR ON program instruction;;;;;;;;;;;;;

ERRON:        ;BCLR PORTE,#BIT1                   ;turn on ERROR LED on pin PE1
              ;BCLR PORTD,#BIT1                   ;turn on ERROR LED on pin PD1 (prototype) 

              JMP keyHdlr_1

;key190: ERROROFF program instruction;;;;;;;;;;;;;

ERROFF:       ;BSET PORTE,#BIT1                   ;turn off ERROR LED on pin PE1
              ;BSET PORTD,#BIT1                   ;turn off ERROR LED on pin PD1 (prototype)         

              JMP keyHdlr_1

;key191: SCAN KP program instruction;;;;;;;;;;;;;;

SCAN:         BCLR flag1,#BIT1                   ;clear the keyFound flag		  

              BCLR PT1AD0,#BIT0                  ;clear all keypad rows
              BCLR PT1AD0,#BIT1
              BCLR PT1AD0,#BIT2
              BCLR PT1AD0,#BIT3
              BCLR PT1AD0,#BIT4
              BCLR PT1AD0,#BIT5
              BCLR PT1AD0,#BIT6
              BCLR PT1AD0,#BIT7
                            
              LDAA PTP
              COMA                            
              BEQ key191_exit                    ;exit if keypad not pressed (A=0)                                             
              
              CALL scanKey2                      ;otherwise set keyFound flag, scan the keypad and record number 
                                                 ;of key pressed in keyNumber
key191_exit:  JMP keyHdlr_1

;key192: KEYNO-> program instruction;;;;;;;;;;;;;;

KNOUT:        LDX #KeyNO
              LDAB keyNumber2
              ABX                                
              LDAA 0,X                           ;A = BCD value of number pressed
              
              LDY #m_comEnd
              
              STAA 0,Y                           ;LS byte of m_com = BCD value of number pressed 
              
              MOVB #$02,noDigMan
              
              JMP Ente                           ;simulate "Enter" press
              
;key193: NOP program instruction;;;;;;;;;;;;;;;;;;

NOPINSTR:     JMP keyHdlr_1

;key194: sinh x;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SINH:         LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX     

              LDX #SNH
              DEX
              STX prgCounter                     ;prgCounter = SNH - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1

;key195: cosh x;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COSH:         LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX     

              LDX #CSH
              DEX
              STX prgCounter                     ;prgCounter = CSH - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1

;key196: tanh x;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TANH:         LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX     

              LDX #TNH
              DEX
              STX prgCounter                     ;prgCounter = TNH - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1

;key197: arcsinh x;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(no branching in program)

ASINH         LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX     

              LDX #ASHPrg
              DEX
              STX prgCounter                     ;prgCounter = ASHPrg - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1

;key198: arccosh x;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ACOSH:        LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX     

              LDX #ACHPrg
              DEX
              STX prgCounter                     ;prgCounter = ACHPrg - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1
              
;key199: arctanh x;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ATANH:        LDX prgCounter
              PSHX                   

              LDX prgCounterStM1
              PSHX           

              LDX #ATHPrg
              DEX
              STX prgCounter                     ;prgCounter = ATHPrg - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1

;key200: floor function;;;;;;;;;;;;;;;;;;;;;;;;;;;

FLOOR:        LDAA noDigMan
              BNE key200_0                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key200_4                       ;branch if the stack is not empty               
              BRA key200_exit                    ;exit as the command line and stack are both empty
              
key200_0:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key200_3         ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit  
              BRA key200_exit
              
key200_3:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack               
              
key200_4:     LDX usPointer
              LDAB #$08
              ABX                                ;X is pointing to exponent of FPN
              
              LDAA 0,X
              BPL key200_exit                    ;exit if FPN is an integer
              
              CLR 0,X                            ;otherwise set exponent to 0     

              NEGA                               ;negate the original exponent in A to make it positive
              PSHA                               ;push it onto the stack
              
              MOVW usPointer,memAddr1 
              JSR absFPN                         ;FPN set to absolute value and manNeg flag set if required
              
              PULA
              STAA counter3
              
key200_5:     JSR divMan10
              DEC counter3
              BNE key200_5                       ;shift FPN counter3 nibbles to the right

              BRCLR flag2,#BIT4,key200_exit      ;exit if manNeg flag clear

              JSR incFPN                         ;otherwise add 1 to FPN and negate before exiting
              JSR negFPN           

key200_exit:  JMP keyHdlr_1

;key201: return from subroutine program instruction

RetFS:        LDY prgStackPtr
              DEY
              DEY
              STY prgStackPtr
              
              LDD 0,Y
              STD prgCounter             

              JMP keyHdlr_1

;key202: |X| function;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MODX:         LDAA noDigMan
              BNE key202_0                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key202_4                       ;branch if the stack is not empty               
              BRA key202_exit                    ;exit as the command line and stack are both empty
              
key202_0:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key202_3         ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit  
              BRA key202_exit    
              
key202_3:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack               
              
key202_4:     LDX usPointer
              LDAA 0,X                           ;A = first byte of mantissa of FPN
              ANDA #$F0
              BEQ key202_exit                    ;exit as FPN is non-negative
              MOVW usPointer,memAddr1            ;otherwise negate FPN to make it positive
              JSR negFPN              

key202_exit:  JMP keyHdlr_1

;key203: set the random number seed;;;;;;;;;;;;;;;

SETRand:       LDAA noDigMan
              BNE key203_2                       ;branch if the command line is not empty 
              LDD usPointer
              CPD #ms_end
              BNE key203_1                       ;branch if the calculator stack is not empty 
              LBRA key203_exit                   ;otherwise the command line and calculator stack are both
                                                 ;empty so return to scanKey subroutine
              
key203_1:     MOVW usPointer,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key203_1_1                     ;continue if FPN_1 <> 0
              
              JSR dispError
              BRA key203_exit                    ;otherwise display "ERROR" and exit
              
key203_1_1:   MOVB #$08,lenMemBytes

              LDX usPointer
              STX memAddr2
              MOVW #rnSeed,memAddr1 
              JSR BCDToBin2                      ;mantissa of FPN_1 converted to binary and copied to rnSeed
              
              MOVB #$01,lenMemBytes
              
              BRA key203_exit 
              
key203_2:     MOVW #m_com,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key203_2_1                     ;continue if m_com <> 0
              
              JSR dispError
              BRA key203_exit                    ;otherwise display "ERROR" and exit

key203_2_1:   BRCLR flag3,#BIT3,key203_3         ;branch if not in Hex/Bin mode
              
              LDX #m_com
              STX memAddr1
              MOVW #rnSeed,memAddr2
              JSR copyMan                        ;m_com copied to rnSeed              
              
              JSR clrComLMem                     ;clear command line memory                         
              
              BRA key203_exit               
              
key203_3:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key203_4         ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit 
              BRA key203_exit
              
key203_4:     MOVB #$08,lenMemBytes  

              LDX m_com
              STX memAddr2
              MOVW #rnSeed,memAddr1 
              JSR BCDToBin2                      ;m_com converted to binary and copied to rnSeed
              
              MOVB #$01,lenMemBytes
              
              JSR clrComLMem                     ;clear command line memory          

key203_exit:  JMP keyHdlr_1

;key204: number of permutations;;;;;;;;;;;;;;;;;;;

PERMU:        LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX     

              LDX #PER
              DEX
              STX prgCounter                     ;prgCounter = PER - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1

;key205: number of combinations;;;;;;;;;;;;;;;;;;;

COMBI:        LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX     

              LDX #COM
              DEX
              STX prgCounter                     ;prgCounter = COM - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1

;key206: ceiling function;;;;;;;;;;;;;;;;;;;;;;;;;

CEIL:         LDAA noDigMan
              BNE key206_0                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key206_4                       ;branch if the stack is not empty               
              BRA key206_exit                    ;exit as the command line and stack are both empty
              
key206_0:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key206_3         ;branch if oFlow flag was not set
              
              JSR dispError                      ;otherwise display "ERROR" on the status line and exit  
              BRA key206_exit
              
key206_3:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack               
              
key206_4:     LDX usPointer
              LDAB #$08
              ABX                                ;X is pointing to exponent of FPN
              
              LDAA 0,X
              BPL key206_exit                    ;exit if FPN is an integer
              
              CLR 0,X                            ;otherwise set exponent to 0     

              NEGA                               ;negate the original exponent in A to make it positive
              PSHA                               ;push it onto the stack
              
              MOVW usPointer,memAddr1 
              JSR absFPN                         ;FPN set to absolute value and manNeg flag set if required
              
              PULA
              STAA counter3
              
key206_5:     JSR divMan10
              DEC counter3
              BNE key206_5                       ;shift FPN counter3 nibbles to the right
              
              BRCLR flag2,#BIT4,key206_6         ;branch if manNeg flag clear, i.e. if FPN was positive
                                      
              JSR negFPN                         ;otherwise negate before exiting
              
              BRA key206_exit 
              
key206_6:     JSR incFPN                    

key206_exit:  JMP keyHdlr_1                 
      
;key209: push the real and imaginary parts of FPN_1_complex onto the stack

CTOR:         LDD usPointer
              CPD #ms_end
              BEQ key209_exit                    ;exit if the stack is empty
              
              PSHD 
              
              ADDD #$1301                        ;D is equal to the address of FPN_1_imaginary
              STD memAddr1
              
              PULD
              PSHD
              
              SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              STD memAddr2
              
              JSR copyFPN                        ;FPN_1_imaginary is copied to level 2 of the user stack
              
              PULD
              PSHD
              
              ADDD #$1301                        ;D is equal to the address of FPN_1_imaginary
              
              TFR D,X                            
              
              CLRA
              MOVB #lenFPNBytes,counter1
              
key209_1:     STAA 1,X+                          ;set FPN_1_imaginary to 0 ->
              DEC counter1
              BNE key209_1                       ;<-
              
              PULD
              SUBD #lenFPNBytes 
              ADDD #$1301                        ;D is equal to the address of FPN_2_imaginary
              
              TFR D,X                            
              
              CLRA
              MOVB #lenFPNBytes,counter1
              
key209_2:     STAA 1,X+                          ;set FPN_2_imaginary to 0 ->
              DEC counter1
              BNE key209_2                       ;<-

key209_exit:  JMP keyHdlr_1

;key210: cartesian form of Z;;;;;;;;;;;;;;;;;;;;;; 

RECT:         JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$02
              BLT key210_exit                    ;exit if the user stack depth < 2
              
              LDX prgCounter
              PSHX                   

              LDX #CPXCarPrg
              DEX
              STX prgCounter                     ;prgCounter = CPXCarPrg - 1
              
              JSR exePrg
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag                      

key210_exit:  JMP keyHdlr_1 

;key211: push the mean of x onto the stack;;;;;;;;

MEANX:        LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX           

              LDX #MEANXPrg
              DEX
              STX prgCounter                     ;prgCounter = meanx - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1
              
;key212: GCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GrCD:         TST noDigMan
              BEQ key212_6                       ;branch if the command line is empty
              
              JSR calcDpt                        ;otherwise calculate the depth of the user stack and store it in A
              TSTA
              BNE key212_2
              LBRA key212_exit                   ;exit as the user stack is empty         
              
key212_2:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key212_3         ;branch if oFlow flag was not set
              
              JSR dispError
              LBRA key212_exit                   ;otherwise display "ERROR" on the status line and exit
              
key212_3:     LDD usPointer
              CPD #$2000
              BNE key212_4                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key212_5                          
                                                  
key212_4:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              
key212_5:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack  
               
              BRA key212_7                       
              
key212_6:     JSR calcDpt                        ;calculate the depth of the user stack and store it in A                          
              CMPA #$01
              BGT key212_7                       ;branch if the user stack depth > 1
              LBRA key212_exit                   ;return to scanKey subroutine as the user stack depth = 0 or 1
              
key212_7:     MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1 -> FPN_a
              
              LDD usPointer
              ADDD #$09
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_2 -> FPN_b
              
              MOVW #m_b,memAddr1
              
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key212_7_3                     ;continue if FPN_2 <> 0
              
              JSR dispError
              LBRA key212_exit                   ;otherwise display "ERROR" on the status line and exit              
              
key212_7_3:   JSR tzFPN_b                        ;eliminate trailing zeros in m_b
              
              JSR absFPN                         ;set m_b to absolute value if required
              
              MOVW #m_a,memAddr1
              
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE key212_7_4                     ;continue if FPN_1 <> 0
              
              JSR dispError
              LBRA key212_exit                   ;otherwise display "ERROR" on the status line and exit              
              
key212_7_4:   JSR tzFPN                          ;eliminate trailing zeros in m_a
              
              JSR absFPN                         ;set m_a to absolute value if required
              
              JSR cmpExp_ab                      ;compare exponents of FPN_a and FPN_b. FPN with larger exponent 
                                                 ;is copied to FPN_a and the other to FPN_b
              
              LDAA e_a
              BPL key212_7_1                     ;continue if FPN_a is an integer 
              
              JSR dispError
              LBRA key212_exit                   ;otherwise display "ERROR" and exit
              
key212_7_1:   LDAA e_b
              BPL key212_7_2                     ;continue if FPN_b is an integer 
              
              JSR dispError
              LBRA key212_exit                   ;otherwise display "ERROR" and exit
              
key212_7_2:   MOVB e_b,power                     ;result will be multiplied by 10^power
              
              LDAA e_a                           ;divide FPN_a,b by 10^power
              SUBA e_b
              STAA e_a
              
              CLR e_b
              
              JSR lzMan   
              
              LDAA noZero
              SUBA e_a
              DECA
              
              BPL key212_8
              
              JSR dispError
              LBRA key212_exit                   ;otherwise display "ERROR" and exit as FPN_a is too big
              
key212_8:     JSR GCDFPN_ab                      ;determine GCD of numerator and denominator and store BCD result
                                                 ;in m_a
              LDD usPointer
              ADDD #lenFPNBytes
              STD usPointer                      ;increment usPointer
              
              MOVW #m_a,memAddr1
              MOVW usPointer,memAddr2
              JSR copyFPN                        ;GCD copied to stack
              
              JSR clrComLMem

key212_exit:  JMP keyHdlr_1

;key213: LCM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LoCM:         LDX prgCounter
              PSHX
              
              LDX prgCounterStM1
              PSHX     

              LDX #LCMPrg
              DEX
              STX prgCounter                     ;prgCounter = LCMPrg - 1
              
              DEX 
              STX prgCounterStM1                 ;prgCounterStM1 used in GOTO and JUMPTOSUBTRE instructions
              
              JSR exePrg
              
              PULX
              STX prgCounterStM1  
              
              PULX
              STX prgCounter
              
              BSET flag4,#BIT7                   ;set the updtScreen flag
              
              JMP keyHdlr_1

;key222: indirect GOTO program instruction;;;;;;;

IGOTO:        LDX prgCounter
              INX
              
              LDAA 0,X                           ;A = hexadecimal keycode of variable storing the step to branch to
                                                 ;(e.g. A = $54 = 84 for Z->)              
              SUBA #$54
              
              LDAB #$09
              
              MUL
              
              ADDD #ms_end                       ;D is now pointing to the variable storing the step to branch to
              PSHD
              
              ;convert BCD value of the step stored in the variable to binary ->
              
              LDX #m_a
              STX memAddr1
                                          
              CLRA                               ;set 2 MS bytes of #m_a to 0 ->              
              STAA 1,X+
              STAA 0,X                           ;<-                                                          

              MOVB #$02,lenMemBytes              ;lenMemBytes = 2 for multBin10add subroutine 
              
              MOVB #$02,counter2                 ;multBin10add subroutine uses counter1

              PULY                               ;Y is pointing to the variable
              INY
              INY
              INY
              INY
              INY
              INY                                ;Y is pointing to the second LS byte of the variable 

key222_1:     LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              STAA keyValue                      ;keyValue = MS nibble of byte of variable

              JSR multBin10add                   ;multiply FPN_M1 = m_a by 10 and add keyValue

              LDAA 1,Y+

              ANDA #$0F
              STAA keyValue                      ;keyValue = LS nibble of byte of variable
              
              JSR multBin10add                   ;multiply FPN_M1 by 10 and add keyValue

              DEC counter2
              BNE key222_1
              
              MOVB #lenExpBytes,lenMemBytes      ;lenMemBytes = lenExpBytes to update value of exponent when entering
                                                 ;values on the command line
              ;<-               
                            
              INX              
              LDAA 1,X+                          ;A = MS byte of the binary value of the step 
              LDAB 0,X                           ;B = LS byte of the binary value of the step
              
              ADDD prgCounterStM1
              STD prgCounter                     ;prgCounter = program step address     
              
              JMP keyHdlr_1
              
;key223: indirect GOTO=0 program instruction;;;;;

IGOTO0:       MOVW usPointer,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BEQ IGOTO                          ;indirect GOTO if FPN_1 = 0
              
              LDD prgCounter
              ADDD #$0001
              STD prgCounter                     ;otherwise increment prgCounter by 1 and exit
              
              JMP keyHdlr_1
              
;key224: indirect GOTO<>0 program instruction;;;;

IGOTON0       MOVW usPointer,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBNE IGOTO                         ;indirect GOTO if FPN_1 <> 0
              
              LDD prgCounter
              ADDD #$0001
              STD prgCounter                     ;otherwise increment prgCounter by 1 and exit
              
              JMP keyHdlr_1

;key225: indirect GOTO = program instruction;;;;;;

IGOTOEQ:      MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b
              
              JSR subFPN                         ;FPN_a - FPN_b -> FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called                                         

              MOVW #m_a,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBEQ IGOTO                         ;indirect GOTO if FPN_a = FPN_b
              
              LDD prgCounter
              ADDD #$0001
              STD prgCounter                     ;otherwise increment prgCounter by 1 and exit
              
              JMP keyHdlr_1  

;key226: indirect GOTO <> program instruction;;;;;

IGOTONEQ:     MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b
              
              JSR subFPN                         ;FPN_a - FPN_b -> FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called                            

              MOVW #m_a,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBNE IGOTO                         ;indirect GOTO if FPN_a <> FPN_b
              
              LDD prgCounter
              ADDD #$0001
              STD prgCounter                     ;otherwise increment prgCounter by 1 and exit
              
              JMP keyHdlr_1

;key227: indirect GOTO > program instruction;;;;;;

IGOTOGT:      MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b            

              JSR cmpFPN_GE                      ;set ge flag if FPN_a >= FPN_b
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRSET flag5,#BIT0,key227_1         ;increment prgCounter by 1 and exit if FPN_b <= FPN_a
              
              LBRA IGOTO                         ;otherwise indirect GOTO
              
key227_1:     LDD prgCounter
              ADDD #$0001
              STD prgCounter                     
              
              JMP keyHdlr_1

;key228:indirect GOTO < program instruction;;;;;;;

IGOTOLT:      MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b            

              JSR cmpFPN_LE                      ;set le flag if FPN_b >= FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRSET flag5,#BIT1,key228_1         ;increment prgCounter by 1 and exit if FPN_a <= FPN_b
              
              LBRA IGOTO                         ;otherwise indirect GOTO
              
key228_1:     LDD prgCounter
              ADDD #$0001
              STD prgCounter                     
              
              JMP keyHdlr_1

;key229: indirect GOTO >= program instruction;;;;;

IGOTOGTE:     MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b            

              JSR cmpFPN_LE                      ;set le flag if FPN_b >= FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRCLR flag5,#BIT1,key229_1         ;increment prgCounter by 1 and exit if FPN_b < FPN_a
              
              LBRA IGOTO                         ;otherwise indirect GOTO
              
key229_1:     LDD prgCounter
              ADDD #$0001
              STD prgCounter                     
              
              JMP keyHdlr_1

;key230: indirect GOTO <= program instruction;;;;;

IGOTOLTE:     MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b            

              JSR cmpFPN_GE                      ;set ge flag if FPN_a >= FPN_b
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRCLR flag5,#BIT0,key230_1         ;increment prgCounter by 1 and exit if FPN_a < FPN_b
              
              LBRA IGOTO                         ;otherwise indirect GOTO
              
key230_1:     LDD prgCounter
              ADDD #$0001
              STD prgCounter                     
              
              JMP keyHdlr_1

;key231: indirect GOTOIFKP program instruction;;;

IGOTOKP:      BRCLR flag1,#BIT1,key231_1         ;increment prgCounter by 1 and exit if keyFound flag clear       

              LBRA IGOTO                         ;otherwise indirect GOTO
              
key231_1:     LDD prgCounter
              ADDD #$0001
              STD prgCounter
              
              JMP keyHdlr_1

;key232: indirect GOTO=xK program instruction;;;;;

IGOTOXK:      MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDY #m_KEnd                        ;convert LS byte of K to binary and store in A ->                  

              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #$0A
              
              MUL                                ;10 * A -> A:B = 0:B since A <= 9 -> 10 * A <= 90 <= 255 
              
              LDAA 0,Y
              ANDA #$0F
              
              ABA                                ;A + B -> A, A <= 99 <-
              
              LDAB #$09
              
              MUL                                ;9 * A -> A:B, 9 * A <= 891
              
              ADDD #x0                           ;D = x0 + LS byte of K * 9
              
              STD memAddr1                       
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;xK -> FPN_b            

              JSR subFPN                         ;FPN_a - FPN_b -> FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called                            

              MOVW #m_a,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBEQ IGOTO                         ;indirect GOTO if FPN_1 = xK
              
              LDD prgCounter
              ADDD #$0001
              STD prgCounter                     ;otherwise increment prgCounter by 1 and exit
              
              JMP keyHdlr_1          

;key233: indirect GOTO<>xK program instruction;;;;

IGOTONXK:     MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDY #m_KEnd                        ;convert LS byte of K to binary and store in A ->                  

              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #$0A
              
              MUL                                ;10 * A -> A:B = 0:B since A <= 9 -> 10 * A <= 90 <= 255 
              
              LDAA 0,Y
              ANDA #$0F
              
              ABA                                ;A + B -> A, A <= 99 <-
              
              LDAB #$09
              
              MUL                                ;9 * A -> A:B, 9 * A <= 891
              
              ADDD #x0                           ;D = x0 + LS byte of K * 9
              
              STD memAddr1                       
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;xK -> FPN_b            

              JSR subFPN                         ;FPN_a - FPN_b -> FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called

              MOVW #m_a,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBNE IGOTO                         ;indirect GOTO if FPN_1 <> xK
              
              LDD prgCounter
              ADDD #$0001
              STD prgCounter                     ;otherwise increment prgCounter by 1 and exit
              
              JMP keyHdlr_1

;key234: indirect GOTO>=xK program instruction;;;;

IGOTOGTEXK:   MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDY #m_KEnd                        ;convert LS byte of K to binary and store in A ->                  

              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #$0A
              
              MUL                                ;10 * A -> A:B = 0:B since A <= 9 -> 10 * A <= 90 <= 255 
              
              LDAA 0,Y
              ANDA #$0F
              
              ABA                                ;A + B -> A, A <= 99 <-
              
              LDAB #$09
              
              MUL                                ;9 * A -> A:B, 9 * A <= 891
              
              ADDD #x0                           ;D = x0 + LS byte of K * 9
              
              STD memAddr1                       
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;xK -> FPN_b            

              JSR cmpFPN_GE                      ;set ge flag if FPN_a >= FPN_b
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRCLR flag5,#BIT0,key234_1         ;increment prgCounter by 1 and exit if FPN_1 < xK
              
              LBRA IGOTO                         ;otherwise indirect GOTO
              
key234_1:     LDD prgCounter
              ADDD #$0001
              STD prgCounter                     
              
              JMP keyHdlr_1

;key235: indirect GOTO<=xK program instruction;;;;

IGOTOLTEXK:   MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDY #m_KEnd                        ;convert LS byte of K to binary and store in A ->                  

              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #$0A
              
              MUL                                ;10 * A -> A:B = 0:B since A <= 9 -> 10 * A <= 90 <= 255 
              
              LDAA 0,Y
              ANDA #$0F
              
              ABA                                ;A + B -> A, A <= 99 <-
              
              LDAB #$09
              
              MUL                                ;9 * A -> A:B, 9 * A <= 891
              
              ADDD #x0                           ;D = x0 + LS byte of K * 9
              
              STD memAddr1                       
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;xK -> FPN_b            

              JSR cmpFPN_LE                      ;set le flag if FPN_a <= FPN_b
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRCLR flag5,#BIT1,key235_1         ;increment prgCounter by 1 and exit if FPN_1 > xK
              
              LBRA IGOTO                         ;otherwise indirect GOTO
              
key235_1:     LDD prgCounter
              ADDD #$0001
              STD prgCounter                     
              
              JMP keyHdlr_1 

;key214: 

key214:       JMP keyHdlr_1

;key215:

key215:       JMP keyHdlr_1

;key216:

key216:       JMP keyHdlr_1

;key217: 2^x;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TWOPX:        LDAA noDigMan
              BNE key26S_1                       ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key26S_5                       ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key26S_7                      ;exit as the command line and stack are both empty
                                                
key26S_1:     JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key26S_2         ;branch if oFlow flag was not set
              
              LBRA key26S_6                      ;otherwise display "ERROR" on the status line and exit       

key26S_2:     LDD usPointer
              CPD #$2000
              BNE key26S_3                       ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key26S_4                         
                                                  
key26S_3:     SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key26S_4:     MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack         
                            
key26S_5:     MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1
              
              LDX #m_b                           ;FPN_b = 332.192809488665 ->
                                                 
              MOVB #$03,1,X+
              MOVB #$32,1,X+
              MOVB #$19,1,X+
              MOVB #$28,1,X+
              MOVB #$09,1,X+
              MOVB #$48,1,X+
              MOVB #$86,1,X+
              MOVB #$65,1,X+                     ;m_b = 03 32 19 28 09 48 86 65 
              
              MOVB #$F4,0,X                      ;e_b = -12

              JSR cmpFPN_GE                      ;sets ge flag if FPN_a >= FPN_b
                                                 ;i.e. if FPN_1 >= 332.192809488665 
              
              BRCLR flag5,#BIT0,key26S_5_2       ;branch if ge flag not set, i.e. if FPN_1 < 332.192809488665 
              
              BRCLR flag2,#BIT7,key26S_5_1       ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer  
              ADDD #lenFPNBytes
              STD usPointer       

key26S_5_1:   BRA key26S_6                       ;display "ERROR" on the status line and exit   
              
key26S_5_2:   MOVW #log2Values,logValues
              MOVW #negLog2Values,negLogValues   ;store address of special values used in expFPN subroutine   

              MOVW usPointer,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_1 = X
              
              JSR expFPN                         ;find 2^FPN_f and store the result in FPN_b 

              MOVW #m_b,memAddr1
              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_b -> FPN_1
              
              BRA key26S_7 

key26S_6:     JSR dispError                      ;display "ERROR" on the status line and exit
  
key26S_7:     JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine

;key218: LD X;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LD:           BRCLR flag3,#BIT2,key26_0          ;branch if not in hex mode

              MOVB #$0D,keyValue
              JSR nzKey
              JMP keyHdlr_1                      ;otherwise update command line and return to scanKey subroutine         

key26_0:      LDAA noDigMan
              BNE key26_1                        ;branch if the command line is not empty
              
              JSR calcDpt
              TSTA
              BNE key26_5                        ;branch if the stack is not empty
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              LBRA key26_7                       ;exit as the command line and stack are both empty
              
key26_1:      JSR chkCom                         ;negate the mantissa/exponent of the value entered on the command
                                                 ;line as required and check for overflow and underflow
                                                               
              BRCLR flag2,#BIT5,key26_2          ;branch if oFlow flag was not set
              
              LBRA key26_6                       ;otherwise display "ERROR" on the status line and exit       

key26_2:      LDD usPointer
              CPD #$2000
              BNE key26_3                        ;branch if the top of the user stack has not yet been reached
              
              JSR resetStack                     ;otherwise copy the current values to the bottom of the user stack                
              BRA key26_4                         
                                                  
key26_3:      SUBD #lenFPNBytes
              STD usPointer                      ;decrement usPointer
              BSET flag2,#BIT7                   ;set the usPDec flag                           
              
key26_4:      MOVW #m_com,memAddr1                  
              MOVW usPointer,memAddr2
              
              JSR copyFPN                        ;command line value copied to the user stack      
              
key26_5:      MOVW usPointer,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_1
              
              LDX usPointer
              LDAA 0,X                           ;A = MS byte of FPN_1
              ANDA #$F0
              LBNE key26_6                       ;display "ERROR" on the status line and exit if FPN_1 < 0

              JSR lzMan
              LDAB noZero
              CMPB #lenMan
              BEQ key26_6                        ;display "ERROR" on the status line and exit if FPN_1 = 0
              
              MOVW #m_f,memAddr1              
              JSR tzFPN_f                        ;eliminate trailing zeros in FPN_f = FPN_1
              LDX #m_fEnd                       
              LDAA 1,X+                          ;A = LS byte of FPN_f
              DECA
              BNE key26_5_1                      ;branch if A <> 1
              LDAA 0,X
              BNE key26_5_1                      ;branch if A <> 0
              
              LDX usPointer                      ;otherwise FPN_f = 1, so set FPN_1 to 0 and exit
              
              MOVB #lenFPNBytes,counter1
              
key26_5_0:    CLR 1,X+                           ;set FPN_1 = 0 ->
              DEC counter1
              BNE key26_5_0                      ;<-
              
              BRA key26_7                        ;exit
              
key26_5_1:    MOVW #log2Values,logValues         ;store address of special ld values used in logFPN subroutine
              MOVW #log2Ten,logbTen              
              
              JSR lzMan
              LDAB noZero                        ;require B = noZero in FPN_f before calling logFPN subroutine
              
              JSR logFPN                         ;find the logarithm of FPN_f and store in FPN_a

              MOVW usPointer,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_1
              
              BRA key26_7 

key26_6:      BRCLR flag2,#BIT7,key26_6_1        ;branch if the usPDec flag was not set

              LDD usPointer                      ;otherwise increment usPointer first 
              ADDD #lenFPNBytes
              STD usPointer            

key26_6_1:    JSR dispError                      ;display "ERROR" on the status line and exit
  
key26_7:      JSR clrComLMem                     ;clear command line memory     

              JMP keyHdlr_1                      ;return to scanKey subroutine

;key219: copy FPN_1 to y(K);;;;;;;;;;;;;;;;;;;;;;;

TOYK:         JMP keyHdlr_1

;key220: push y(K) onto the stack;;;;;;;;;;;;;;;;;

YKOUT:        JMP keyHdlr_1

;key221:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key221:       JMP keyHdlr_1

;key222:

key222:       JMP keyHdlr_1

;key223:

key223:       JMP keyHdlr_1

;key224:

key224:       JMP keyHdlr_1

;key225:

key225:       JMP keyHdlr_1

;key226:

key226:       JMP keyHdlr_1

;key227:

key227:       JMP keyHdlr_1

;key228:

key228:       JMP keyHdlr_1

;key229:

key229:       JMP keyHdlr_1

;key230:

key230:       JMP keyHdlr_1

;key231:

key231:       JMP keyHdlr_1

;key232:

key232:       JMP keyHdlr_1

;key233:

key233:       JMP keyHdlr_1

;key234:

key234:       JMP keyHdlr_1

;key235:

key235:       JMP keyHdlr_1

;key236: reserved for future 2 byte instructions starting $EC

EC2BYTE:      JMP keyHdlr_1

;key237: reserved for future 2 byte instructions starting $ED

ED2BYTE:      JMP keyHdlr_1

;key238: reserved for future 2 byte instructions starting $EE

EE2BYTE:      JMP keyHdlr_1

;key239: $EF - first byte of 2 byte instruction (EF00, EF01,...,EFFE, EFFF except EFEC, EFED, EFEE and EFEF)

EF2BYTE:      LDX #keyTable2ByteEF

              LDD prgCounter                     ;increment prgCounter
              ADDD #$0001
              STD prgCounter

              LDY prgCounter
              LDAB 0,Y                           ;(prgCounter) -> B
              CLRA
              
              ASLD                               ;multiply D by 2
              
              JMP [D,X]              
              
;key240: GOTO program instruction;;;;;;;;;;;;;;;;;

GOTO:         LDX prgCounter
              INX
              INX
              INX                                ;X = address of byte equal to MS byte of step                     
                     
              LDAA 0,X                           ;A = MS byte of step
              
              INX                                ;X = address of byte equal to LS byte of step
              
              LDAB 0,X                           ;B = LS byte of step (i.e. D = step in hexadecimal) 
              
              ADDD prgCounterStM1
              STD prgCounter                     ;prgCounter = program step address     
              
              JMP keyHdlr_1

;key241: GOTO=0 program instruction;;;;;;;;;;;;;;;

GOTO0:        MOVW usPointer,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BEQ GOTO                           ;GOTO if FPN_1 = 0
              
              LDD prgCounter
              ADDD #$0004
              STD prgCounter                     ;otherwise increment prgCounter by 4 and exit
              
              JMP keyHdlr_1
               
;key242: GOTO<>0 program instruction;;;;;;;;;;;;;;

GOTON0:       MOVW usPointer,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE GOTO                           ;GOTO if FPN_1 <> 0
              
              LDD prgCounter
              ADDD #$0004
              STD prgCounter                     ;otherwise increment prgCounter by 4 and exit
              
              JMP keyHdlr_1
                            
;key243: GOTO = program instruction;;;;;;;;;;;;;;;

GOTOEQ:       MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b
              
              JSR subFPN                         ;FPN_a - FPN_b -> FPN_a 
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called                           

              MOVW #m_a,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBEQ GOTO                          ;GOTO if FPN_a = FPN_b
              
              LDD prgCounter
              ADDD #$0004
              STD prgCounter                     ;otherwise increment prgCounter by 4 and exit
              
              JMP keyHdlr_1              

;key244: GOTO <> program instruction;;;;;;;;;;;;;;

GOTONEQ:      MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b
              
              JSR subFPN                         ;FPN_a - FPN_b -> FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called                            

              MOVW #m_a,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBNE GOTO                          ;GOTO if FPN_a <> FPN_b
              
              LDD prgCounter
              ADDD #$0004
              STD prgCounter                     ;otherwise increment prgCounter by 4 and exit
              
              JMP keyHdlr_1

;key245: GOTO > program instruction;;;;;;;;;;;;;;;

GOTOGT:       MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b            

              JSR cmpFPN_GE                      ;set ge flag if FPN_a >= FPN_b
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRSET flag5,#BIT0,key245_1         ;increment prgCounter by 4 and exit if FPN_b <= FPN_a
              
              LBRA GOTO                          ;otherwise GOTO
              
key245_1:     LDD prgCounter
              ADDD #$0004
              STD prgCounter                     
              
              JMP keyHdlr_1

;key246: GOTO < program instruction;;;;;;;;;;;;;;;

GOTOLT:       MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b            

              JSR cmpFPN_LE                      ;set le flag if FPN_b >= FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRSET flag5,#BIT1,key246_1         ;increment prgCounter by 4 and exit if FPN_a <= FPN_b
              
              LBRA GOTO                          ;otherwise GOTO
              
key246_1:     LDD prgCounter
              ADDD #$0004
              STD prgCounter                     
              
              JMP keyHdlr_1

;key247: GOTO >= program instruction;;;;;;;;;;;;;;

GOTOGTE:      MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b            

              JSR cmpFPN_LE                      ;set le flag if FPN_b >= FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRCLR flag5,#BIT1,key247_1         ;increment prgCounter by 4 and exit if FPN_b < FPN_a
              
              LBRA GOTO                          ;otherwise GOTO
              
key247_1:     LDD prgCounter
              ADDD #$0004
              STD prgCounter                     
              
              JMP keyHdlr_1

;key248: GOTO <= program instruction;;;;;;;;;;;;;;

GOTOLTE:      MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDD usPointer
              ADDD #lenFPNBytes
              
              STD memAddr1
              
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;FPN_2 -> FPN_b            

              JSR cmpFPN_GE                      ;set ge flag if FPN_a >= FPN_b
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRCLR flag5,#BIT0,key248_1         ;increment prgCounter by 4 and exit if FPN_a < FPN_b
              
              LBRA GOTO                          ;otherwise GOTO
              
key248_1:     LDD prgCounter
              ADDD #$0004
              STD prgCounter                     
              
              JMP keyHdlr_1

;key249: GOTOIFKP program instruction;;;;;;;;;;;;;

GOTOKP:       BRCLR flag1,#BIT1,key249_1         ;increment prgCounter by 4 and exit if keyFound flag clear       

              LBRA GOTO                          ;otherwise GOTO
              
key249_1:     LDD prgCounter
              ADDD #$0004
              STD prgCounter
              
              JMP keyHdlr_1
              
;key250: GOTO=xK program instruction;;;;;;;;;;;;;;

GOTOXK:       MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDY #m_KEnd                        ;convert LS byte of K to binary and store in A ->                  

              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #$0A
              
              MUL                                ;10 * A -> A:B = 0:B since A <= 9 -> 10 * A <= 90 <= 255 
              
              LDAA 0,Y
              ANDA #$0F
              
              ABA                                ;A + B -> A, A <= 99 <-
              
              LDAB #$09
              
              MUL                                ;9 * A -> A:B, 9 * A <= 891
              
              ADDD #x0                           ;D = x0 + LS byte of K * 9
              
              STD memAddr1                       
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;xK -> FPN_b            

              JSR subFPN                         ;FPN_a - FPN_b -> FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called                            

              MOVW #m_a,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBEQ GOTO                          ;GOTO if FPN_1 = xK
              
              LDD prgCounter
              ADDD #$0004
              STD prgCounter                     ;otherwise increment prgCounter by 4 and exit
              
              JMP keyHdlr_1           

;key251: GOTO<>xK program instruction;;;;;;;;;;;;;

GOTONXK:      MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDY #m_KEnd                        ;convert LS byte of K to binary and store in A ->                  

              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #$0A
              
              MUL                                ;10 * A -> A:B = 0:B since A <= 9 -> 10 * A <= 90 <= 255 
              
              LDAA 0,Y
              ANDA #$0F
              
              ABA                                ;A + B -> A, A <= 99 <-
              
              LDAB #$09
              
              MUL                                ;9 * A -> A:B, 9 * A <= 891
              
              ADDD #x0                           ;D = x0 + LS byte of K * 9
              
              STD memAddr1                       
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;xK -> FPN_b            

              JSR subFPN                         ;FPN_a - FPN_b -> FPN_a
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called

              MOVW #m_a,memAddr1
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              LBNE GOTO                          ;GOTO if FPN_1 <> xK
              
              LDD prgCounter
              ADDD #$0004
              STD prgCounter                     ;otherwise increment prgCounter by 4 and exit
              
              JMP keyHdlr_1

;key252: GOTO>=xK program instruction;;;;;;;;;;;;;

GOTOGTEXK:    MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDY #m_KEnd                        ;convert LS byte of K to binary and store in A ->                  

              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #$0A
              
              MUL                                ;10 * A -> A:B = 0:B since A <= 9 -> 10 * A <= 90 <= 255 
              
              LDAA 0,Y
              ANDA #$0F
              
              ABA                                ;A + B -> A, A <= 99 <-
              
              LDAB #$09
              
              MUL                                ;9 * A -> A:B, 9 * A <= 891
              
              ADDD #x0                           ;D = x0 + LS byte of K * 9
              
              STD memAddr1                       
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;xK -> FPN_b            

              JSR cmpFPN_GE                      ;set ge flag if FPN_a >= FPN_b
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRCLR flag5,#BIT0,key252_1         ;increment prgCounter by 4 and exit if FPN_1 < xK
              
              LBRA GOTO                          ;otherwise GOTO
              
key252_1:     LDD prgCounter
              ADDD #$0004
              STD prgCounter                     
              
              JMP keyHdlr_1
               
;key253: GOTO<=xK program instruction;;;;;;;;;;;;;

GOTOLTEXK:    MOVW usPointer,memAddr1
              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_1 -> FPN_a       

              LDY #m_KEnd                        ;convert LS byte of K to binary and store in A ->                  

              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #$0A
              
              MUL                                ;10 * A -> A:B = 0:B since A <= 9 -> 10 * A <= 90 <= 255 
              
              LDAA 0,Y
              ANDA #$0F
              
              ABA                                ;A + B -> A, A <= 99 <-
              
              LDAB #$09
              
              MUL                                ;9 * A -> A:B, 9 * A <= 891
              
              ADDD #x0                           ;D = x0 + LS byte of K * 9
              
              STD memAddr1                       
              MOVW #m_b,memAddr2
              
              JSR copyFPN                        ;xK -> FPN_b            

              JSR cmpFPN_LE                      ;set le flag if FPN_a <= FPN_b
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set when subFPN subroutine called
              
              BRCLR flag5,#BIT1,key253_1         ;increment prgCounter by 4 and exit if FPN_1 > xK
              
              LBRA GOTO                          ;otherwise GOTO
              
key253_1:     LDD prgCounter
              ADDD #$0004
              STD prgCounter                     
              
              JMP keyHdlr_1 

;key254: GOTOIFCOMLEMP program instruction;;;;;;;; 

GOTOCOMLE:    LDAA noDigMan
              BNE GOTOCOMLE_NOTEMPTY             ;increment prgCounter by 4 and exit if command line is not empty                

              LBRA GOTO                          ;otherwise GOTO
              
GOTOCOMLE_NOTEMPTY:     
              LDD prgCounter
              ADDD #$0004
              STD prgCounter
              
              JMP keyHdlr_1

;key255: jump to subroutine program instruction;;;

JUMPSR:       LDX prgCounter
              INX
              INX
              INX                                ;X = address of byte equal to MS byte of step                     
                     
              LDAA 0,X                           ;A = MS byte of step
              
              INX                                ;X = address of byte equal to LS byte of step
              
              LDAB 0,X                           ;B = LS byte of step (i.e. D = step in hexadecimal)
              
              LDY prgStackPtr
              STX 2,Y+                           ;the address to return to after the subroutine is executed is 
                                                 ;pushed onto the program stack
              STY prgStackPtr     
              
              ADDD prgCounterStM1
              STD prgCounter                     ;prgCounter = program step address      
              
              JMP keyHdlr_1

;keyEF0: set DEG mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

SDEGM:        BCLR flag4,#BIT4                   ;clear rad flag 
              BCLR flag1,#BIT6                   ;clear grad flag

              JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF1: set RAD mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SRADM:        BSET flag4,#BIT4                   ;set grad flag 
              BCLR flag1,#BIT6                   ;clear grad flag
              
              JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF2: set GRA mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SGRAM:        BCLR flag4,#BIT4                   ;clear rad flag 
              BSET flag1,#BIT6                   ;set grad flag
              
              JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF3: set ~ mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SAPPRM:       BCLR flag4,#BIT2                   ;clear exact flag
              BCLR flag3,#BIT2                   ;clear hex flag
              BCLR flag4,#BIT1                   ;clear the cpx flag 
              BCLR flag4,#BIT0                   ;clear bin flag
              BCLR flag3,#BIT3                   ;clear hex/bin flag
              BCLR flag5,#BIT7                   ;clear 2-adic flag 
              
              CALL setUserStk                    ;set the user stack to decimal      

              JMP keyHdlr_1
              
;keyEF4: set = mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SEXACM:       BSET flag4,#BIT2                   ;set exact flag

              BCLR flag3,#BIT2                   ;clear hex flag
              BCLR flag4,#BIT1                   ;clear the cpx flag 
              BCLR flag4,#BIT0                   ;clear bin flag
              BCLR flag3,#BIT3                   ;clear hex/bin flag
              
              CALL setDenomStk                   ;set the numerators and denominators   

              JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF5: set CPX mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SCPXM:        BSET flag4,#BIT1                   ;set the cpx flag       

              BCLR flag3,#BIT2                   ;clear hex flag
              BCLR flag4,#BIT2                   ;clear exact flag
              BCLR flag4,#BIT0                   ;clear bin flag
              BCLR flag3,#BIT3                   ;clear hex/bin flag 
              BCLR flag5,#BIT7                   ;clear 2-adic flag      

              JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF6: set ENG mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SENGM:        JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF7: select number of decimal places to be displayed (FIX)

FIXM:         JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF8: display "ERROR" and terminate program execution

ERRORTRAP:    JSR dispError

;keyEF9: set HEX mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SHEXM:        BSET flag3,#BIT2                   ;set hex flag
              BSET flag3,#BIT3                   ;set hex/bin flag

              BCLR flag4,#BIT2                   ;clear exact flag
              BCLR flag4,#BIT0                   ;clear bin flag              
              BCLR flag4,#BIT1                   ;clear cpx flag
              BCLR flag5,#BIT7                   ;clear 2-adic flag 
              
              JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF10: set DEC mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SDECM:        BCLR flag3,#BIT2                   ;clear hex flag
              BCLR flag4,#BIT2                   ;clear exact flag
              BCLR flag4,#BIT0                   ;clear bin flag              
              BCLR flag4,#BIT1                   ;clear cpx flag               
              BCLR flag3,#BIT3                   ;clear hex/bin flag
              BCLR flag1,#BIT3                   ;clear sci flag
              BCLR flag5,#BIT7                   ;clear 2-adic flag  

              JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF11: set BIN mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SBINM:        BSET flag4,#BIT0                   ;set bin flag
              BSET flag3,#BIT3                   ;set hex/bin flag

              BCLR flag4,#BIT2                   ;clear exact flag
              BCLR flag3,#BIT2                   ;clear hex flag              
              BCLR flag4,#BIT1                   ;clear cpx flag
              BCLR flag5,#BIT7                   ;clear 2-adic flag      

              JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF12: set SCI mode;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SSCIM:        BSET flag1,#BIT3                   ;set sci flag

              BCLR flag3,#BIT2                   ;clear hex flag
              BCLR flag4,#BIT2                   ;clear exact flag
              BCLR flag4,#BIT0                   ;clear bin flag              
              BCLR flag4,#BIT1                   ;clear cpx flag               
              BCLR flag3,#BIT3                   ;clear hex/bin flag
              BCLR flag5,#BIT7                   ;clear 2-adic flag   

              JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF13: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

keyEF13:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF14: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

keyEF14:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF15: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

keyEF15:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF16: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

keyEF16:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF17: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

keyEF17:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF18:

keyEF18:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF19:

keyEF19:      JMP keyHdlr_1                      ;return to scanKey subroutine   

;keyEF20: 

keyEF20:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF21: 

keyEF21:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF22:

keyEF22:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF23:

keyEF23:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF24:

keyEF24:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF25:

keyEF25:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF26:

keyEF26:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF27:

keyEF27:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF28:

keyEF28:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF29:

keyEF29:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF30: 

keyEF30:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF31: 

keyEF31:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF32:

keyEF32:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF33:

keyEF33:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF34:

keyEF34:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF35:

keyEF35:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF36:

keyEF36:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF37:

keyEF37:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF38:

keyEF38:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF39:

keyEF39:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF40: 

keyEF40:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF41: 

keyEF41:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF42:

keyEF42:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF43:

keyEF43:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF44:
       
keyEF44:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF45:

keyEF45:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF46:

keyEF46:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF47:

keyEF47:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF48:

keyEF48:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF49:

keyEF49:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF50:

keyEF50:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF51: 

keyEF51:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF52:

keyEF52:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF53:

keyEF53:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF54:
       
keyEF54:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF55:

keyEF55:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF56:

keyEF56:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF57:

keyEF57:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF58:

keyEF58:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF59:

keyEF59:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF60:

keyEF60:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF61: 

keyEF61:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF62:

keyEF62:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF63:

keyEF63:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF64:
       
keyEF64:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF65:

keyEF65:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF66:

keyEF66:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF67:

keyEF67:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF68:

keyEF68:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF69:

keyEF69:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF70:

keyEF70:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF71: 

keyEF71:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF72:

keyEF72:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF73:

keyEF73:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF74:
       
keyEF74:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF75:

keyEF75:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF76:

keyEF76:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF77:

keyEF77:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF78:

keyEF78:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF79:

keyEF79:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF80:

keyEF80:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF81: 

keyEF81:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF82:

keyEF82:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF83:

keyEF83:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF84:
       
keyEF84:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF85:

keyEF85:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF86:

keyEF86:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF87:

keyEF87:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF88:

keyEF88:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF89:

keyEF89:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF90:

keyEF90:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF91: 

keyEF91:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF92:

keyEF92:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF93:

keyEF93:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF94:
       
keyEF94:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF95:

keyEF95:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF96:

keyEF96:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF97:

keyEF97:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF98:

keyEF98:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF99:

keyEF99:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF100: 

keyEF100:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF101: 

keyEF101:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF102: 

keyEF102:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF103: 

keyEF103:      JMP keyHdlr_1                      ;return to scanKey subroutine
              
;keyEF104: 

keyEF104:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF105: 

keyEF105:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF106: 

keyEF106:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF107:
 
keyEF107:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF108: 

keyEF108:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF109: 

keyEF109:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF110: 

keyEF110:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF111: 

keyEF111:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF112:

keyEF112:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF113:

keyEF113:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF114:

keyEF114:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF115:

keyEF115:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF116:

keyEF116:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF117:

keyEF117:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF118:

keyEF118:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF119:

keyEF119:      JMP keyHdlr_1                      ;return to scanKey subroutine   

;keyEF120: 

keyEF120:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF121: 

keyEF121:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF122:

keyEF122:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF123:

keyEF123:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF124:

keyEF124:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF125:

keyEF125:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF126:

keyEF126:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF127:

keyEF127:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF128:

keyEF128:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF129:

keyEF129:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF130: 

keyEF130:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF131: 

keyEF131:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF132:

keyEF132:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF133:

keyEF133:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF134:

keyEF134:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF135:

keyEF135:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF136:

keyEF136:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF137:

keyEF137:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF138:

keyEF138:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF139:

keyEF139:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF140: 

keyEF140:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF141: 

keyEF141:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF142:

keyEF142:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF143:

keyEF143:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF144:
       
keyEF144:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF145:

keyEF145:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF146:

keyEF146:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF147:

keyEF147:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF148:

keyEF148:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF149:

keyEF149:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF150:

keyEF150:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF151: 

keyEF151:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF152:

keyEF152:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF153:

keyEF153:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF154:
       
keyEF154:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF155:

keyEF155:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF156:

keyEF156:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF157:

keyEF157:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF158:

keyEF158:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF159:

keyEF159:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF160:

keyEF160:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF161: 

keyEF161:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF162:

keyEF162:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF163:

keyEF163:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF164:
       
keyEF164:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF165:

keyEF165:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF166:

keyEF166:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF167:

keyEF167:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF168:

keyEF168:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF169:

keyEF169:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF170:

keyEF170:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF171: 

keyEF171:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF172:

keyEF172:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF173:

keyEF173:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF174:
       
keyEF174:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF175:

keyEF175:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF176:

keyEF176:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF177:

keyEF177:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF178:

keyEF178:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF179:

keyEF179:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF180:

keyEF180:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF181: 

keyEF181:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF182:

keyEF182:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF183:

keyEF183:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF184:
       
keyEF184:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF185:

keyEF185:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF186:

keyEF186:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF187:

keyEF187:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF188:

keyEF188:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF189:

keyEF189:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF190:

keyEF190:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF191: 

keyEF191:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF192:

keyEF192:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF193:

keyEF193:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF194:
       
keyEF194:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF195:

keyEF195:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF196:

keyEF196:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF197:

keyEF197:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF198:

keyEF198:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF199:

keyEF199:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF200: 

keyEF200:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF201: 

keyEF201:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF202: 

keyEF202:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF203: 

keyEF203:      JMP keyHdlr_1                      ;return to scanKey subroutine
              
;keyEF204: 

keyEF204:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF205: 

keyEF205:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF206: 

keyEF206:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF207:
 
keyEF207:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF208: 

keyEF208:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF209: 

keyEF209:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF210: 

keyEF210:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF211: 

keyEF211:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF212:

keyEF212:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF213:

keyEF213:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF214:

keyEF214:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF215:

keyEF215:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF216:

keyEF216:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF217:

keyEF217:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF218:

keyEF218:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF219:

keyEF219:      JMP keyHdlr_1                      ;return to scanKey subroutine   

;keyEF220: 

keyEF220:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF221: 

keyEF221:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF222:

keyEF222:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF223:

keyEF223:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF224:

keyEF224:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF225:

keyEF225:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF226:

keyEF226:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF227:

keyEF227:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF228:

keyEF228:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF229:

keyEF229:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF230: 

keyEF230:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF231: 

keyEF231:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF232:

keyEF232:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF233:

keyEF233:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF234:

keyEF234:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF235:

keyEF235:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF236:

keyEF236:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF237:

keyEF237:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF238:

keyEF238:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF239:

keyEF239:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF240: 

keyEF240:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF241: 

keyEF241:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF242:

keyEF242:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF243:

keyEF243:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF244:
       
keyEF244:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF245:

keyEF245:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF246:

keyEF246:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF247:

keyEF247:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF248:

keyEF248:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF249:

keyEF249:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF250:

keyEF250:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF251: 

keyEF251:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF252:

keyEF252:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF253:

keyEF253:      JMP keyHdlr_1                      ;return to scanKey subroutine

;keyEF254:
       
keyEF254:      JMP keyHdlr_1                      ;return to scanKey subroutine 

;keyEF255:

keyEF255:      JMP keyHdlr_1                      ;return to scanKey subroutine 

              
;*************************************************              
              
              ORG $C000
              
;keyHdlr: computed GOTO table;;;;;;;;;;;;;;;;;;;;;
              
keyHdlr:      JMP [D,X]
              
keyTable      DC.W Add                           ;(0) ADDITION
              DC.W Dele                          ;(1) DELETE  
              DC.W DePo                          ;(2) DECIMAL POINT 
              DC.W Zero                          ;(3) 0 
              DC.W PlMi                          ;(4) +/-
              DC.W NOKEY                         ;(5) NOKEY
              DC.W Minu                          ;(6) SUBTRACTION
              DC.W Thre                          ;(7) 3
              DC.W Two                           ;(8) 2
              DC.W One                           ;(9) 1
              DC.W ExpE                          ;(10) EXP
              DC.W NOKEY                         ;(11) NOKEY
              DC.W Mult                          ;(12) MULTIPLICATION
              DC.W Six                           ;(13) 6
              DC.W Five                          ;(14) 5
              DC.W Four                          ;(15) 4                       
              DC.W Ente                          ;(16) ENTER
              DC.W NOKEY                         ;(17) NOKEY
              DC.W Divi                          ;(18) DIVISION
              DC.W Nine                          ;(19) 9
              DC.W Eigh                          ;(20) 8
              DC.W Seve                          ;(21) 7
              DC.W Shif                          ;(22) SHIFT
              DC.W NOKEY                         ;(23) NOKEY
              DC.W TenPX                         ;(24) F/10^x
              DC.W EPX                           ;(25) E/e^x
              DC.W PI                            ;(26) D/pi
              DC.W TanX                          ;(27) C/tan
              DC.W CosX                          ;(28) B/cos
              DC.W SinX                          ;(29) A/sin
              DC.W OneOX                         ;(30) 1/x
              DC.W XPY                           ;(31) x^y
              DC.W XSQ                           ;(32) x^2
              DC.W HEX                           ;(33) Hex
              DC.W DECI                          ;(34) Dec
              DC.W BIN                           ;(35) Bin
              DC.W EXIT                          ;(36) Exit
              DC.W DOWN                          ;(37) Down
			        DC.W UP                            ;(38) Up
              DC.W RIGHT                         ;(39) Right
              DC.W LEFT                          ;(40) Left
              DC.W NEXT                          ;(41) Next
              DC.W M6                            ;(42) M6
              DC.W M5                            ;(43) M5
              DC.W M4                            ;(44) M4
              DC.W M3                            ;(45) M3
              DC.W M2                            ;(46) M2
              DC.W M1                            ;(47) M1 (2*47=94)
              
                                                 ;Shift ->
              DC.W key48                         ;(48)               
              DC.W Clea                          ;(49) CLEAR 
              DC.W EQN                           ;(50) EQN folder
              DC.W STAT                          ;(51) STAT folder
              DC.W STAK                          ;(52) STAK folder
              DC.W NOKEY                         ;(53) NOKEY
              DC.W key54                         ;(54)
              DC.W PROB                          ;(55) PROB folder
              DC.W POLY                          ;(56) POLY folder
              DC.W OPRE                          ;(57) OPRE folder
              DC.W Pick                          ;(58) Pick
              DC.W NOKEY                         ;(59) NOKEY
              DC.W STO                           ;(60) STO
              DC.W NUMB                          ;(61) NUMB folder
              DC.W MATR                          ;(62) MATR folder
              DC.W FUNC                          ;(63) FUNC folder
              DC.W Swapp                         ;(64) SWAP
              DC.W NOKEY                         ;(65) NOKEY
              DC.W RECL                          ;(66) RCL
              DC.W FINA                          ;(67) FINA folder
              DC.W CPLX                          ;(68) CPLX folder
              DC.W CALC                          ;(69) CALC folder
              DC.W UShift                        ;(70) undo shift
              DC.W NOKEY                         ;(71) NOKEY
              DC.W LOGX                          ;(72) log x
              DC.W LNX                           ;(73) ln x
              DC.W Rand                          ;(74) Random
              DC.W ATAN                          ;(75) arctan x
              DC.W ACOS                          ;(76) arccos x
              DC.W ASIN                          ;(77) arcsin x
              DC.W FACT                          ;(78) !
              DC.W XPOY                          ;(79) x^(1/y)
              DC.W SQRT                          ;(80) x^(1/2)
              DC.W GRPH                          ;(81) GRPH folder
              DC.W DDMS                          ;(82) -> DMS
              DC.W DMSD                          ;(83) DMS ->              
              DC.W SYS                           ;(84) SYS folder
              DC.W ASM                           ;(85) ASM folder
			        DC.W APP                           ;(86) APP folder
              DC.W MODEF                         ;(87) MODE folder
              DC.W DRG                           ;(88) DRG              
              DC.W AET                           ;(89) Approximate/Exact toggle              
              DC.W M6S                           ;(90) M6S
              DC.W M5S                           ;(91) M5S
              DC.W M4S                           ;(92) M4S
              DC.W M3S                           ;(93) M3S
              DC.W M2S                           ;(94) M2S
              DC.W M1S                           ;(95) M1S (2*95=190)
                                                 ;<- Shift             
                                                 
                                                 ;->program instructions
              DC.W ZOUT                          ;(96) Z->
              DC.W YOUT                          ;(97) Y->
              DC.W XOUT                          ;(98) X->
              DC.W WOUT                          ;(99) W->
              DC.W VOUT                          ;(100)V->                                        
              DC.W UOUT                          ;(101)U->
              DC.W TOUT                          ;(102)T-> 
              DC.W SOUT                          ;(103)S->
              DC.W ROUT                          ;(104)R->
              DC.W QOUT                          ;(105)Q->
              DC.W POUT                          ;(106)P->
              DC.W OOUT                          ;(107)O->
              DC.W NOUT                          ;(108)N->
              DC.W MOUT                          ;(109)M->
              DC.W LOUT                          ;(110)L->
              DC.W KOUT                          ;(111)K->
              DC.W JOUT                          ;(112)J->
              DC.W IOUT                          ;(113)I->
              DC.W HOUT                          ;(114)H->
              DC.W GOUT                          ;(115)G->
              DC.W FOUT                          ;(116)F->                        
              DC.W EOUT                          ;(117)E->
              DC.W DOUT                          ;(118)D->
              DC.W COUT                          ;(119)C->
              DC.W BOUT                          ;(120)B->
              DC.W AOUT                          ;(121)A-> (2*121=242)             
              
              DC.W PRGEND                        ;(122) terminates program execution (END)
              DC.W TON                           ;(123) starts the timer
              DC.W TOF                           ;(124) stops the timer              
              DC.W MODZ                          ;(125) modulus of complex number
              DC.W PRG6                          ;(126) execute program 6              
              DC.W MEMO                          ;(127) view memory contents
              DC.W TIME                          ;(128) view elapsed time
              DC.W RTOC                          ;(129) convert real numbers to complex number
              DC.W COZ                           ;(130) conjugate of complex number              
              DC.W Prg6Ed                        ;(131) enter program 6 edit mode                                                  
              DC.W Prg6Db                        ;(132) enter program 6 debug mode
              DC.W PrgCt                         ;(133) set program counter                         
              DC.W ABOUT                         ;(134) about page
              DC.W PickPrg                       ;(135) PICK program instruction
              DC.W STOZ                          ;(136) ->Z program instruction                                                                            
              DC.W STOY                          ;(137) ->Y program instruction
              DC.W STOX                          ;(138) ->X program instruction
              DC.W STOW                          ;(139) ->W program instruction                       
              DC.W STOV                          ;(140) ->V program instruction
              DC.W STOU                          ;(141) ->U program instruction 
              DC.W STOT                          ;(142) ->T program instruction                                                                            
              DC.W STOS                          ;(143) ->S program instruction
              DC.W STOR                          ;(144) ->R program instruction
              DC.W STOQ                          ;(145) ->Q program instruction                       
              DC.W STORP                         ;(146) ->P program instruction
              DC.W STOO                          ;(147) ->O program instruction
              DC.W STON                          ;(148) ->N program instruction                                                                            
              DC.W STOM                          ;(149) ->M program instruction
              DC.W STOL                          ;(150) ->L program instruction
              DC.W STOK                          ;(151) ->K program instruction                       
              DC.W STOJ                          ;(152) ->J program instruction
              DC.W STOI                          ;(153) ->I program instruction  
              DC.W STOH                          ;(154) ->H program instruction
              DC.W STOG                          ;(155) ->G program instruction  
              DC.W STOF                          ;(156) ->F program instruction
              DC.W STOE                          ;(157) ->E program instruction  
              DC.W STOD                          ;(158) ->D program instruction
              DC.W STOC                          ;(159) ->C program instruction              
              DC.W STOB                          ;(160) ->B program instruction
              DC.W STOA                          ;(161) ->A program instruction
              DC.W ROT                           ;(162) rotate the stack
              DC.W DEL2                          ;(163) delete FPN_1 and FPN_2 
              DC.W UNROT                         ;(164) unrotate the stack
              DC.W DEL3                          ;(165) delete FPN_1,FPN_2 and FPN_3
              DC.W ENT2                          ;(166) push FPN_1 and FPN_2 onto the stack 
              DC.W OVER                          ;(167) over
              DC.W POLAR                         ;(168) polar form of complex number 
              DC.W ENT3                          ;(169) push FPN_1,FPN_2 and FPN_3 onto the stack
              DC.W DEPTH                         ;(170) push the stack depth onto the stack 
              DC.W ENT4                          ;(171) push FPN_1,FPN_2,FPN_3 and FPN_4 onto the stack
              DC.W TOXK                          ;(172) copy FPN_1 to xK
              DC.W XKOUT                         ;(173) push xK onto the stack                                                               
              DC.W incK                          ;(174) increment K program instruction                                                
              DC.W decK                          ;(175) decrement K program instruction
              DC.W HALT                          ;(176) HALT program instruction
              DC.W DLYK                          ;(177) DELAYK program instruction 
              DC.W BUON                          ;(178) BUSY ON program instruction
              DC.W BUOFF                         ;(179) BUSY OFF program instruction
              DC.W ERRON                         ;(180) ERROR ON program instruction
              DC.W ERROFF                        ;(181) ERROROFF program instruction
              DC.W SCAN                          ;(182) SCN program instruction
              DC.W KNOUT                         ;(183) KEYNO-> program instruction
              DC.W NOPINSTR                      ;(184) NOP program instruction (2*184=368)
              DC.W SINH                          ;(185) sinh x                        
              DC.W COSH                          ;(186) cosh x
              DC.W TANH                          ;(187) tanh x
              DC.W ASINH                         ;(188) arcsinh x
              DC.W ACOSH                         ;(189) arccosh x
              DC.W ATANH                         ;(190) arctanh x
              DC.W FLOOR                         ;(191) floor function
              DC.W RetFS                         ;(192) RETFRMSUBRTE program instruction
              DC.W MODX                          ;(193) modulus of real number
              DC.W SETRand                       ;(194) set the random number seed
              DC.W PERMU                         ;(195) nPr
              DC.W COMBI                         ;(196) nCr 
              DC.W CEIL                          ;(197) ceiling function
              DC.W CTOR                          ;(198) push real and imaginary parts of complex number onto the 
                                                 ;stack               
              DC.W RECT                          ;(199) rectangular form of complex number
              DC.W MEANX                         ;(200) mean of x
              DC.W GrCD                          ;(201) GCD of FPN_1 and FPN_2
              DC.W LoCM                          ;(202) LCM of FPN_1 and FPN_2
              
              DC.W IGOTO                         ;(203) indirect GOTO program instruction
              DC.W IGOTO0                        ;(204) indirect GOTOIF=0 program instruction
              DC.W IGOTON0                       ;(205) indirect GOTOIF<>0 program instruction
              DC.W IGOTOEQ                       ;(206) indirect GOTOIF= program instruction
              DC.W IGOTONEQ                      ;(207) indirect GOTOIF<> program instruction
              DC.W IGOTOGT                       ;(208) indirect GOTOIF> program instruction
              DC.W IGOTOLT                       ;(209) indirect GOTOIF< program instruction
              DC.W IGOTOGTE                      ;(210) indirect GOTOIF>= program instruction
              DC.W IGOTOLTE                      ;(211) indirect GOTOIF<= program instruction
              DC.W IGOTOKP                       ;(212) indirect GOTOIFKEYPRS program instruction
              DC.W IGOTOXK                       ;(213) indirect GOTOIF=x(K) program instruction
              DC.W IGOTONXK                      ;(214) indirect GOTOIF<>x(K) program instruction
              DC.W IGOTOGTEXK                    ;(215) indirect GOTOIF>=x(K) program instruction
              DC.W IGOTOLTEXK                    ;(216) indirect GOTOIF<=x(K) program instruction
              
              DC.W TWOPX                         ;(217) 2^x
              DC.W LD                            ;(218) ld x
              DC.W TOYK                          ;(219) copy FPN_1 to yK
              DC.W YKOUT                         ;(220) push yK onto the stack
              DC.W key221                        ;(221)
              DC.W key222                        ;(222)
              DC.W key223                        ;(223)
              DC.W key224                        ;(224)
              DC.W key225                        ;(225)
              DC.W key226                        ;(226)
              DC.W key227                        ;(227)
              DC.W key228                        ;(228)
              DC.W key229                        ;(229)
              DC.W key230                        ;(230)
              DC.W key231                        ;(231)
              DC.W key232                        ;(232)
              DC.W key233                        ;(233)
              DC.W key234                        ;(234)
              DC.W key235                        ;(235)              
              DC.W EC2BYTE                       ;(236) $EC - reserved for future 2 byte instructions
              DC.W ED2BYTE                       ;(237) $ED - reserved for future 2 byte instructions
              DC.W EE2BYTE                       ;(238) $EE - reserved for future 2 byte instructions 
              DC.W EF2BYTE                       ;(239) $EF - 1st byte of 2 byte instruction
              
              DC.W GOTO                          ;(240) GOTO program instruction
              DC.W GOTO0                         ;(241) GOTOIF=0 program instruction
              DC.W GOTON0                        ;(242) GOTOIF<>0 program instruction
              DC.W GOTOEQ                        ;(243) GOTOIF= program instruction
              DC.W GOTONEQ                       ;(244) GOTOIF<> program instruction
              DC.W GOTOGT                        ;(245) GOTOIF> program instruction
              DC.W GOTOLT                        ;(246) GOTOIF< program instruction
              DC.W GOTOGTE                       ;(247) GOTOIF>= program instruction
              DC.W GOTOLTE                       ;(248) GOTOIF<= program instruction
              DC.W GOTOKP                        ;(249) GOTOIFKEYPRS program instruction
              DC.W GOTOXK                        ;(250) GOTOIF=x(K) program instruction
              DC.W GOTONXK                       ;(251) GOTOIF<>x(K) program instruction              
              DC.W GOTOGTEXK                     ;(252) GOTOIF>=x(K) program instruction
              DC.W GOTOLTEXK                     ;(253) GOTOIF<=x(K) program instruction
              DC.W GOTOCOMLE                     ;(254) GOTOIFCOMLEMP program instruction
              DC.W JUMPSR                        ;(255) JUMPTOSUBRTE program instruction                                                
              
keyTable2ByteEF
              DC.W SDEGM                         ;set DEG mode  
              DC.W SRADM                         ;set RAD mode
              DC.W SGRAM                         ;set GRA mode
              DC.W SAPPRM                        ;set ~ mode
              DC.W SEXACM                        ;set = mode
              DC.W SCPXM                         ;set CPX mode
              DC.W SENGM                         ;set ENG mode
              DC.W FIXM                          ;FIX
              DC.W ERRORTRAP                     ;display "ERROR" and terminate program execution
              DC.W SHEXM                         ;set HEX mode 
              DC.W SDECM                         ;set DEC mode 
              DC.W SBINM                         ;set BIN mode 
              DC.W SSCIM                         ;set SCI mode 
              DC.W keyEF13
              DC.W keyEF14
              DC.W keyEF15
              DC.W keyEF16
              DC.W keyEF17
              DC.W keyEF18
              DC.W keyEF19
              DC.W keyEF20
              DC.W keyEF21
              DC.W keyEF22
              DC.W keyEF23
              DC.W keyEF24
              DC.W keyEF25
              DC.W keyEF26
              DC.W keyEF27
              DC.W keyEF28
              DC.W keyEF29
              DC.W keyEF30
              DC.W keyEF31
              DC.W keyEF32
              DC.W keyEF33
              DC.W keyEF34
              DC.W keyEF35
              DC.W keyEF36
              DC.W keyEF37
              DC.W keyEF38
              DC.W keyEF39
              DC.W keyEF40
              DC.W keyEF41
              DC.W keyEF42
              DC.W keyEF43
              DC.W keyEF44
              DC.W keyEF45
              DC.W keyEF46
              DC.W keyEF47
              DC.W keyEF48
              DC.W keyEF49
              DC.W keyEF50
              DC.W keyEF51
              DC.W keyEF52
              DC.W keyEF53
              DC.W keyEF54
              DC.W keyEF55
              DC.W keyEF56
              DC.W keyEF57
              DC.W keyEF58
              DC.W keyEF59
              DC.W keyEF60
              DC.W keyEF61
              DC.W keyEF62
              DC.W keyEF63
              DC.W keyEF64
              DC.W keyEF65
              DC.W keyEF66
              DC.W keyEF67
              DC.W keyEF68
              DC.W keyEF69
              DC.W keyEF70
              DC.W keyEF71
              DC.W keyEF72
              DC.W keyEF73
              DC.W keyEF74
              DC.W keyEF75
              DC.W keyEF76
              DC.W keyEF77
              DC.W keyEF78
              DC.W keyEF79
              DC.W keyEF80
              DC.W keyEF81
              DC.W keyEF82
              DC.W keyEF83
              DC.W keyEF84
              DC.W keyEF85
              DC.W keyEF86
              DC.W keyEF87
              DC.W keyEF88
              DC.W keyEF89
              DC.W keyEF90
              DC.W keyEF91
              DC.W keyEF92
              DC.W keyEF93
              DC.W keyEF94
              DC.W keyEF95
              DC.W keyEF96
              DC.W keyEF97
              DC.W keyEF98
              DC.W keyEF99
              DC.W keyEF100                          
              DC.W keyEF101                        
              DC.W keyEF102                        
              DC.W keyEF103                       
              DC.W keyEF104                        
              DC.W keyEF105                        
              DC.W keyEF106                        
              DC.W keyEF107                        
              DC.W keyEF108                        
              DC.W keyEF109                        
              DC.W keyEF110                       
              DC.W keyEF111                       
              DC.W keyEF112
              DC.W keyEF113
              DC.W keyEF114
              DC.W keyEF115
              DC.W keyEF116
              DC.W keyEF117
              DC.W keyEF118
              DC.W keyEF119
              DC.W keyEF120
              DC.W keyEF121
              DC.W keyEF122
              DC.W keyEF123
              DC.W keyEF124
              DC.W keyEF125
              DC.W keyEF126
              DC.W keyEF127
              DC.W keyEF128
              DC.W keyEF129
              DC.W keyEF130
              DC.W keyEF131
              DC.W keyEF132
              DC.W keyEF133
              DC.W keyEF134
              DC.W keyEF135
              DC.W keyEF136
              DC.W keyEF137
              DC.W keyEF138
              DC.W keyEF139
              DC.W keyEF140
              DC.W keyEF141
              DC.W keyEF142
              DC.W keyEF143
              DC.W keyEF144
              DC.W keyEF145
              DC.W keyEF146
              DC.W keyEF147
              DC.W keyEF148
              DC.W keyEF149
              DC.W keyEF150
              DC.W keyEF151
              DC.W keyEF152
              DC.W keyEF153
              DC.W keyEF154
              DC.W keyEF155
              DC.W keyEF156
              DC.W keyEF157
              DC.W keyEF158
              DC.W keyEF159
              DC.W keyEF160
              DC.W keyEF161
              DC.W keyEF162
              DC.W keyEF163
              DC.W keyEF164
              DC.W keyEF165
              DC.W keyEF166
              DC.W keyEF167
              DC.W keyEF168
              DC.W keyEF169
              DC.W keyEF170
              DC.W keyEF171
              DC.W keyEF172
              DC.W keyEF173
              DC.W keyEF174
              DC.W keyEF175
              DC.W keyEF176
              DC.W keyEF177
              DC.W keyEF178
              DC.W keyEF179
              DC.W keyEF180
              DC.W keyEF181
              DC.W keyEF182
              DC.W keyEF183
              DC.W keyEF184
              DC.W keyEF185
              DC.W keyEF186
              DC.W keyEF187
              DC.W keyEF188
              DC.W keyEF189
              DC.W keyEF190
              DC.W keyEF191
              DC.W keyEF192
              DC.W keyEF193
              DC.W keyEF194
              DC.W keyEF195
              DC.W keyEF196
              DC.W keyEF197
              DC.W keyEF198
              DC.W keyEF199
              DC.W keyEF200                          
              DC.W keyEF201                        
              DC.W keyEF202                        
              DC.W keyEF203                       
              DC.W keyEF204                        
              DC.W keyEF205                        
              DC.W keyEF206                        
              DC.W keyEF207                        
              DC.W keyEF208                        
              DC.W keyEF209                        
              DC.W keyEF210                       
              DC.W keyEF211                       
              DC.W keyEF212
              DC.W keyEF213
              DC.W keyEF214
              DC.W keyEF215
              DC.W keyEF216
              DC.W keyEF217
              DC.W keyEF218
              DC.W keyEF219
              DC.W keyEF220
              DC.W keyEF221
              DC.W keyEF222
              DC.W keyEF223
              DC.W keyEF224
              DC.W keyEF225
              DC.W keyEF226
              DC.W keyEF227
              DC.W keyEF228
              DC.W keyEF229
              DC.W keyEF230
              DC.W keyEF231
              DC.W keyEF232
              DC.W keyEF233
              DC.W keyEF234
              DC.W keyEF235
              DC.W keyEF236
              DC.W keyEF237
              DC.W keyEF238
              DC.W keyEF239
              DC.W keyEF240
              DC.W keyEF241
              DC.W keyEF242
              DC.W keyEF243
              DC.W keyEF244
              DC.W keyEF245
              DC.W keyEF246
              DC.W keyEF247
              DC.W keyEF248
              DC.W keyEF249
              DC.W keyEF250
              DC.W keyEF251
              DC.W keyEF252
              DC.W keyEF253
              DC.W keyEF254
              DC.W keyEF255                      ;<- program instructions
              
                                                 ;program edit mode ->
keyTableTWO   DC.W key0_TWO                      ;(0) ADDITION
              DC.W key1_TWO                      ;(1) DELETE
              DC.W key2_TWO                      ;(2) DECIMAL POINT
              DC.W key3_TWO                      ;(3) 0 
              DC.W key4_TWO                      ;(4) +/-
              DC.W NOKEY                         ;(5) NOKEY
              DC.W key6_TWO                      ;(6) SUBTRACTION
              DC.W key7_TWO                      ;(7) 3
              DC.W key8_TWO                      ;(8) 2
              DC.W key9_TWO                      ;(9) 1
              DC.W key10_TWO                     ;(10) EXP
              DC.W NOKEY                         ;(11) NOKEY
              DC.W key12_TWO                     ;(12) MULTIPLICATION
              DC.W key13_TWO                     ;(13) 6
              DC.W key14_TWO                     ;(14) 5
              DC.W key15_TWO                     ;(15) 4
              DC.W key16_TWO                     ;(16) ENTER
              DC.W NOKEY                         ;(17) NOKEY 
              DC.W key18_TWO                     ;(18) DIVISION
              DC.W key19_TWO                     ;(19) 9
              DC.W key20_TWO                     ;(20) 8
              DC.W key21_TWO                     ;(21) 7
              DC.W key22_TWO                     ;(22) SHIFT
              DC.W NOKEY                         ;(23) NOKEY
              DC.W key24_TWO                     ;(24) F/10^x
              DC.W key25_TWO                     ;(25) E/e^x
              DC.W key26_TWO                     ;(26) D/pi
              DC.W key27_TWO                     ;(27) C/tan
              DC.W key28_TWO                     ;(28) B/cos
              DC.W key29_TWO                     ;(29) A/sin
              DC.W key30_TWO                     ;(30) 1/x
              DC.W key31_TWO                     ;(31) x^y
              DC.W key32_TWO                     ;(32) x^2
              DC.W key33_TWO                     ;(33) Hex
              DC.W key34_TWO                     ;(34) Dec
              DC.W key35_TWO                     ;(35) Bin
              DC.W key36_TWO                     ;(36) Exit
              DC.W key37_TWO                     ;(37) Down
			        DC.W key38_TWO                     ;(38) Up
              DC.W key39_TWO                     ;(39) Right
              DC.W key40_TWO                     ;(40) Left
              DC.W key41_TWO                     ;(41) Next
              DC.W key42_TWO                     ;(42) M6
              DC.W key43_TWO                     ;(43) M5
              DC.W key44_TWO                     ;(44) M4
              DC.W key45_TWO                     ;(45) M3
              DC.W key46_TWO                     ;(46) M2
              DC.W key47_TWO                     ;(47) M1   
              
              DC.W key48Prg                      ;(48)
              DC.W key1S_TWO                     ;(49) Clear 
              DC.W key2S_TWO                     ;(50) EQN folder
              DC.W key3S_TWO                     ;(51) STAT folder
              DC.W key4S_TWO                     ;(52) STAK folder
              DC.W NOKEY                         ;(53) NOKEY
              DC.W key54Prg                      ;(54) 
              DC.W key7S_TWO                     ;(55) PROB folder 
              DC.W key8S_TWO                     ;(56) POLY folder
              DC.W key9S_TWO                     ;(57) OPRE folder
              DC.W key10S_TWO                    ;(58) PICK
              DC.W NOKEY                         ;(59) NOKEY
              DC.W key12S_TWO                    ;(60) STO
              DC.W key13S_TWO                    ;(61) NUMB folder
              DC.W key14S_TWO                    ;(62) MATR folder
              DC.W key15S_TWO                    ;(63) FUNC folder
              DC.W key16S_TWO                    ;(64) SWAP
              DC.W NOKEY                         ;(65) NOKEY
              DC.W key18S_TWO                    ;(66) RCL
              DC.W key19S_TWO                    ;(67) FINA folder
              DC.W key20S_TWO                    ;(68) CPLX folder
              DC.W key21S_TWO                    ;(69) CALC folder
              DC.W UShiftPrg                     ;(70) undo shift
              DC.W NOKEY                         ;(71) NOKEY
              DC.W key24S_TWO                    ;(72) log
              DC.W key25S_TWO                    ;(73) ln
              DC.W key26S_TWO                    ;(74) RAND
              DC.W key27S_TWO                    ;(75) atan
              DC.W key28S_TWO                    ;(76) acos
              DC.W key29S_TWO                    ;(77) asin
              DC.W key30S_TWO                    ;(78) factorial
              DC.W key31S_TWO                    ;(79) x^(1/y)
              DC.W key32S_TWO                    ;(80) sqrt(x)
              DC.W key33S_TWO                    ;(81) GRPH folder
              DC.W key34S_TWO                    ;(82) ->DMS
              DC.W key35S_TWO                    ;(83) DMS->
              DC.W key36S_TWO                    ;(84) SYS folder
              DC.W key37S_TWO                    ;(85) ASM folder
			        DC.W key38S_TWO                    ;(86) APP folder
              DC.W key39S_TWO                    ;(87) MODE folder
              DC.W key40S_TWO                    ;(88) D|R -NOP
              DC.W key41S_TWO                    ;(89) ~|= -NOP
              DC.W key42S_TWO                    ;(90) M6S
              DC.W key43S_TWO                    ;(91) M5S
              DC.W key44S_TWO                    ;(92) M4S
              DC.W key45S_TWO                    ;(93) M3S
              DC.W key46S_TWO                    ;(94) M2S
              DC.W key47S_TWO                    ;(95) M1S               
                                                 
keyTableTHREE DC.W key0_THREE                    ;(0) display "+"
              DC.W key1_THREE                    ;(1) display "DELETE"
              DC.W key2_THREE                    ;(2) display "."
              DC.W key3_THREE                    ;(3) display "0"
              DC.W key4_THREE                    ;(4) display "+-"
              DC.W NOKEY                         ;(5) 
              DC.W key6_THREE                    ;(6) display "-"
              DC.W key7_THREE                    ;(7) display "3"
              DC.W key8_THREE                    ;(8) display "2"
              DC.W key9_THREE                    ;(9) display "1"
              DC.W key10_THREE                   ;(10) display "EXP"
              DC.W NOKEY                         ;(11) 
              DC.W key12_THREE                   ;(12) display "*"
              DC.W key13_THREE                   ;(13) display "6"
              DC.W key14_THREE                   ;(14) display "5"
              DC.W key15_THREE                   ;(15) display "4"
              DC.W key16_THREE                   ;(16) display "ENTER"
              DC.W NOKEY                         ;(17) 
              DC.W key18_THREE                   ;(18) display "/"
              DC.W key19_THREE                   ;(19) display "9"
              DC.W key20_THREE                   ;(20) display "8"
              DC.W key21_THREE                   ;(21) display "7"
              DC.W NOKEY                         ;(22) 
              DC.W NOKEY                         ;(23) 
              DC.W key24_THREE                   ;(24) display "10^x"
              DC.W key25_THREE                   ;(25) display "e^x"
              DC.W key26_THREE                   ;(26) display "Pi"
              DC.W key27_THREE                   ;(27) display "tan"
              DC.W key28_THREE                   ;(28) display "cos"
              DC.W key29_THREE                   ;(29) display "sin"
              DC.W key30_THREE                   ;(30) display "1/x"
              DC.W key31_THREE                   ;(31) display "x^y"
              DC.W key32_THREE                   ;(32) display "x^2"
              DC.W NOKEY                         ;(33) 
              DC.W NOKEY                         ;(34)
              DC.W NOKEY                         ;(35)
              DC.W NOKEY                         ;(36)
              DC.W NOKEY                         ;(37)
			        DC.W NOKEY                         ;(38)
              DC.W NOKEY                         ;(39)
              DC.W NOKEY                         ;(40)
              DC.W NOKEY                         ;(41)
              DC.W NOKEY                         ;(42)
              DC.W NOKEY                         ;(43)
              DC.W NOKEY                         ;(44)
              DC.W NOKEY                         ;(45)
              DC.W NOKEY                         ;(46)
              DC.W NOKEY                         ;(47) 
                                                 ;Shift ->
              DC.W NOKEY                         ;(48)
              DC.W key1S_THREE                   ;(49) display "CLEAR"
              DC.W NOKEY                         ;(50) 
              DC.W NOKEY                         ;(51)
              DC.W NOKEY                         ;(52) 
              DC.W NOKEY                         ;(53)
              DC.W NOKEY                         ;(54)
              DC.W NOKEY                         ;(55)
              DC.W NOKEY                         ;(56)
              DC.W NOKEY                         ;(57)
              DC.W NOKEY                         ;(58) 
              DC.W NOKEY                         ;(59)
              DC.W NOKEY                         ;(60)
              DC.W NOKEY                         ;(61)
              DC.W NOKEY                         ;(62)
              DC.W NOKEY                         ;(63)
              DC.W key16S_THREE                  ;(64) display "SWAP"
              DC.W NOKEY                         ;(65)
              DC.W NOKEY                         ;(66)
              DC.W NOKEY                         ;(67)
              DC.W NOKEY                         ;(68)
              DC.W NOKEY                         ;(69) 
              DC.W NOKEY                         ;(70)
              DC.W NOKEY                         ;(71)
              DC.W key24S_THREE                  ;(72) display "log x"
              DC.W key25S_THREE                  ;(73) display "ln x"
              DC.W key26S_THREE                  ;(74) display "RANDOMNUMBER"
              DC.W key27S_THREE                  ;(75) display "arctan x"
              DC.W key28S_THREE                  ;(76) display "arccos x"
              DC.W key29S_THREE                  ;(77) display "arcsin x"
              DC.W key30S_THREE                  ;(78) display "!"
              DC.W key31S_THREE                  ;(79) display "x^(1/y)"
              DC.W key32S_THREE                  ;(80) display "sqrt x"
              DC.W NOKEY                         ;(81)
              DC.W key34S_THREE                  ;(82) display "DECIMAL->degree symbol ' " "
              DC.W key35S_THREE                  ;(83) display "degree symbol ' "->DECIMAL"
              DC.W NOKEY                         ;(84)
              DC.W NOKEY                         ;(85)
			        DC.W NOKEY                         ;(86)
              DC.W NOKEY                         ;(87)
              DC.W NOKEY                         ;(88)
              DC.W NOKEY                         ;(89)
              DC.W NOKEY                         ;(90)
              DC.W NOKEY                         ;(91)
              DC.W NOKEY                         ;(92)
              DC.W NOKEY                         ;(93)
              DC.W NOKEY                         ;(94)
              DC.W NOKEY                         ;(95)                               
              
              DC.W key0T_THREE                   ;(96) display "Z->
              DC.W key1T_THREE                   ;(97) display "Y->
              DC.W key2T_THREE                   ;(98) display "X->
              DC.W key3T_THREE                   ;(99) display "W->
              DC.W key4T_THREE                   ;(100) display "V->              
              DC.W key6T_THREE                   ;(101) display "U->
              DC.W key7T_THREE                   ;(102) display "T->
              DC.W key8T_THREE                   ;(103) display "S->
              DC.W key9T_THREE                   ;(104) display "R->
              DC.W key10T_THREE                  ;(105) display "Q->              
              DC.W key12T_THREE                  ;(106) display "P->"
              DC.W key13T_THREE                  ;(107) display "O->"
              DC.W key14T_THREE                  ;(108) display "N->"
              DC.W key15T_THREE                  ;(109) display "M->"
              DC.W key16T_THREE                  ;(110) display "L->"                                
              DC.W key18T_THREE                  ;(111) display "K->"
              DC.W key19T_THREE                  ;(112) display "J->"
              DC.W key20T_THREE                  ;(113) display "I->"
              DC.W key21T_THREE                  ;(114) display "H->"
              DC.W key22T_THREE                  ;(115) display "G->"
              DC.W key24T_THREE                  ;(116) display "F->"
              DC.W key25T_THREE                  ;(117) display "E->"
              DC.W key26T_THREE                  ;(118) display "D->"
              DC.W key27T_THREE                  ;(119) display "C->"
              DC.W key28T_THREE                  ;(120) display "B->"
              DC.W key29T_THREE                  ;(121) display "A->"
              DC.W key126_THREE                  ;(122) display "END"                  
              DC.W key127_THREE                  ;(123) display "TMRON"
              DC.W key128_THREE                  ;(124) display "TMROFF"
              DC.W key131_THREE                  ;(125) display "|Z|" (modulus of complex number)
              DC.W NOKEY                         ;(126) execute program 6 (no operation)
              DC.W NOKEY                         ;(127) view memory contents (no operation)
              DC.W NOKEY                         ;(128) view elapsed time (no operation)
              DC.W key137_THREE                  ;(129) display "R->Z"
              DC.W key138_THREE                  ;(130) display "CZ" (conjugate of complex number)                           
              DC.W NOKEY                         ;(131) enter program 6 edit mode (no operation)                                                  
              DC.W NOKEY                         ;(132) enter program 6 debug mode (no operation)
              DC.W NOKEY                         ;(133) set program counter (no operation) 
              DC.W NOKEY                         ;(134) about page (no operation)
              DC.W key143_THREE                  ;(135) PICK program instruction
              DC.W key144_THREE                  ;(136) display "->Z"                                                                             
              DC.W key145_THREE                  ;(137) display "->Y"
              DC.W key146_THREE                  ;(138) display "->X" 
              DC.W key147_THREE                  ;(139) display "->W"                        
              DC.W key148_THREE                  ;(140) display "->V"
              DC.W key149_THREE                  ;(141) display "->U"
              DC.W key150_THREE                  ;(142) display "->T"                                                                            
              DC.W key151_THREE                  ;(143) display "->S"
              DC.W key152_THREE                  ;(144) display "->R"
              DC.W key153_THREE                  ;(145) display "->Q"                       
              DC.W key154_THREE                  ;(146) display "->P"
              DC.W key155_THREE                  ;(147) display "->O"
              DC.W key156_THREE                  ;(148) display "->N"                                                                            
              DC.W key157_THREE                  ;(149) display "->M"
              DC.W key158_THREE                  ;(150) display "->L"
              DC.W key159_THREE                  ;(151) display "->K"                      
              DC.W key160_THREE                  ;(152) display "->J"
              DC.W key161_THREE                  ;(153) display "->I"
              DC.W key162_THREE                  ;(154) display "->H"
              DC.W key163_THREE                  ;(155) display "->G"  
              DC.W key164_THREE                  ;(156) display "->F"
              DC.W key165_THREE                  ;(157) display "->E"  
              DC.W key166_THREE                  ;(158) display "->D"
              DC.W key167_THREE                  ;(159) display "->C"              
              DC.W key168_THREE                  ;(160) display "->B"
              DC.W key169_THREE                  ;(161) display "->A"
              DC.W key170_THREE                  ;(162) display "ROTATE" 
              DC.W key171_THREE                  ;(163) display "DELETE2"
              DC.W key172_THREE                  ;(164) display "UNROTATE" 
              DC.W key173_THREE                  ;(165) display "DELETE3"  
              DC.W key174_THREE                  ;(166) display "ENTER2" 
              DC.W key175_THREE                  ;(167) display "OVER"
              DC.W key176_THREE                  ;(168) display "POLARFORM Z" 
              DC.W key177_THREE                  ;(169) display "ENTER3"
              DC.W key178_THREE                  ;(170) display "DEPTH"
              DC.W key179_THREE                  ;(171) display "ENTER4"                                
              DC.W key181_THREE                  ;(172) display "->x(K)"
              DC.W key182_THREE                  ;(173) display "x(K)->"
              DC.W key183_THREE                  ;(174) display "INC K"              
              DC.W key184_THREE                  ;(175) display "DEC K"
              DC.W key185_THREE                  ;(176) display "HALT"
              DC.W key186_THREE                  ;(177) display "DELAYK"
              DC.W key187_THREE                  ;(178) display "BUSY ON"
              DC.W key188_THREE                  ;(179) display "BUSY OFF"
              DC.W key189_THREE                  ;(180) display "ERROR ON"
              DC.W key190_THREE                  ;(181) display "ERROROFF"
              DC.W key191_THREE                  ;(182) display "SCAN KP"
              DC.W key192_THREE                  ;(183) display "KEYNO->"
              DC.W key193_THREE                  ;(184) display "NOP"
              DC.W key194_THREE                  ;(185) display "sinh x"                  
              DC.W key195_THREE                  ;(186) display "cosh x"  
              DC.W key196_THREE                  ;(187) display "tanh x"  
              DC.W key197_THREE                  ;(188) display "arcsinh x"
              DC.W key198_THREE                  ;(189) display "arccosh x"
              DC.W key199_THREE                  ;(190) display "arctanh x"
              DC.W key200_THREE                  ;(191) display floor function symbol
              DC.W key201_THREE                  ;(192) display "RETFRMSUBRTE"
              DC.W key202_THREE                  ;(193) display "|X|" (modulus of real number)                  
              DC.W key203_THREE                  ;(194) display "->RANDOM#SEED"
              DC.W key204_THREE                  ;(195) display "PERMUTATION"
              DC.W key205_THREE                  ;(196) display "COMBINATION"
              DC.W key206_THREE                  ;(197) display ceiling function symbol                                             
              DC.W key209_THREE                  ;(198) display "COMPLEX->REAL"              
              DC.W key210_THREE                  ;(199) display "CARTFORMOFZ"
              DC.W key211_THREE                  ;(200) display mean of x symbol
              DC.W key212_THREE                  ;(201) display "GCD(a,b)"
              DC.W key213_THREE                  ;(202) display "LCM(a,b)"              
              DC.W key222_THREE                  ;(203) display underlined (indirect) "GOTO"
              DC.W key223_THREE                  ;(204) display underlined (indirect) "GOTOIF=0"
              DC.W key224_THREE                  ;(205) display underlined (indirect) "GOTOIF<>0"
              DC.W key225_THREE                  ;(206) display underlined (indirect) "GOTOIF="
              DC.W key226_THREE                  ;(207) display underlined (indirect) "GOTOIF<>"
              DC.W key227_THREE                  ;(208) display underlined (indirect) "GOTOIF>"
              DC.W key228_THREE                  ;(209) display underlined (indirect) "GOTOIF<"
              DC.W key229_THREE                  ;(210) display underlined (indirect) "GOTOIF>="
              DC.W key230_THREE                  ;(211) display underlined (indirect) "GOTOIF<="
              DC.W key231_THREE                  ;(212) display underlined (indirect) "GOTOIFKEYPRS"
              DC.W key232_THREE                  ;(213) display underlined (indirect) "GOTOIF=x(K)"
              DC.W key233_THREE                  ;(214) display underlined (indirect) "GOTOIF<>x(K)"
              DC.W key234_THREE                  ;(215) display underlined (indirect) "GOTOIF>=x(K)"
              DC.W key235_THREE                  ;(216) display underlined (indirect) "GOTOIF<=x(K)"
              DC.W key214_THREE                  ;(217) display "2^x"
              DC.W key215_THREE                  ;(218) display "ld x"
              DC.W key216_THREE                  ;(219) display "->y(K)
              DC.W key217_THREE                  ;(220) display "y(K)->"
              DC.W NOKEY                         ;(221)
              DC.W NOKEY                         ;(222)
              DC.W NOKEY                         ;(223)
              DC.W NOKEY                         ;(224)
              DC.W NOKEY                         ;(225)
              DC.W NOKEY                         ;(226)
              DC.W NOKEY                         ;(227)
              DC.W NOKEY                         ;(228)
              DC.W NOKEY                         ;(229)
              DC.W NOKEY                         ;(230)
              DC.W NOKEY                         ;(231)
              DC.W NOKEY                         ;(232)
              DC.W NOKEY                         ;(233)
              DC.W NOKEY                         ;(234)
              DC.W NOKEY                         ;(235)              
              DC.W key236_THREE                  ;(236) for future 2 byte instructions
              DC.W key237_THREE                  ;(237) for future 2 byte instructions
              DC.W key238_THREE                  ;(238) for future 2 byte instructions
              DC.W key239_THREE                  ;(239) display "2BYTEINSTRUC"
              DC.W key240_THREE                  ;(240) display "GOTO"
              DC.W key241_THREE                  ;(241) display "GOTOIF=0"
              DC.W key242_THREE                  ;(242) display "GOTOIF<>0"
              DC.W key243_THREE                  ;(243) display "GOTOIF="
              DC.W key244_THREE                  ;(244) display "GOTOIF<>"
              DC.W key245_THREE                  ;(245) display "GOTOIF>"
              DC.W key246_THREE                  ;(246) display "GOTOIF<"
              DC.W key247_THREE                  ;(247) display "GOTOIF>="
              DC.W key248_THREE                  ;(248) display "GOTOIF<="
              DC.W key249_THREE                  ;(249) display "GOTOIFKEYPRS"
              DC.W key250_THREE                  ;(250) display "GOTOIF=x(K)"
              DC.W key251_THREE                  ;(251) display "GOTOIF<>x(K)"              
              DC.W key252_THREE                  ;(252) display "GOTOIF>=x(K)"
              DC.W key253_THREE                  ;(253) display "GOTOIF<=x(K)"
              DC.W key254_THREE                  ;(254) display "GOTOIFCMDEMP"
              DC.W key255_THREE                  ;(255) display "JUMPTOSUBRTE"
              
keyTable2ByteEFTHREE
              DC.W keyEF0_THREE                  ;display "SETDEGMODE"
              DC.W keyEF1_THREE                  ;display "SETRADMODE"
              DC.W keyEF2_THREE                  ;display "SETGRAMODE"
              DC.W keyEF3_THREE                  ;display "SET~MODE"
              DC.W keyEF4_THREE                  ;display "SET=MODE"
              DC.W keyEF5_THREE                  ;display "SETCPXMODE"
              DC.W keyEF6_THREE                  ;display "SETENGMODE"
              DC.W keyEF7_THREE                  ;display "FIX"
              DC.W keyEF8_THREE                  ;display "DISPLAYERROR"
              DC.W keyEF9_THREE                  
              DC.W keyEF10_THREE                 
              DC.W keyEF11_THREE                 
              DC.W keyEF12_THREE
              DC.W keyEF13_THREE
              DC.W keyEF14_THREE
              DC.W keyEF15_THREE
              DC.W keyEF16_THREE
              DC.W keyEF17_THREE
              DC.W keyEF18_THREE
              DC.W keyEF19_THREE
              DC.W keyEF20_THREE
              DC.W keyEF21_THREE
              DC.W keyEF22_THREE
              DC.W keyEF23_THREE
              DC.W keyEF24_THREE
              DC.W keyEF25_THREE
              DC.W keyEF26_THREE
              DC.W keyEF27_THREE
              DC.W keyEF28_THREE
              DC.W keyEF29_THREE
              DC.W keyEF30_THREE
              DC.W keyEF31_THREE
              DC.W keyEF32_THREE
              DC.W keyEF33_THREE
              DC.W keyEF34_THREE
              DC.W keyEF35_THREE
              DC.W keyEF36_THREE
              DC.W keyEF37_THREE
              DC.W keyEF38_THREE
              DC.W keyEF39_THREE
              DC.W keyEF40_THREE
              DC.W keyEF41_THREE
              DC.W keyEF42_THREE
              DC.W keyEF43_THREE
              DC.W keyEF44_THREE
              DC.W keyEF45_THREE
              DC.W keyEF46_THREE
              DC.W keyEF47_THREE
              DC.W keyEF48_THREE
              DC.W keyEF49_THREE
              DC.W keyEF50_THREE
              DC.W keyEF51_THREE
              DC.W keyEF52_THREE
              DC.W keyEF53_THREE
              DC.W keyEF54_THREE
              DC.W keyEF55_THREE
              DC.W keyEF56_THREE
              DC.W keyEF57_THREE
              DC.W keyEF58_THREE
              DC.W keyEF59_THREE
              DC.W keyEF60_THREE
              DC.W keyEF61_THREE
              DC.W keyEF62_THREE
              DC.W keyEF63_THREE
              DC.W keyEF64_THREE
              DC.W keyEF65_THREE
              DC.W keyEF66_THREE
              DC.W keyEF67_THREE
              DC.W keyEF68_THREE
              DC.W keyEF69_THREE
              DC.W keyEF70_THREE
              DC.W keyEF71_THREE
              DC.W keyEF72_THREE
              DC.W keyEF73_THREE
              DC.W keyEF74_THREE
              DC.W keyEF75_THREE
              DC.W keyEF76_THREE
              DC.W keyEF77_THREE
              DC.W keyEF78_THREE
              DC.W keyEF79_THREE
              DC.W keyEF80_THREE
              DC.W keyEF81_THREE
              DC.W keyEF82_THREE
              DC.W keyEF83_THREE
              DC.W keyEF84_THREE
              DC.W keyEF85_THREE
              DC.W keyEF86_THREE
              DC.W keyEF87_THREE
              DC.W keyEF88_THREE
              DC.W keyEF89_THREE
              DC.W keyEF90_THREE
              DC.W keyEF91_THREE
              DC.W keyEF92_THREE
              DC.W keyEF93_THREE
              DC.W keyEF94_THREE
              DC.W keyEF95_THREE
              DC.W keyEF96_THREE
              DC.W keyEF97_THREE
              DC.W keyEF98_THREE
              DC.W keyEF99_THREE
              DC.W keyEF100_THREE                  
              DC.W keyEF101_THREE                  
              DC.W keyEF102_THREE                  
              DC.W keyEF103_THREE                  
              DC.W keyEF104_THREE                  
              DC.W keyEF105_THREE                  
              DC.W keyEF106_THREE                  
              DC.W keyEF107_THREE                  
              DC.W keyEF108_THREE                  
              DC.W keyEF109_THREE                  
              DC.W keyEF110_THREE                
              DC.W keyEF111_THREE                 
              DC.W keyEF112_THREE
              DC.W keyEF113_THREE
              DC.W keyEF114_THREE
              DC.W keyEF115_THREE
              DC.W keyEF116_THREE
              DC.W keyEF117_THREE
              DC.W keyEF118_THREE
              DC.W keyEF119_THREE
              DC.W keyEF120_THREE
              DC.W keyEF121_THREE
              DC.W keyEF122_THREE
              DC.W keyEF123_THREE
              DC.W keyEF124_THREE
              DC.W keyEF125_THREE
              DC.W keyEF126_THREE
              DC.W keyEF127_THREE
              DC.W keyEF128_THREE
              DC.W keyEF129_THREE
              DC.W keyEF130_THREE
              DC.W keyEF131_THREE
              DC.W keyEF132_THREE
              DC.W keyEF133_THREE
              DC.W keyEF134_THREE
              DC.W keyEF135_THREE
              DC.W keyEF136_THREE
              DC.W keyEF137_THREE
              DC.W keyEF138_THREE
              DC.W keyEF139_THREE
              DC.W keyEF140_THREE
              DC.W keyEF141_THREE
              DC.W keyEF142_THREE
              DC.W keyEF143_THREE
              DC.W keyEF144_THREE
              DC.W keyEF145_THREE
              DC.W keyEF146_THREE
              DC.W keyEF147_THREE
              DC.W keyEF148_THREE
              DC.W keyEF149_THREE
              DC.W keyEF150_THREE
              DC.W keyEF151_THREE
              DC.W keyEF152_THREE
              DC.W keyEF153_THREE
              DC.W keyEF154_THREE
              DC.W keyEF155_THREE
              DC.W keyEF156_THREE
              DC.W keyEF157_THREE
              DC.W keyEF158_THREE
              DC.W keyEF159_THREE
              DC.W keyEF160_THREE
              DC.W keyEF161_THREE
              DC.W keyEF162_THREE
              DC.W keyEF163_THREE
              DC.W keyEF164_THREE
              DC.W keyEF165_THREE
              DC.W keyEF166_THREE
              DC.W keyEF167_THREE
              DC.W keyEF168_THREE
              DC.W keyEF169_THREE
              DC.W keyEF170_THREE
              DC.W keyEF171_THREE
              DC.W keyEF172_THREE
              DC.W keyEF173_THREE
              DC.W keyEF174_THREE
              DC.W keyEF175_THREE
              DC.W keyEF176_THREE
              DC.W keyEF177_THREE
              DC.W keyEF178_THREE
              DC.W keyEF179_THREE
              DC.W keyEF180_THREE
              DC.W keyEF181_THREE
              DC.W keyEF182_THREE
              DC.W keyEF183_THREE
              DC.W keyEF184_THREE
              DC.W keyEF185_THREE
              DC.W keyEF186_THREE
              DC.W keyEF187_THREE
              DC.W keyEF188_THREE
              DC.W keyEF189_THREE
              DC.W keyEF190_THREE
              DC.W keyEF191_THREE
              DC.W keyEF192_THREE
              DC.W keyEF193_THREE
              DC.W keyEF194_THREE
              DC.W keyEF195_THREE
              DC.W keyEF196_THREE
              DC.W keyEF197_THREE
              DC.W keyEF198_THREE
              DC.W keyEF199_THREE
              DC.W keyEF200_THREE                  
              DC.W keyEF201_THREE                  
              DC.W keyEF202_THREE                  
              DC.W keyEF203_THREE                  
              DC.W keyEF204_THREE                  
              DC.W keyEF205_THREE                  
              DC.W keyEF206_THREE                  
              DC.W keyEF207_THREE                  
              DC.W keyEF208_THREE                  
              DC.W keyEF209_THREE                  
              DC.W keyEF210_THREE                
              DC.W keyEF211_THREE                 
              DC.W keyEF212_THREE
              DC.W keyEF213_THREE
              DC.W keyEF214_THREE
              DC.W keyEF215_THREE
              DC.W keyEF216_THREE
              DC.W keyEF217_THREE
              DC.W keyEF218_THREE
              DC.W keyEF219_THREE
              DC.W keyEF220_THREE
              DC.W keyEF221_THREE
              DC.W keyEF222_THREE
              DC.W keyEF223_THREE
              DC.W keyEF224_THREE
              DC.W keyEF225_THREE
              DC.W keyEF226_THREE
              DC.W keyEF227_THREE
              DC.W keyEF228_THREE
              DC.W keyEF229_THREE
              DC.W keyEF230_THREE
              DC.W keyEF231_THREE
              DC.W keyEF232_THREE
              DC.W keyEF233_THREE
              DC.W keyEF234_THREE
              DC.W keyEF235_THREE
              DC.W keyEF236_THREE
              DC.W keyEF237_THREE
              DC.W keyEF238_THREE
              DC.W keyEF239_THREE
              DC.W keyEF240_THREE
              DC.W keyEF241_THREE
              DC.W keyEF242_THREE
              DC.W keyEF243_THREE
              DC.W keyEF244_THREE
              DC.W keyEF245_THREE
              DC.W keyEF246_THREE
              DC.W keyEF247_THREE
              DC.W keyEF248_THREE
              DC.W keyEF249_THREE
              DC.W keyEF250_THREE
              DC.W keyEF251_THREE
              DC.W keyEF252_THREE
              DC.W keyEF253_THREE
              DC.W keyEF254_THREE
              DC.W keyEF255_THREE              
              
keyHdlr_1:    RTS

;***************key functions TWO****************

;Key0_TWO: "+", "->Z" or "Z->";;;;;;;;;;;;;;;;;;;;

key0_TWO:     CALL key0_TWOSUB

              JMP keyHdlr_1

;Key1_TWO: NOP, "DELETE", "->Y" or "Y->"

key1_TWO:     CALL key1_TWOSUB
                            
              JMP keyHdlr_1    

;Key2_TWO: ".", "->X" or "X->";;;;;;;;;;;;;;;;;;;; 

key2_TWO:     CALL key2_TWOSUB 

              JMP keyHdlr_1              
              
;Key3_TWO: "0", "->W" or "W->";;;;;;;;;;;;;;;;;;;; 

key3_TWO:     CALL key3_TWOSUB

              JMP keyHdlr_1              
              
;Key4_TWO: "NEG" or "->V" ;;;;;;;;;;;;;;;;;;;;;;;;

key4_TWO:     CALL key4_TWOSUB

              JMP keyHdlr_1

;Key6_TWO: "-" or "->U";;;;;;;;;;;;;;;;;;;;;;;;;;; 

key6_TWO:     CALL key6_TWOSUB

              JMP keyHdlr_1
              
;Key7_TWO: "3" or "->T";;;;;;;;;;;;;;;;;;;;;;;;;;; 

key7_TWO:     CALL key7_TWOSUB  

              JMP keyHdlr_1      

;Key8_TWO: "2" or "->S";;;;;;;;;;;;;;;;;;;;;;;;;;; 

key8_TWO:     CALL key8_TWOSUB 

              JMP keyHdlr_1 
              
;Key9_TWO: "1" or "->R";;;;;;;;;;;;;;;;;;;;;;;;;;; 

key9_TWO:     CALL key9_TWOSUB

              JMP keyHdlr_1 
               
;Key10_TWO: "EXP" or "->Q";;;;;;;;;;;;;;;;; 

key10_TWO:    CALL key10_TWOSUB

              JMP keyHdlr_1                      

;Key12_TWO: "*" or "->P";;;;;;;;;;;;;;;;;;;;;;;;;; 

key12_TWO:    CALL key12_TWOSUB

              JMP keyHdlr_1
              
;Key13_TWO: "6" or "->O";;;;;;;;;;;;;;;;;;;;;;;;;; 

key13_TWO:    CALL key13_TWOSUB

              JMP keyHdlr_1 
              
;Key14_TWO: "5" or "->N";;;;;;;;;;;;;;;;;;;;;;;;;; 

key14_TWO:    CALL key14_TWOSUB

              JMP keyHdlr_1  
              
;Key15_TWO: "4" or "->M";;;;;;;;;;;;;;;;;;;;;;;;;; 

key15_TWO:    CALL key15_TWOSUB

              JMP keyHdlr_1 
              
;Key16_TWO: "ENTER" or "->L";;;;;;;;;;;;;;;;;;;;;;

key16_TWO:    CALL key16_TWOSUB

              JMP keyHdlr_1

;Key18_TWO: "/" or "->K";;;;;;;;;;;;;;;;;;;;;;;;;; 

key18_TWO:    CALL key18_TWOSUB 

              JMP keyHdlr_1
              
;Key19_TWO: "9" or "->J";;;;;;;;;;;;;;;;;;;;;;;;;; 

key19_TWO:    CALL key19_TWOSUB

              JMP keyHdlr_1 
              
;Key20_TWO: "8" or "->I";;;;;;;;;;;;;;;;;;;;;;;;;; 

key20_TWO:    CALL key20_TWOSUB 

              JMP keyHdlr_1 
              
;Key21_TWO: "7" or "->H";;;;;;;;;;;;;;;;;;;;;;;;;; 

key21_TWO:    CALL key21_TWOSUB

              JMP keyHdlr_1 
              
;Key22_TWO: "Shift" or "->G";;;;;;;;;;;;;;;;;;;;;;

key22_TWO:    CALL key22_TWOSUB
              
              JMP keyHdlr_1                      

;Key24_TWO: "10^x" or "->F";;;;;;;;;;;;;;;;;;;;;;;; 

key24_TWO:    CALL key24_TWOSUB

              JMP keyHdlr_1
              
;Key25_TWO: "e^x" or "->E";;;;;;;;;;;;;;;;;;;;;;;;; 

key25_TWO:    CALL key25_TWOSUB

              JMP keyHdlr_1
              
;Key26_TWO: "Pi" or "->D";;;;;;;;;;;;;;;;;;;;;;;;; 

key26_TWO:    CALL key26_TWOSUB

              JMP keyHdlr_1
              
;Key27_TWO: "tan" or "->C";;;;;;;;;;;;;;;;;;;;;;;; 

key27_TWO:    CALL key27_TWOSUB

              JMP keyHdlr_1
              
;Key28_TWO: "cos" or "->B";;;;;;;;;;;;;;;;;;;;;;;; 

key28_TWO:    CALL key28_TWOSUB

              JMP keyHdlr_1
              
;Key29_TWO: "sin" or "->A";;;;;;;;;;;;;;;;;;;;;;;; 

key29_TWO:    CALL key29_TWOSUB

              JMP keyHdlr_1
              
;Key30_TWO: "1/x";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

key30_TWO:    CALL key30_TWOSUB
                            
              JMP keyHdlr_1
              
;Key31_TWO: "x^y";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

key31_TWO:    CALL key31_TWOSUB
              
              JMP keyHdlr_1
              
;Key32_TWO: "x^2";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

key32_TWO:    CALL key32_TWOSUB
              
              JMP keyHdlr_1        
              
;Key33_TWO: "Hex";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

key33_TWO:    CALL key33_TWOSUB
                            
              JMP keyHdlr_1
              
;Key34_TWO: "Dec";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

key34_TWO:    CALL key34_TWOSUB
                            
              JMP keyHdlr_1
              
;Key35_TWO: "Bin";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

key35_TWO:    CALL key35_TWOSUB
                            
              JMP keyHdlr_1

;Key36_TWO: exit current menu/program edit mode;;;

key36_TWO:    CALL key36_TWOSUB

              JMP keyHdlr_1                      

;Key37_TWO: program edit mode down arrow;;;;;;;;;;

key37_TWO:    CALL key37_TWOSUB

              JMP keyHdlr_1

;Key38_TWO: program edit mode up arrow;;;;;;;;;;;;

key38_TWO     CALL key38_TWOSUB

              JMP keyHdlr_1

;Key39_TWO: program edit mode right arrow;;;;;;;;;

key39_TWO:    BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1

;Key40_TWO: program edit mode left arrow;;;;;;;;;;

key40_TWO:    BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1

;Key41_TWO: toggle program menus;;;;;;;;;;;;;;;;;;

key41_TWO:    CALL key41_TWOSUB

              JMP keyHdlr_1
              
;Key42_TWO: MK6 program edit mode;;;;;;;;;;;;;;;;;

key42_TWO:    CALL key42_TWOSUB  

              JMP keyHdlr_1
              
;Key43_TWO: MK5 program edit mode;;;;;;;;;;;;;;;;;

key43_TWO:    CALL key43_TWOSUB 

              JMP keyHdlr_1
              
;Key44_TWO: MK4 program edit mode;;;;;;;;;;;;;;;;;

key44_TWO:    CALL key44_TWOSUB 

              JMP keyHdlr_1
              
;Key45_TWO: MK3 program edit mode;;;;;;;;;;;;;;;;;

key45_TWO:    CALL key45_TWOSUB 

              JMP keyHdlr_1
              
;Key46_TWO: MK2 program edit mode;;;;;;;;;;;;;;;;;

key46_TWO:    CALL key46_TWOSUB 

              JMP keyHdlr_1
              
;Key47_TWO: MK1 program edit mode;;;;;;;;;;;;;;;;;

key47_TWO:    CALL key47_TWOSUB 

              JMP keyHdlr_1

;Key1S_TWO: Clear;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key1S_TWO:    ;CALL key1S_TWOSUB

              MOVB keyNumber,0,Y                 ;(prgCounter) = $31 = 49 (CLEAR)
                            
              JMP keyHdlr_1

;Key2S_TWO:EQN folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key2S_TWO:    MOVB #$26,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter    

              JMP keyHdlr_1
              
;Key3S_TWO:STAT folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key3S_TWO:    MOVB #$19,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter    

              JMP keyHdlr_1
              
;Key4S_TWO:STAK folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key4S_TWO:    MOVB #$2A,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter    

              JMP keyHdlr_1
              
;Key7S_TWO:PROB folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key7S_TWO:    MOVB #$17,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1
              
;Key8S_TWO:POLY folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key8S_TWO:    MOVB #$0D,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1
              
;Key9S_TWO:OPRE folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key9S_TWO:    MOVB #$11,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1
              
;Key10S_TWO: PICK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key10S_TWO:   MOVB #$87,0,Y                      ;(prgCounter) = $87 = 135 (PICK program instruction)
                            
              JMP keyHdlr_1

;Key12S_TWO:STO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key12S_TWO:   CALL key12S_TWOSUB

              JMP keyHdlr_1
              
;Key13S_TWO:NUMB folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key13S_TWO:   MOVB #$0B,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1 
              
;Key14S_TWO:MATR folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key14S_TWO:   MOVB #$1B,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1 
              
;Key15S_TWO:FUNC folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key15S_TWO:   MOVB #$13,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1 
              
;Key16S_TWO:SWAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key16S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) = $40 = 64 (SWAP)   

              JMP keyHdlr_1
              
;Key18S_TWO:RCL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
key18S_TWO:   CALL key18S_TWOSUB   

              JMP keyHdlr_1
              
;Key19S_TWO:FINA folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key19S_TWO:   MOVB #$16,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1  
              
;Key20S_TWO:CPLX folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key20S_TWO:   MOVB #$07,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1 
              
;Key21S_TWO:CALC folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key21S_TWO:   MOVB #$0F,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1 
              
;Key24S_TWO: "log x";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key24S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) = 
                            
              JMP keyHdlr_1
              
;Key25S_TWO: "ln x";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key25S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) =
                            
              JMP keyHdlr_1
              
;Key26S_TWO: "RAND";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key26S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) =
                            
              JMP keyHdlr_1
              
;Key27S_TWO: "arctan";;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key27S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) =
                            
              JMP keyHdlr_1

;Key28S_TWO: "arccos";;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key28S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) =
                            
              JMP keyHdlr_1
              
;Key29S_TWO: "arcsin";;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key29S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) =
                            
              JMP keyHdlr_1
              
;Key30S_TWO: "!";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key30S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) =
                            
              JMP keyHdlr_1
              
;Key31S_TWO: "x^1/y";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key31S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) =
                            
              JMP keyHdlr_1
              
;Key32S_TWO: "sqrt(x)";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key32S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) =
                            
              JMP keyHdlr_1

;Key33S_TWO:GRPH folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key33S_TWO:   MOVB #$13,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1  
              
;Key34S_TWO:->DMS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key34S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) =  

              JMP keyHdlr_1 
              
;Key35S_TWO:DMS->;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key35S_TWO:   MOVB keyNumber,0,Y                 ;(prgCounter) =  

              JMP keyHdlr_1
              
;Key36S_TWO:SYS folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key36S_TWO:   MOVB #$21,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1
              
;Key37S_TWO:ASM folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key37S_TWO:   MOVB #$09,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1
              
;Key38S_TWO:APP folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key38S_TWO:   MOVB #$15,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1
              
;Key39S_TWO:MODE folder;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key39S_TWO:   MOVB #$23,menu

              BCLR flag5,#BIT3                   ;do not increment prgCounter

              JMP keyHdlr_1

;Key40S_TWO:D|R - NOP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key40S_TWO:   JMP keyHdlr_1

;Key41S_TWO:~|= - NOP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key41S_TWO:   JMP keyHdlr_1
     
;Key42S_TWO: shift MK6 program edit mode;;;;;;;;;;

key42S_TWO:   CALL key42S_TWOSUB   

              JMP keyHdlr_1
              
;Key43S_TWO: shift MK5 program edit mode;;;;;;;;;;

key43S_TWO:   CALL key43S_TWOSUB 

              JMP keyHdlr_1
              
;Key44S_TWO: shift MK4 program edit mode;;;;;;;;;;

key44S_TWO:   CALL key44S_TWOSUB 

              JMP keyHdlr_1
              
;Key45S_TWO: shift MK3 program edit mode;;;;;;;;;;

key45S_TWO:   CALL key45S_TWOSUB 

              JMP keyHdlr_1
              
;Key46S_TWO: shift MK2 program edit mode;;;;;;;;;;

key46S_TWO:   CALL key46S_TWOSUB 

              JMP keyHdlr_1
              
;Key47S_TWO: shift MK1 program edit mode;;;;;;;;;;

key47S_TWO:   CALL key47S_TWOSUB 

              JMP keyHdlr_1
                           
;****************key functions 3******************
              
;Key0_THREE: display "+";;;;;;;;;;;;;;;;;;;;;;;;;;

key0_THREE:   CALL key0_THREESUB 
              
              JMP keyHdlr_1    
              
;Key1_THREE: display "DELETE";;;;;;;;;;;;;;;;;;;;;

key1_THREE:   CALL key1_THREESUB                 
              
              JMP keyHdlr_1
              
;Key2_THREE: display ".";;;;;;;;;;;;;;;;;;;;;;;;;;

key2_THREE:   CALL key2_THREESUB                  
              
              JMP keyHdlr_1
              
;Key3_THREE: display "0";;;;;;;;;;;;;;;;;;;;;;;;;; 

key3_THREE:   CALL key3_THREESUB               
              
              JMP keyHdlr_1
              
;Key4_THREE: display "NEG";;;;;;;;;;;;;;;;;;;;;;;;

key4_THREE:   CALL key4_THREESUB                  
              
              JMP keyHdlr_1

;Key6_THREE: display "-";;;;;;;;;;;;;;;;;;;;;;;;;;

key6_THREE:   CALL key6_THREESUB 

              JMP keyHdlr_1
              
;Key7_THREE: display "3";;;;;;;;;;;;;;;;;;;;;;;;;;

key7_THREE:   CALL key7_THREESUB                
              
              JMP keyHdlr_1 
              
;Key8_THREE: display "2";;;;;;;;;;;;;;;;;;;;;;;;;; 

key8_THREE:   CALL key8_THREESUB             
              
              JMP keyHdlr_1
              
;Key9_THREE: display "1";;;;;;;;;;;;;;;;;;;;;;;;;; 

key9_THREE:   CALL key9_THREESUB                 
              
              JMP keyHdlr_1
              
;Key10_THREE: display "EXP";;;;;;;;;;;;;;;;;;;;;;;

key10_THREE:  CALL key10_THREESUB                   
              
              JMP keyHdlr_1

;Key12_THREE: display "*";;;;;;;;;;;;;;;;;;;;;;;;;

key12_THREE:  CALL key12_THREESUB                   
              
              JMP keyHdlr_1

;Key13_THREE: display "6";;;;;;;;;;;;;;;;;;;;;;;;; 

key13_THREE:  CALL key13_THREESUB               
              
              JMP keyHdlr_1 
              
;Key14_THREE: display "5";;;;;;;;;;;;;;;;;;;;;;;;;; 

key14_THREE:  CALL key14_THREESUB                 
              
              JMP keyHdlr_1 
              
;Key15_THREE: display "4";;;;;;;;;;;;;;;;;;;;;;;;;; 

key15_THREE:  CALL key15_THREESUB 

              JMP keyHdlr_1
 
;Key16_THREE: display "ENTER";;;;;;;;;;;;;;;;;;;;;

key16_THREE:  CALL key16_THREESUB                   
              
              JMP keyHdlr_1              

;Key18_THREE: display "/";;;;;;;;;;;;;;;;;;;;;;;;;

key18_THREE:  CALL key18_THREESUB 

              JMP keyHdlr_1
              
;Key19_THREE: display "9";;;;;;;;;;;;;;;;;;;;;;;;; 

key19_THREE:  CALL key19_THREESUB                   
              
              JMP keyHdlr_1      

;Key20_THREE: display "8";;;;;;;;;;;;;;;;;;;;;;;;; 

key20_THREE:  CALL key20_THREESUB                     
              
              JMP keyHdlr_1 
              
;Key21_THREE: display "7";;;;;;;;;;;;;;;;;;;;;;;;; 

key21_THREE:  CALL key21_THREESUB                  
              
              JMP keyHdlr_1

;Key24_THREE: display 10^x symbol;;;;;;;;;;;;;;;;;

key24_THREE:  CALL key24S_THREESUB                   
              
              JMP keyHdlr_1
               
;Key25_THREE: display e^x symbol;;;;;;;;;;;;;;;;;;

key25_THREE:  CALL key25S_THREESUB                    
              
              JMP keyHdlr_1
              
;Key26_THREE: display pi symbol;;;;;;;;;;;;;;;;;;;

key26_THREE:  CALL key130_THREESUB                
              
              JMP keyHdlr_1
              
;Key27_THREE: display "tan x";;;;;;;;;;;;;;;;;;;;;

key27_THREE:  CALL key27_THREESUB                    
              
              JMP keyHdlr_1 
              
;Key28_THREE: display "cos x";;;;;;;;;;;;;;;;;;;;;

key28_THREE:  CALL key28_THREESUB                    
              
              JMP keyHdlr_1
              
;Key29_THREE: display "sin x";;;;;;;;;;;;;;;;;;;;;

key29_THREE:  CALL key29_THREESUB

              JMP keyHdlr_1
              
;Key30_THREE: display "1/x";;;;;;;;;;;;;;;;;;;;;;;

key30_THREE:  CALL key30_THREESUB                   
              
              JMP keyHdlr_1
              
;Key31_THREE: display x^y symbol;;;;;;;;;;;;;;;;;;

key31_THREE:  CALL key31_THREESUB                     
              
              JMP keyHdlr_1
              
;Key32_THREE: display x^2 symbol;;;;;;;;;;;;;;;;;

key32_THREE:  CALL key32S_THREESUB 
              
              JMP keyHdlr_1           
              
;Key1S_THREE: display "CLEAR";;;;;;;;;;;;;;;;;;;;;

key1S_THREE:  CALL key1S_THREESUB                    
              
              JMP keyHdlr_1
                            
;Key16S_THREE;display "SWAP";;;;;;;;;;;;;;;;;;;;;;

key16S_THREE: CALL key16S_THREESUB                   
              
              JMP keyHdlr_1
 
;Key24S_THREE: display "log x";;;;;;;;;;;;;;;;;;;;

key24S_THREE: CALL key24_THREESUB                    
              
              JMP keyHdlr_1
              
;Key25S_THREE: display "ln x" symbol;;;;;;;;;;;;;;

key25S_THREE: CALL key25_THREESUB                   
              
              JMP keyHdlr_1

;Key26S_THREE: display "RANDOMNUMBER";;;;;;;;;;;;; 

key26S_THREE: CALL key26S_THREESUB

              JMP keyHdlr_1
              
;Key27S_THREE: display symbol for arctan x;;;;;;;;

key27S_THREE: CALL key27S_THREESUB                   
              
              JMP keyHdlr_1 
              
;Key28S_THREE: display symbol for arccos x;;;;;;;;

key28S_THREE: CALL key28S_THREESUB                    
              
              JMP keyHdlr_1 
              
;Key29S_THREE: display symbol for arcsin x;;;;;;;;

key29S_THREE: CALL key29S_THREESUB                    
              
              JMP keyHdlr_1
              
;Key30S_THREE: display "!";;;;;;;;;;;;;;;;;;;;;;;;

key30S_THREE: CALL key30S_THREESUB                  
              
              JMP keyHdlr_1
              
;Key31S_THREE: display y^(1/x) symbol;;;;;;;;;;;;;;

key31S_THREE: CALL key31S_THREESUB                     
              
              JMP keyHdlr_1
              
;Key32S_THREE: display square root symbol;;;;;;;;;

key32S_THREE: CALL key32_THREESUB          
              
              JMP keyHdlr_1
             
;Key34S_THREE;DECIMAL -> DMS;;;;;;;;;;;;;;;;;;;;;;

key34S_THREE: CALL key34_THREESUB

              JMP keyHdlr_1
              
;Key35S_THREE;DMS -> DECIMAL;;;;;;;;;;;;;;;;;;;;;;

key35S_THREE: CALL key35_THREESUB 

              JMP keyHdlr_1
                                        
;Key0T_THREE: display "Z->";;;;;;;;;;;;;;;;;;;;;;;

key0T_THREE:  CALL key0T_THREESUB                   
              
              JMP keyHdlr_1
              
;Key1T_THREE: display "Y->";;;;;;;;;;;;;;;;;;;;;;;

key1T_THREE:  CALL key1T_THREESUB                 
              
              JMP keyHdlr_1
              
;Key2T_THREE: display "X->";;;;;;;;;;;;;;;;;;;;;;;

key2T_THREE:  CALL key2T_THREESUB                    
              
              JMP keyHdlr_1
              
;Key3T_THREE: display "W->";;;;;;;;;;;;;;;;;;;;;;;

key3T_THREE:  CALL key3T_THREESUB                 
              
              JMP keyHdlr_1
              
;Key4T_THREE: display "V->";;;;;;;;;;;;;;;;;;;;;;;

key4T_THREE:  CALL key4T_THREESUB                  
              
              JMP keyHdlr_1
              
;Key6T_THREE: display "U->";;;;;;;;;;;;;;;;;;;;;;;

key6T_THREE:  CALL key6T_THREESUB                     
              
              JMP keyHdlr_1
              
;Key7T_THREE: display "T->";;;;;;;;;;;;;;;;;;;;;;;

key7T_THREE:  CALL key7T_THREESUB                 
              
              JMP keyHdlr_1
              
;Key8T_THREE: display "S->";;;;;;;;;;;;;;;;;;;;;;;

key8T_THREE:  CALL key8T_THREESUB                   
              
              JMP keyHdlr_1
              
;Key9T_THREE: display "R->";;;;;;;;;;;;;;;;;;;;;;;

key9T_THREE:  CALL key9T_THREESUB                   
              
              JMP keyHdlr_1
              
;Key10T_THREE: display "Q->";;;;;;;;;;;;;;;;;;;;;;

key10T_THREE: CALL key10T_THREESUB             
              
              JMP keyHdlr_1
              
;Key12T_THREE: display "P->";;;;;;;;;;;;;;;;;;;;;;

key12T_THREE: CALL key12T_THREESUB                
              
              JMP keyHdlr_1
              
;Key13T_THREE: display "O->";;;;;;;;;;;;;;;;;;;;;;

key13T_THREE: CALL key13T_THREESUB

              JMP keyHdlr_1
              
;Key14T_THREE: display "N->";;;;;;;;;;;;;;;;;;;;;;

key14T_THREE: CALL key14T_THREESUB                   
              
              JMP keyHdlr_1
              
;Key15T_THREE: display "M->";;;;;;;;;;;;;;;;;;;;;;

key15T_THREE: CALL key15T_THREESUB               
              
              JMP keyHdlr_1
              
;Key16T_THREE: display "L->";;;;;;;;;;;;;;;;;;;;;;

key16T_THREE: CALL key16T_THREESUB                    
              
              JMP keyHdlr_1
              
;Key18T_THREE: display "K->";;;;;;;;;;;;;;;;;;;;;;

key18T_THREE: CALL key18T_THREESUB                   
              
              JMP keyHdlr_1
              
;Key19T_THREE: display "J->";;;;;;;;;;;;;;;;;;;;;;

key19T_THREE: CALL key19T_THREESUB                   
              
              JMP keyHdlr_1
              
;Key20T_THREE: display "I->";;;;;;;;;;;;;;;;;;;;;;

key20T_THREE: CALL key20T_THREESUB                  
              
              JMP keyHdlr_1
              
;Key21T_THREE: display "H->";;;;;;;;;;;;;;;;;;;;;;

key21T_THREE: CALL key21T_THREESUB                    
              
              JMP keyHdlr_1
              
;Key22T_THREE: display "G->";;;;;;;;;;;;;;;;;;;;;;

key22T_THREE: CALL key22T_THREESUB                    
              
              JMP keyHdlr_1
              
;Key24T_THREE: display "F->";;;;;;;;;;;;;;;;;;;;;;

key24T_THREE: CALL key24T_THREESUB                     
              
              JMP keyHdlr_1
              
;Key25T_THREE: display "E->";;;;;;;;;;;;;;;;;;;;;;

key25T_THREE: CALL key25T_THREESUB                     
              
              JMP keyHdlr_1
              
;Key26T_THREE: display "D->";;;;;;;;;;;;;;;;;;;;;;

key26T_THREE: CALL key26T_THREESUB                     
              
              JMP keyHdlr_1
              
;Key27T_THREE: display "C->";;;;;;;;;;;;;;;;;;;;;;

key27T_THREE: CALL key27T_THREESUB                       
              
              JMP keyHdlr_1
              
;Key28T_THREE: display "B->";;;;;;;;;;;;;;;;;;;;;;

key28T_THREE: CALL key28T_THREESUB                     
              
              JMP keyHdlr_1
              
;Key29T_THREE: display "A->";;;;;;;;;;;;;;;;;;;;;;

key29T_THREE: CALL key29T_THREESUB                    
              
              JMP keyHdlr_1
              
;Key126_THREE: display "END";;;;;;;;;;;;;;;;;;;;;; 

key126_THREE: CALL key126_THREESUB                    
              
              JMP keyHdlr_1

;Key127_THREE: display "TIMERON";;;;;;;;;;;;;;;;;;

key127_THREE: CALL key127_THREESUB                   
              
              JMP keyHdlr_1
              
;Key128_THREE: display "TIMEROFF";;;;;;;;;;;;;;;;;

key128_THREE: CALL key128_THREESUB                   
              
              JMP keyHdlr_1              
           
;Key131_THREE: display "|Z|";;;;;;;;;;;;;;;;;;;;;;

key131_THREE: CALL key131_THREESUB                   
              
              JMP keyHdlr_1 

;Key134_THREE: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key134_THREE: NOP

;Key137_THREE: display "REAL->COMPLEX";;;;;;;;;;;;

key137_THREE: CALL key137_THREESUB                     
              
              JMP keyHdlr_1 

;Key138_THREE: display "CONJUGATEOFZ";;;;;;;;;;;;;

key138_THREE: CALL key138_THREESUB                     
              
              JMP keyHdlr_1

;Key143_THREE: display "PICK";;;;;;;;;;;;;;;;;;;;;

key143_THREE: CALL key143_THREESUB 

              JMP keyHdlr_1              
              
;Key144_THREE: display "->Z";;;;;;;;;;;;;;;;;;;;;;

key144_THREE: CALL key144_THREESUB                    
              
              JMP keyHdlr_1
              
;Key145_THREE: display "->Y";;;;;;;;;;;;;;;;;;;;;;

key145_THREE: CALL key145_THREESUB                      
              
              JMP keyHdlr_1
              
;Key146_THREE: display "->X";;;;;;;;;;;;;;;;;;;;;;

key146_THREE: CALL key146_THREESUB                  
              
              JMP keyHdlr_1
              
;Key147_THREE: display "->W";;;;;;;;;;;;;;;;;;;;;;

key147_THREE: CALL key147_THREESUB                 
              
              JMP keyHdlr_1
              
;Key148_THREE: display "->V";;;;;;;;;;;;;;;;;;;;;;

key148_THREE: CALL key148_THREESUB                     
              
              JMP keyHdlr_1
              
;Key149_THREE: display "->U";;;;;;;;;;;;;;;;;;;;;;

key149_THREE: CALL key149_THREESUB                   
              
              JMP keyHdlr_1 
              
;Key150_THREE: display "->T";;;;;;;;;;;;;;;;;;;;;;

key150_THREE: CALL key150_THREESUB                    
              
              JMP keyHdlr_1
              
;Key151_THREE: display "->S";;;;;;;;;;;;;;;;;;;;;;

key151_THREE: CALL key151_THREESUB                 
              
              JMP keyHdlr_1 
              
;Key152_THREE: display "->R";;;;;;;;;;;;;;;;;;;;;;

key152_THREE: CALL key152_THREESUB                   
              
              JMP keyHdlr_1
              
;Key153_THREE: display "->Q";;;;;;;;;;;;;;;;;;;;;;

key153_THREE: CALL key153_THREESUB                   
              
              JMP keyHdlr_1 
              
;Key154_THREE: display "->P";;;;;;;;;;;;;;;;;;;;;;

key154_THREE: CALL key154_THREESUB                     
              
              JMP keyHdlr_1
              
;Key155_THREE: display "->O";;;;;;;;;;;;;;;;;;;;;;

key155_THREE: CALL key155_THREESUB                     
              
              JMP keyHdlr_1 
              
;Key156_THREE: display "->N";;;;;;;;;;;;;;;;;;;;;;

key156_THREE: CALL key156_THREESUB                   
              
              JMP keyHdlr_1
              
;Key157_THREE: display "->M";;;;;;;;;;;;;;;;;;;;;;

key157_THREE: CALL key157_THREESUB                   
              
              JMP keyHdlr_1 
              
;Key158_THREE: display "->L";;;;;;;;;;;;;;;;;;;;;;

key158_THREE: CALL key158_THREESUB 

              JMP keyHdlr_1
              
;Key159_THREE: display "->K";;;;;;;;;;;;;;;;;;;;;;

key159_THREE: CALL key159_THREESUB                      
              
              JMP keyHdlr_1 
              
;Key160_THREE: display "->J";;;;;;;;;;;;;;;;;;;;;;

key160_THREE: CALL key160_THREESUB                    
              
              JMP keyHdlr_1
              
;Key161_THREE: display "->I";;;;;;;;;;;;;;;;;;;;;;

key161_THREE: CALL key161_THREESUB                    
              
              JMP keyHdlr_1 
              
;Key162_THREE: display "->H";;;;;;;;;;;;;;;;;;;;;;

key162_THREE: CALL key162_THREESUB                    
              
              JMP keyHdlr_1
              
;Key163_THREE: display "->G";;;;;;;;;;;;;;;;;;;;;;

key163_THREE: CALL key163_THREESUB                    
              
              JMP keyHdlr_1 
              
;Key164_THREE: display "->F";;;;;;;;;;;;;;;;;;;;;;

key164_THREE: CALL key164_THREESUB                    
              
              JMP keyHdlr_1
              
;Key165_THREE: display "->E";;;;;;;;;;;;;;;;;;;;;;

key165_THREE: CALL key165_THREESUB                   
              
              JMP keyHdlr_1 
              
;Key166_THREE: display "->D";;;;;;;;;;;;;;;;;;;;;;

key166_THREE: CALL key166_THREESUB                    
              
              JMP keyHdlr_1
              
;Key167_THREE: display "->C";;;;;;;;;;;;;;;;;;;;;;

key167_THREE: CALL key167_THREESUB                  
              
              JMP keyHdlr_1 
              
;Key168_THREE: display "->B";;;;;;;;;;;;;;;;;;;;;;

key168_THREE: CALL key168_THREESUB                   
              
              JMP keyHdlr_1
              
;Key169_THREE: display "->A";;;;;;;;;;;;;;;;;;;;;;

key169_THREE: CALL key169_THREESUB                    
              
              JMP keyHdlr_1
              
;key170_THREE: display "ROTATE";;;;;;;;;;;;;;;;;;;

key170_THREE: CALL key170_THREESUB                   
              
              JMP keyHdlr_1 

;key171_THREE: display "DELETE2";;;;;;;;;;;;;;;;;;

key171_THREE: CALL key171_THREESUB                     
              
              JMP keyHdlr_1
              
;key172_THREE: display "UNROTATE";;;;;;;;;;;;;;;;;

key172_THREE: CALL key172_THREESUB                      
              
              JMP keyHdlr_1

;key173_THREE: display "DELETE3";;;;;;;;;;;;;;;;;;

key173_THREE: CALL key173_THREESUB                      
              
              JMP keyHdlr_1
              
;key174_THREE: display "ENTER2";;;;;;;;;;;;;;;;;;;

key174_THREE: CALL key174_THREESUB                    
              
              JMP keyHdlr_1

;key175_THREE: display "OVER";;;;;;;;;;;;;;;;;;;;;

key175_THREE: CALL key175_THREESUB                     
              
              JMP keyHdlr_1

;key176_THREE: display "POLARFORMOFZ";;;;;;;;;;;;;;

key176_THREE: CALL key176_THREESUB                      
              
              JMP keyHdlr_1
              
;key177_THREE: display "ENTER3";;;;;;;;;;;;;;;;;;;

key177_THREE: CALL key177_THREESUB                     
              
              JMP keyHdlr_1

;key178_THREE: display "DEPTH";;;;;;;;;;;;;;;;;;;;

key178_THREE: CALL key178_THREESUB                 
              
              JMP keyHdlr_1 
              
;key179_THREE: display "ENTER4";;;;;;;;;;;;;;;;;;;

key179_THREE: CALL key179_THREESUB                     
              
              JMP keyHdlr_1

;key181_THREE: display "->x(K)";;;;;;;;;;;;;;;;;;;

key181_THREE: CALL key181_THREESUB                    
              
              JMP keyHdlr_1
              
;key182_THREE: display "x(K)->";;;;;;;;;;;;;;;;;;;

key182_THREE: CALL key182_THREESUB                     
              
              JMP keyHdlr_1
              
;key183_THREE: display "INCREMENTK";;;;;;;;;;;;;;;

key183_THREE: CALL key183_THREESUB                     
              
              JMP keyHdlr_1

;key184_THREE: display "DECREMENTK";;;;;;;;;;;;;;;

key184_THREE: CALL key184_THREESUB                   
              
              JMP keyHdlr_1

;key185_THREE: display "HALT";;;;;;;;;;;;;;;;;;;;;

key185_THREE: CALL key185_THREESUB                   
              
              JMP keyHdlr_1

;key186_THREE: display "DELAYK";;;;;;;;;;;;;;;;;;;

key186_THREE: CALL key186_THREESUB                    
              
              JMP keyHdlr_1 

;key187_THREE: display "BUSYON";;;;;;;;;;;;;;;;;;;

key187_THREE: CALL key187_THREESUB                    
              
              JMP keyHdlr_1 

;key188_THREE: display "BUSYOFF";;;;;;;;;;;;;;;;;;

key188_THREE: CALL key188_THREESUB                    
              
              JMP keyHdlr_1

;key189_THREE: display "ERRORON";;;;;;;;;;;;;;;;;;

key189_THREE: CALL key189_THREESUB                 
              
              JMP keyHdlr_1

;key190_THREE: display "ERROROFF";;;;;;;;;;;;;;;;;

key190_THREE: CALL key190_THREESUB                   
              
              JMP keyHdlr_1
              
;key191_THREE: display "SCANKEYPAD";;;;;;;;;;;;;;;

key191_THREE: CALL key191_THREESUB                     
              
              JMP keyHdlr_1

;key192_THREE: display "KEYNUMBER->";;;;;;;;;;;;;;

key192_THREE: CALL key192_THREESUB                    
              
              JMP keyHdlr_1

;key193_THREE: display "NOP";;;;;;;;;;;;;;;;;;;;;

key193_THREE: CALL key193_THREESUB                     
              
              JMP keyHdlr_1

;key194_THREE: display "sinh x";;;;;;;;;;;;;;;;;;;

key194_THREE: CALL key194_THREESUB                     
              
              JMP keyHdlr_1

;key195_THREE: display "cosh x";;;;;;;;;;;;;;;;;;;

key195_THREE: CALL key195_THREESUB                    
              
              JMP keyHdlr_1
              
;key196_THREE: display "tanh x";;;;;;;;;;;;;;;;;;;

key196_THREE: CALL key196_THREESUB                    
              
              JMP keyHdlr_1

;key197_THREE: display symbol for arcsinh x;;;;;;;

key197_THREE: CALL key197_THREESUB                    
              
              JMP keyHdlr_1

;key198_THREE: display symbol for arccosh x;;;;;;;

key198_THREE: CALL key198_THREESUB                     
              
              JMP keyHdlr_1

;key199_THREE: display symbol for arctanh x;;;;;;;

key199_THREE: CALL key199_THREESUB                     
              
              JMP keyHdlr_1

;key200_THREE: display symbol for floor function;;

key200_THREE: CALL key200_THREESUB                     
              
              JMP keyHdlr_1

;key201_THREE: display "RETFRMSUBRTE";;;;;;;;;;;;;

key201_THREE: CALL key201_THREESUB                     
              
              JMP keyHdlr_1
              
;key202_THREE: display "|X|";;;;;;;;;;;;;;;;;;;;;;

key202_THREE: CALL key202_THREESUB 
              
              JMP keyHdlr_1

;key203_THREE: display "->RANDOM#SEED";;;;;;;;;;;;

key203_THREE: CALL key203_THREESUB

              JMP keyHdlr_1

;key204_THREE: display "PERMUTATION";;;;;;;;;;;;;;

key204_THREE: CALL key204_THREESUB 

              JMP keyHdlr_1

;key205_THREE: display "COMBINATION";;;;;;;;;;;;;;

key205_THREE: CALL key205_THREESUB 

              JMP keyHdlr_1

;key206_THREE: display symbol for ceiling function

key206_THREE: CALL key206_THREESUB                     
              
              JMP keyHdlr_1 

;key209_THREE: display "COMPLEX->REAL";;;;;;;;;;;;

key209_THREE: CALL key209_THREESUB 

              JMP keyHdlr_1 

;key210_THREE: display "CARTFORMOFZ";;;;;;;;;;;;;; 

key210_THREE: CALL key210_THREESUB 

              JMP keyHdlr_1
              
;key211_THREE: display mean of x symbol;;;;;;;;;;; 

key211_THREE: CALL key211_THREESUB 

              JMP keyHdlr_1  

;key212_THREE: display "GCD(a,b)";;;;;;;;;;;;;;;;;

key212_THREE: CALL key212_THREESUB 

              JMP keyHdlr_1

;key213_THREE: display "LCM(a,b)";;;;;;;;;;;;;;;;; 

key213_THREE: CALL key213_THREESUB  

              JMP keyHdlr_1

;key222_THREE: display underlined (indirect) "GOTO"

key222_THREE: CALL key222_THREESUB                   
              
              JMP keyHdlr_1

;key223_THREE: display underlined (indirect) "GOTOIF=0"

key223_THREE: CALL key223_THREESUB                   
              
              JMP keyHdlr_1

;key224_THREE: display underlined (indirect) "GOTOIF<>0"

key224_THREE: CALL key224_THREESUB                   
              
              JMP keyHdlr_1 

;key225_THREE: display underlined (indirect) "GOTOIF="

key225_THREE: CALL key225_THREESUB                   
              
              JMP keyHdlr_1 

;key226_THREE: display underlined (indirect) "GOTOIF<>"

key226_THREE: CALL key226_THREESUB                   
              
              JMP keyHdlr_1 

;key227_THREE: display underlined (indirect) "GOTOIF>"

key227_THREE: CALL key227_THREESUB                   
              
              JMP keyHdlr_1

;key228_THREE: display underlined (indirect) "GOTOIF<"

key228_THREE: CALL key228_THREESUB                   
              
              JMP keyHdlr_1

;key229_THREE: display underlined (indirect) "GOTOIF>="

key229_THREE: CALL key229_THREESUB                   
              
              JMP keyHdlr_1

;key230_THREE: display underlined (indirect) "GOTOIF<="

key230_THREE: CALL key230_THREESUB                   
              
              JMP keyHdlr_1

;key231_THREE: display underlined (indirect) "GOTOIFKEYPRS"

key231_THREE: CALL key231_THREESUB                   
              
              JMP keyHdlr_1

;key232_THREE: display underlined (indirect) "GOTOIF=x(K)"

key232_THREE: CALL key232_THREESUB
              
              JMP keyHdlr_1 

;key233_THREE: display underlined (indirect) "GOTOIF<>x(K)"

key233_THREE: CALL key233_THREESUB
              
              JMP keyHdlr_1

;key234_THREE: display underlined (indirect) "GOTOIF>=x(K)"

key234_THREE: CALL key234_THREESUB
              
              JMP keyHdlr_1 

;key235_THREE: display underlined (indirect) "GOTOIF<=x(K)"

key235_THREE: CALL key235_THREESUB
              
              JMP keyHdlr_1              

;key214_THREE;display "2^x";;;;;;;;;;;;;;;;;;;;;;

key214_THREE: CALL key214_THREESUB

              JMP keyHdlr_1

;key215_THREE;display "ld x";;;;;;;;;;;;;;;;;;;;;;

key215_THREE: CALL key215_THREESUB

              JMP keyHdlr_1              
              
;key216_THREE;display "->y(K)";;;;;;;;;;;;;;;;;;;

key216_THREE: CALL key216_THREESUB

              JMP keyHdlr_1 
              
;key217_THREE;display "y(K)->";;;;;;;;;;;;;;;;;;;

key217_THREE: CALL key217_THREESUB

              JMP keyHdlr_1          

;key236_THREE: for "reserved" function;;;;;;;;;;;;

key236_THREE: JMP keyHdlr_1 

;key237_THREE: for "reserved" function;;;;;;;;;;;;

key237_THREE: JMP keyHdlr_1

;key238_THREE: for "reserved" function;;;;;;;;;;;;

key238_THREE: JMP keyHdlr_1 

;key239_THREE: display "2BYTEINSTRUC";;;;;;;;;;;;;

key239_THREE: CALL key239_THREESUB                    
              
              JMP keyHdlr_1
              
;key240_THREE: display "GOTO";;;;;;;;;;;;;;;;;;;;;

key240_THREE: CALL key240_THREESUB                   
              
              JMP keyHdlr_1

;key241_THREE: display "GOTOIF=0";;;;;;;;;;;;;;;;;

key241_THREE: CALL key241_THREESUB                 
              
              JMP keyHdlr_1

;key242_THREE: display "GOTOIF<>0";;;;;;;;;;;;;;;;

key242_THREE: CALL key242_THREESUB                 
              
              JMP keyHdlr_1

;key243_THREE: display "GOTOIF=";;;;;;;;;;;;;;;;;;

key243_THREE: CALL key243_THREESUB                 
              
              JMP keyHdlr_1 

;key244_THREE: display "GOTOIF<>";;;;;;;;;;;;;;;;;

key244_THREE: CALL key244_THREESUB                  
              
              JMP keyHdlr_1

;key245_THREE: display "GOTOIF>";;;;;;;;;;;;;;;;;;

key245_THREE: CALL key245_THREESUB                  
              
              JMP keyHdlr_1 

;key246_THREE: display "GOTOIF<";;;;;;;;;;;;;;;;;;

key246_THREE: CALL key246_THREESUB                   
              
              JMP keyHdlr_1

;key247_THREE: display "GOTOIF>=";;;;;;;;;;;;;;;;;

key247_THREE: CALL key247_THREESUB                 
              
              JMP keyHdlr_1 

;key248_THREE: display "GOTOIF<=";;;;;;;;;;;;;;;;;

key248_THREE: CALL key248_THREESUB                 
              
              JMP keyHdlr_1 

;key249_THREE: display "GOTOIFKEYPRS";;;;;;;;;;;;;;;;;

key249_THREE: CALL key249_THREESUB

              JMP keyHdlr_1

;key250_THREE: display "GOTOIF=x(K)";;;;;;;;;;;;;

key250_THREE: CALL key250_THREESUB
              
              JMP keyHdlr_1
              
;key251_THREE: display "GOTOIF<>x(K)";;;;;;;;;;;;;

key251_THREE: CALL key251_THREESUB
              
              JMP keyHdlr_1

;key252_THREE: display "GOTOIF>=x(K)";;;;;;;;;;;;;

key252_THREE: CALL key252_THREESUB
              
              JMP keyHdlr_1                     

;key253_THREE: display "GOTOIF<=x(K)";;;;;;;;;;;;;

key253_THREE: CALL key253_THREESUB
              
              JMP keyHdlr_1
              
;key254_THREE: display "GOTOIFCMDEMP";;;;;;;;;;;;;

key254_THREE: CALL key254_THREESUB 

              JMP keyHdlr_1

;key255_THREE: display "JUMPTOSUBRTE";;;;;;;;;;;;;

key255_THREE: CALL key255_THREESUB                    
              
              JMP keyHdlr_1

;keyEF0_THREE: display "SETDEGMODE";;;;;;;;;;;;;;;

keyEF0_THREE: CALL keyEF0_THREESUB

              JMP keyHdlr_1

;keyEF1_THREE: display "SETRADMODE";;;;;;;;;;;;;;;

keyEF1_THREE: CALL keyEF1_THREESUB

              JMP keyHdlr_1

;keyEF2_THREE: display "SETGRAMODE";;;;;;;;;;;;;;;

keyEF2_THREE: CALL keyEF2_THREESUB

              JMP keyHdlr_1

;keyEF3_THREE: display "SETAPXMODE";;;;;;;;;;;;;;;

keyEF3_THREE: CALL keyEF3_THREESUB

              JMP keyHdlr_1

;keyEF4_THREE: display "SETEXTMODE";;;;;;;;;;;;;;;

keyEF4_THREE: CALL keyEF4_THREESUB

              JMP keyHdlr_1

;keyEF5_THREE: display "SETCPXMODE";;;;;;;;;;;;;;;

keyEF5_THREE: CALL keyEF5_THREESUB

              JMP keyHdlr_1

;keyEF6_THREE: display "SETENGMODE";;;;;;;;;;;;;;;

keyEF6_THREE: CALL keyEF6_THREESUB

              JMP keyHdlr_1

;keyEF7_THREE: display "FIX";;;;;;;;;;;;;;;;;;;;;;

keyEF7_THREE: CALL keyEF7_THREESUB

              JMP keyHdlr_1

;keyEF8_THREE: display "DISPLAYERROR"

keyEF8_THREE: CALL keyEF8_THREESUB 

              JMP keyHdlr_1                   

;keyEF9_THREE: display "SETHEXMODE";;;;;;;;;;;;;;; 

keyEF9_THREE: CALL keyEF9_THREESUB 

              JMP keyHdlr_1                   

;keyEF10_THREE: display "SETDECMODE";;;;;;;;;;;;;;

keyEF10_THREE:CALL keyEF10_THREESUB 

              JMP keyHdlr_1   

;keyEF11_THREE: display "SETBINMODE";;;;;;;;;;;;;;

keyEF11_THREE:CALL keyEF11_THREESUB 

              JMP keyHdlr_1

;keyEF12_THREE: display "SETSCIMODE";;;;;;;;;;;;;;

keyEF12_THREE:CALL keyEF12_THREESUB 

              JMP keyHdlr_1

;keyEF13_THREE:

keyEF13_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF14_THREE:

keyEF14_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF15_THREE:

keyEF15_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF16_THREE:

keyEF16_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF17_THREE:

keyEF17_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF18_THREE:

keyEF18_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF19_THREE:

keyEF19_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"   

;keyEF20_THREE: 

keyEF20_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF21_THREE: 

keyEF21_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF22_THREE:

keyEF22_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF23_THREE:

keyEF23_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF24_THREE:

keyEF24_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF25_THREE:

keyEF25_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF26_THREE:

keyEF26_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF27_THREE:

keyEF27_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF28_THREE:

keyEF28_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF29_THREE:

keyEF29_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF30_THREE: 

keyEF30_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF31_THREE: 

keyEF31_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF32_THREE:

keyEF32_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF33_THREE:

keyEF33_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF34_THREE:

keyEF34_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF35_THREE:

keyEF35_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF36_THREE:

keyEF36_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF37_THREE:

keyEF37_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF38_THREE:

keyEF38_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF39_THREE:

keyEF39_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF40_THREE: 

keyEF40_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF41_THREE: 

keyEF41_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF42_THREE:

keyEF42_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF43_THREE:

keyEF43_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF44_THREE:
       
keyEF44_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF45_THREE:

keyEF45_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF46_THREE:

keyEF46_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF47_THREE:

keyEF47_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF48_THREE:

keyEF48_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF49_THREE:

keyEF49_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF50_THREE:

keyEF50_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF51_THREE: 

keyEF51_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF52_THREE:

keyEF52_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"e 

;keyEF53_THREE:

keyEF53_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF54_THREE:
       
keyEF54_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF55_THREE:

keyEF55_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF56_THREE:

keyEF56_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF57_THREE:

keyEF57_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"e

;keyEF58_THREE:

keyEF58_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF59_THREE:

keyEF59_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF60_THREE:

keyEF60_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF61_THREE: 

keyEF61_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF62_THREE:

keyEF62_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF63_THREE:

keyEF63_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF64_THREE:
       
keyEF64_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF65_THREE:

keyEF65_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF66_THREE:

keyEF66_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF67_THREE:

keyEF67_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF68_THREE:

keyEF68_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF69_THREE:

keyEF69_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF70_THREE:

keyEF70_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF71_THREE: 

keyEF71_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF72_THREE:

keyEF72_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF73_THREE:

keyEF73_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF74_THREE:
       
keyEF74_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF75_THREE:

keyEF75_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF76_THREE:

keyEF76_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF77_THREE:

keyEF77_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF78_THREE:

keyEF78_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF79_THREE:

keyEF79_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF80_THREE:

keyEF80_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF81_THREE: 

keyEF81_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF82_THREE:

keyEF82_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF83_THREE:

keyEF83_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF84_THREE:
       
keyEF84_THREE:CALL key193_THREESUB

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF85_THREE:

keyEF85_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF86_THREE:

keyEF86_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF87_THREE:

keyEF87_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF88_THREE:

keyEF88_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF89_THREE:

keyEF89_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF90_THREE:

keyEF90_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF91_THREE: 

keyEF91_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF92_THREE:

keyEF92_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF93_THREE:

keyEF93_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF94_THREE:
       
keyEF94_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF95_THREE:

keyEF95_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF96_THREE:

keyEF96_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF97_THREE:

keyEF97_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF98_THREE:

keyEF98_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP" 

;keyEF99_THREE:

keyEF99_THREE:CALL key193_THREESUB 

              JMP keyHdlr_1                   ;display "NOP"

;keyEF100_THREE: 

keyEF100_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP"
 
;keyEF101_THREE: 

keyEF101_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP"
               
;keyEF102_THREE:

keyEF102_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP"               

;keyEF103_THREE:

keyEF103_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP"               

;keyEF104_THREE:

keyEF104_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF105_THREE:

keyEF105_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF106_THREE:

keyEF106_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF107_THREE:

keyEF107_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF108_THREE:

keyEF108_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF109_THREE:

keyEF109_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF110_THREE: 

keyEF110_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF111_THREE: 

keyEF111_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 
              
;keyEF112_THREE:

keyEF112_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF113_THREE:

keyEF113_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF114_THREE:

keyEF114_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF115_THREE:

keyEF115_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF116_THREE:

keyEF116_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" 

;keyEF117_THREE:

keyEF117_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP" "

;keyEF118_THREE:

keyEF118_THREE:CALL key193_THREESUB 

               JMP keyHdlr_1                   ;display "NOP"  

;keyEF119_THREE:

keyEF119_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1                      

;keyEF120_THREE: 

keyEF120_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1
               
;keyEF121_THREE: 

keyEF121_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF122_THREE:

keyEF122_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF123_THREE:

keyEF123_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF124_THREE:

keyEF124_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1 

;keyEF125_THREE:

keyEF125_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF126_THREE:

keyEF126_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF127_THREE:

keyEF127_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF128_THREE:

keyEF128_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF129_THREE:

keyEF129_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF130_THREE: 

keyEF130_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF131_THREE: 

keyEF131_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF132_THREE:

keyEF132_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF133_THREE:

keyEF133_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF134_THREE:

keyEF134_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF135_THREE:

keyEF135_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF136_THREE:

keyEF136_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF137_THREE:

keyEF137_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF138_THREE:

keyEF138_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF139_THREE:

keyEF139_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1 

;keyEF140_THREE: 

keyEF140_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF141_THREE: 

keyEF141_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF142_THREE:

keyEF142_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF143_THREE:

keyEF143_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF144_THREE:
       
keyEF144_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF145_THREE:

keyEF145_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF146_THREE:

keyEF146_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF147_THREE:

keyEF147_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF148_THREE:

keyEF148_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF149_THREE:

keyEF149_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF150_THREE:

keyEF150_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF151_THREE: 

keyEF151_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF152_THREE:

keyEF152_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1 

;keyEF153_THREE:

keyEF153_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF154_THREE:
       
keyEF154_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1 

;keyEF155_THREE:

keyEF155_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF156_THREE:

keyEF156_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF157_THREE:

keyEF157_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF158_THREE:

keyEF158_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF159_THREE:

keyEF159_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF160_THREE:

keyEF160_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF161_THREE: 

keyEF161_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF162_THREE:

keyEF162_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1 

;keyEF163_THREE:

keyEF163_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF164_THREE:
       
keyEF164_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF165_THREE:

keyEF165_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF166_THREE:

keyEF166_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF167_THREE:

keyEF167_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF168_THREE:

keyEF168_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF169_THREE:

keyEF169_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF170_THREE:

keyEF170_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF171_THREE: 

keyEF171_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF172_THREE:

keyEF172_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF173_THREE:

keyEF173_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF174_THREE:
       
keyEF174_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF175_THREE:

keyEF175_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF176_THREE:

keyEF176_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF177_THREE:

keyEF177_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF178_THREE:

keyEF178_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1
;keyEF179_THREE:

keyEF179_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF180_THREE:

keyEF180_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF181_THREE: 

keyEF181_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF182_THREE:

keyEF182_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1 

;keyEF183_THREE:

keyEF183_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF184_THREE:
       
keyEF184_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF185_THREE:

keyEF185_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF186_THREE:

keyEF186_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF187_THREE:

keyEF187_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF188_THREE:

keyEF188_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF189_THREE:

keyEF189_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF190_THREE:

keyEF190_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF191_THREE: 

keyEF191_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF192_THREE:

keyEF192_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF193_THREE:

keyEF193_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF194_THREE:
       
keyEF194_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF195_THREE:

keyEF195_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF196_THREE:

keyEF196_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1 

;keyEF197_THREE:

keyEF197_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF198_THREE:

keyEF198_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF199_THREE:

keyEF199_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF200_THREE: 

keyEF200_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF201_THREE: 

keyEF201_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF202_THREE:

keyEF202_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1
     
;keyEF203_THREE:

keyEF203_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF204_THREE:

keyEF204_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF205_THREE:

keyEF205_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF206_THREE:

keyEF206_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF207_THREE:

keyEF207_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF208_THREE:

keyEF208_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF209_THREE:

keyEF209_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF210_THREE: 

keyEF210_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF211_THREE: 

keyEF211_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1
              
;keyEF212_THREE:

keyEF212_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF213_THREE:

keyEF213_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF214_THREE:

keyEF214_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF215_THREE:

keyEF215_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF216_THREE:

keyEF216_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF217_THREE:

keyEF217_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF218_THREE:

keyEF218_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF219_THREE:

keyEF219_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1  

;keyEF220_THREE: 

keyEF220_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF221_THREE: 

keyEF221_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF222_THREE:

keyEF222_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF223_THREE:

keyEF223_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF224_THREE:

keyEF224_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF225_THREE:

keyEF225_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF226_THREE:

keyEF226_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF227_THREE:

keyEF227_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF228_THREE:

keyEF228_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF229_THREE:

keyEF229_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF230_THREE: 

keyEF230_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF231_THREE: 

keyEF231_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF232_THREE:

keyEF232_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF233_THREE:

keyEF233_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF234_THREE:

keyEF234_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF235_THREE:

keyEF235_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF236_THREE:

keyEF236_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF237_THREE:

keyEF237_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF238_THREE:

keyEF238_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1 

;keyEF239_THREE:

keyEF239_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF240_THREE: 

keyEF240_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF241_THREE: 

keyEF241_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF242_THREE:

keyEF242_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF243_THREE:

keyEF243_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF244_THREE:
       
keyEF244_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF245_THREE:

keyEF245_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF246_THREE:

keyEF246_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF247_THREE:

keyEF247_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF248_THREE:

keyEF248_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF249_THREE:

keyEF249_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF250_THREE:

keyEF250_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF251_THREE: 

keyEF251_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF252_THREE:

keyEF252_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF253_THREE:

keyEF253_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1

;keyEF254_THREE:
       
keyEF254_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1 

;keyEF255_THREE:

keyEF255_THREE:CALL key193_THREESUB              ;display "NOP" 

               JMP keyHdlr_1 
              
;*********Symbol used in exePrg subroutine********

R             DC.B $00, $7F, $09, $19, $29, $46               ;R

;**Symbols used in both user mode and program edit mode**

Alpha         DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $FC, $24, $24, $24, $18               ;p
              DC.B $00, $7F, $08, $04, $04, $78               ;h
              DC.B $00, $20, $54, $54, $54, $78               ;a

Approx        DC.B $00, $24, $48, $24, $12, $24               ;~

decPoint      DC.B $00, $00, $60, $60, $00, $00, $00, $00

DigitSL       DC.B $00, $3E, $51, $49, $45, $3E               ;0
              DC.B $00, $00, $42, $7F, $40, $00               ;1
              DC.B $00, $42, $61, $51, $49, $46               ;2
              DC.B $00, $21, $41, $45, $4B, $31               ;3
              DC.B $00, $18, $14, $12, $7F, $10               ;4
              DC.B $00, $27, $45, $45, $45, $39               ;5
              DC.B $00, $3C, $4A, $49, $49, $30               ;6
              DC.B $00, $01, $71, $09, $05, $03               ;7
              DC.B $00, $36, $49, $49, $49, $36               ;8
              DC.B $00, $06, $49, $49, $29, $1E               ;9
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $49, $49, $49, $36               ;B
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $09, $09, $09, $01               ;F
              
Digit         DC.B $3E, $7F, $71, $59, $4D, $7F, $3E, $00	    ;0
              DC.B $00, $02, $7F, $7F, $00, $00, $00, $00	    ;1
              DC.B $62, $73, $59, $49, $4F, $46, $00, $00	    ;2
              DC.B $22, $63, $49, $49, $7F, $36, $00, $00	    ;3
              DC.B $18, $1C, $16, $13, $7F, $7F, $10, $00	    ;4
              DC.B $27, $67, $45, $45, $7D, $39, $00, $00	    ;5
              DC.B $3C, $7E, $4B, $49, $79, $30, $00, $00	    ;6
              DC.B $01, $01, $71, $79, $0F, $07, $00, $00	    ;7
              DC.B $36, $7F, $49, $49, $7F, $36, $00, $00     ;8
              DC.B $06, $4F, $49, $69, $3F, $1E, $00, $00	    ;9
              DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A
              DC.B $00, $7F, $7F, $49, $49, $7F, $36, $00	    ;B
              DC.B $1C, $3E, $63, $41, $41, $63, $22, $00     ;C
              DC.B $00, $7F, $7F, $41, $63, $3E, $1C, $00	    ;D
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7F, $7F, $09, $09, $01, $01, $00	    ;F 
              
Div           DC.B $60, $30, $18, $0C, $06, $03, $01, $00	    ;/

Exact         DC.B $00, $24, $24, $24, $24, $24               ;=  

Imag          DC.B $00, $00, $00, $7D, $7D, $00, $00, $00	    ;i

Minus         DC.B $00, $00, $08, $08, $08, $08, $08, $00     ;-

Plus          DC.B $08, $08, $3E, $3E, $08, $08, $00, $00	    ;+ 

Rcl           DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $7F, $40, $40, $40, $40               ;L

Shift         DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $7F, $08, $04, $04, $78               ;h
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $08, $7E, $09, $01, $02               ;f
              DC.B $00, $04, $3F, $44, $40, $20               ;t

stackLevels   DC.B $C1, $80, $8E, $A6, $B2, $80, $C1, $FF 	  ;0 inverted
              DC.B $FF, $FF, $FD, $80, $80, $FF, $FF, $FF     ;1 inverted 
              DC.B $FF, $9D, $8C, $A6, $B6, $B0, $B9, $FF     ;2 inverted
              DC.B $FF, $DD, $9C, $B6, $B6, $80, $C9, $FF     ;3 inverted
              DC.B $FF, $E7, $E3, $E9, $EC, $80, $80, $EF     ;4 inverted
              DC.B $FF, $D8, $98, $BA, $BA, $82, $C6, $FF	    ;5 inverted 
              DC.B $FF, $C3, $81, $B4, $B6, $86, $CF, $FF 	  ;6 inverted
              DC.B $FF, $FE, $FE, $8E, $86, $F0, $F8, $FF   	;7 inverted  
              DC.B $FF, $C9, $80, $B6, $B6, $80, $C9, $FF 	  ;8 inverted
              DC.B $FF, $F9, $B0, $B6, $96, $C0, $E1, $FF	    ;9 inverted	   
              
Space         DC.B $00, $00, $00, $00, $00, $00, $00, $00     ;

Sto           DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              
Tick          DC.B $00, $00, $0F, $0F, $00, $00, $00, $00     ;'

;*****************Constant Table******************

Fact          DC.W Fact1, Fact2, Fact3, Fact4, Fact5, Fact6, Fact7, Fact8,Fact9
              DC.W Fact10, Fact11, Fact12, Fact13, Fact14

Fact1         DC.B $02, $EE, $1E, $94, $60, $94, $37, $4C     ;65! 

Fact2         DC.B $02, $F4, $CA, $14, $1A, $82, $9B, $43     ;60!

Fact3         DC.B $00, $73, $79, $1E, $1E, $42, $47, $3B     ;55!

Fact4         DC.B $01, $14, $9D, $54, $36, $EB, $EE, $32     ;50!

Fact5         DC.B $00, $6C, $CB, $B7, $FB, $5F, $C8, $2A     ;45!

Fact6         DC.B $02, $E6, $12, $14, $9F, $F3, $1A, $21     ;40!

Fact7         DC.B $00, $5D, $FA, $BC, $23, $B4, $F5, $1A     ;35!

Fact8         DC.B $00, $F1, $3E, $FE, $7C, $19, $5F, $12     ;30!

Fact9         DC.B $00, $8D, $12, $D9, $A5, $8D, $9E, $0B     ;25!

Fact10        DC.B $00, $DD, $45, $69, $FF, $40, $00, $04     ;20!

Fact11        DC.B $00, $01, $30, $77, $77, $58, $00, $00     ;15!

Fact12        DC.B $00, $00, $00, $00, $37, $5F, $00, $00     ;10!

Fact13        DC.B $00, $00, $00, $00, $00, $00, $78, $00     ;5!

Fact14        DC.B $00, $00, $00, $00, $00, $00, $01, $00     ;0! 

log2Ten       DC.B $01, $2E, $20, $AA, $68, $11, $60

log2Values    DC.W log2Value1, log2Value2, log2Value3, log2Value4, log2Value5, log2Value6, log2Value7, log2Value8
              DC.W log2Value9, log2Value10, log2Value11, log2Value12, log2Value13, log2Value14, log2Value15 

log2Value1    DC.B $00 ,$10, $00, $00, $00, $00, $00, $00     ;log2(2)               
                                                              
log2Value2    DC.B $00, $01, $37, $50, $35, $23, $74, $99     ;log2(1.1)

log2Value3    DC.B $00, $00, $14, $35, $52, $92, $97, $71     ;log2(1.01)

log2Value4    DC.B $00, $00, $01, $44, $19, $74, $17, $39     ;log2(1.001)     

log2Value5    DC.B $00, $00, $00, $14, $42, $62, $29, $11     ;log2(1.0001)

log2Value6    DC.B $00, $00, $00, $01, $44, $26, $87, $83     ;log2(1.00001)

log2Value7    DC.B $00, $00, $00, $00, $14, $42, $69, $43     ;log2(1.000001)

log2Value8    DC.B $00, $00, $00, $00, $01, $44, $26, $95     ;log2(1.0000001)

log2Value9    DC.B $00, $00, $00, $00, $00, $14, $42, $70     ;log2(1.00000001)

log2Value10   DC.B $00, $00, $00, $00, $00, $01, $44, $27     ;log2(1.000000001)

log2Value11   DC.B $00, $00, $00, $00, $00, $00, $14, $43     ;log2(1.0000000001)
                                                           
log2Value12   DC.B $00, $00, $00, $00, $00, $00, $01, $44     ;log2(1.00000000001)

log2Value13   DC.B $00, $00, $00, $00, $00, $00, $00, $14     ;log2(1.000000000001)

log2Value14   DC.B $00, $00, $00, $00, $00, $00, $00, $01     ;log2(1.0000000000001)

log2Value15   DC.B $00

negLog2Values DC.W negLog2Value1, negLog2Value2, negLog2Value3, negLog2Value4, negLog2Value5, negLog2Value6 
              DC.W negLog2Value7, negLog2Value8, negLog2Value9, negLog2Value10, negLog2Value11, negLog2Value12
              DC.W negLog2Value13, negLog2Value14, negLog2Value15
              
negLog2Value1 DC.B $99, $90, $00, $00, $00, $00, $00, $00

negLog2Value2 DC.B $99, $98, $62, $49, $64, $76, $25, $01

negLog2Value3 DC.B $99, $99, $85, $64, $47, $07, $02, $29

negLog2Value4 DC.B $99, $99, $98, $55, $80, $25, $82, $61

negLog2Value5 DC.B $99, $99, $99, $85, $57, $37, $70, $89

negLog2Value6 DC.B $99, $99, $99, $98, $55, $73, $12, $17

negLog2Value7 DC.B $99, $99, $99, $99, $85, $57, $30, $57

negLog2Value8 DC.B $99, $99, $99, $99, $98, $55, $73, $05

negLog2Value9 DC.B $99, $99, $99, $99, $99, $85, $57, $30

negLog2Value10 
              DC.B $99, $99, $99, $99, $99, $98, $55, $73

negLog2Value11 
              DC.B $99, $99, $99, $99, $99, $99, $85, $57

negLog2Value12 
              DC.B $99, $99, $99, $99, $99, $99, $98, $56

negLog2Value13 
              DC.B $99, $99, $99, $99, $99, $99, $99, $86

negLog2Value14 
              DC.B $99, $99, $99, $99, $99, $99, $99, $99

negLog2Value15 
              DC.B $00
              
log10Values   DC.W log10Value1, log10Value2, log10Value3, log10Value4, log10Value5, log10Value6, log10Value7
              DC.W log10Value8, log10Value9, log10Value10, log10Value11, log10Value12, log10Value13, log10Value14
              DC.W log10Value15               

log10Value1   DC.B $00 ,$30, $10, $29, $99, $56, $63, $98     ;log10(2)               
                                                              
log10Value2   DC.B $00, $04, $13, $92, $68, $51, $58, $23     ;log10(1.1)

log10Value3   DC.B $00, $00, $43, $21, $37, $37, $82, $64     ;log10(1.01)

log10Value4   DC.B $00, $00, $04, $34, $07, $74, $79, $32     ;log10(1.001)     

log10Value5   DC.B $00, $00, $00, $43, $42, $72, $76, $86     ;log10(1.0001)

log10Value6   DC.B $00, $00, $00, $04, $34, $29, $23, $10     ;log10(1.00001)

log10Value7   DC.B $00, $00, $00, $00, $43, $42, $94, $26     ;log10(1.000001)

log10Value8   DC.B $00, $00, $00, $00, $04, $34, $29, $45     ;log10(1.0000001)

log10Value9   DC.B $00, $00, $00, $00, $00, $43, $42, $94     ;log10(1.00000001)

log10Value10  DC.B $00, $00, $00, $00, $00, $04, $34, $29     ;log10(1.000000001)

log10Value11  DC.B $00, $00, $00, $00, $00, $00, $43, $43     ;log10(1.0000000001)
                                                           
log10Value12  DC.B $00, $00, $00, $00, $00, $00, $04, $34     ;log10(1.00000000001)

log10Value13  DC.B $00, $00, $00, $00, $00, $00, $00, $43     ;log10(1.000000000001)

log10Value14  DC.B $00, $00, $00, $00, $00, $00, $00, $04     ;log10(1.0000000000001)

log10Value15  DC.B $00

negLog10Values 
              DC.W negLog10Value1, negLog10Value2, negLog10Value3, negLog10Value4, negLog10Value5, negLog10Value6 
              DC.W negLog10Value7, negLog10Value8, negLog10Value9, negLog10Value10, negLog10Value11, negLog10Value12
              DC.W negLog10Value13, negLog10Value14, negLog10Value15
              
negLog10Value1 DC.B $99, $69, $89, $70, $00, $43, $36, $02

negLog10Value2 DC.B $99, $95, $86, $07, $31, $48, $41, $77

negLog10Value3 DC.B $99, $99, $56, $78, $62, $62, $17, $36

negLog10Value4 DC.B $99, $99, $95, $65, $92, $25, $20, $68

negLog10Value5 DC.B $99, $99, $99, $56, $57, $27, $23, $14

negLog10Value6 DC.B $99, $99, $99, $95, $65, $70, $76, $90

negLog10Value7 DC.B $99, $99, $99, $99, $56, $57, $05, $74

negLog10Value8 DC.B $99, $99, $99, $99, $95, $65, $70, $55

negLog10Value9 DC.B $99, $99, $99, $99, $99, $56, $57, $06

negLog10Value10 
               DC.B $99, $99, $99, $99, $99, $95, $65, $71

negLog10Value11 
               DC.B $99, $99, $99, $99, $99, $99, $56, $57

negLog10Value12 
               DC.B $99, $99, $99, $99, $99, $99, $95, $66

negLog10Value13 
               DC.B $99, $99, $99, $99, $99, $99, $99, $57

negLog10Value14 
               DC.B $99, $99, $99, $99, $99, $99, $99, $96

negLog10Value15
               DC.B $00
               
logETen       DC.B $00, $D1, $6B, $3C, $A7, $3E, $CD

logEValues    DC.W logEValue1, logEValue2, logEValue3, logEValue4, logEValue5, logEValue6, logEValue7, logEValue8
              DC.W logEValue9, logEValue10, logEValue11, logEValue12, logEValue13, logEValue14, logEValue15 

logEValue1    DC.B $00, $06, $93, $14, $71, $80, $55, $99                

logEValue2    DC.B $00, $00, $95, $31, $01, $79, $80, $43

logEValue3    DC.B $00, $00, $09, $95, $03, $30, $85, $32

logEValue4    DC.B $00, $00, $00, $99, $95, $00, $33, $31

logEValue5    DC.B $00, $00, $00, $09, $99, $95, $00, $03

logEValue6    DC.B $00, $00, $00, $00, $99, $99, $95, $00

logEValue7    DC.B $00, $00, $00, $00, $09, $99, $99, $95

logEValue8    DC.B $00, $00, $00, $00, $01, $00, $00, $00

logEValue9    DC.B $00, $00, $00, $00, $00, $10, $00, $00

logEValue10   DC.B $00, $00, $00, $00, $00, $01, $00, $00

logEValue11   DC.B $00, $00, $00, $00, $00, $00, $10, $00

logEValue12   DC.B $00, $00, $00, $00, $00, $00, $01, $00

logEValue13   DC.B $00, $00, $00, $00, $00, $00, $00, $10

logEValue14   DC.B $00, $00, $00, $00, $00, $00, $00, $01 

logEValue15   DC.B $00

negLogEValues DC.W negLogEValue1, negLogEValue2, negLogEValue3, negLogEValue4, negLogEValue5, negLogEValue6 
              DC.W negLogEValue7, negLogEValue8, negLogEValue9, negLogEValue10, negLogEValue11, negLogEValue12
              DC.W negLogEValue13, negLogEValue14, negLogEValue15
              
negLogEValue1 DC.B $99, $93, $06, $85, $28, $19, $44, $01

negLogEValue2 DC.B $99, $99, $04, $68, $98, $20, $19, $57

negLogEValue3 DC.B $99, $99, $90, $04, $96, $69, $14, $68

negLogEValue4 DC.B $99, $99, $99, $00, $04, $99, $66, $69

negLogEValue5 DC.B $99, $99, $99, $90, $00, $04, $99, $97

negLogEValue6 DC.B $99, $99, $99, $99, $00, $00, $05, $00

negLogEValue7 DC.B $99, $99, $99, $99, $90, $00, $00, $05

negLogEValue8 DC.B $99, $99, $99, $99, $99, $00, $00, $00

negLogEValue9 DC.B $99, $99, $99, $99, $99, $90, $00, $00

negLogEValue10 
              DC.B $99, $99, $99, $99, $99, $99, $00, $00

negLogEValue11 
              DC.B $99, $99, $99, $99, $99, $99, $90, $00

negLogEValue12 
              DC.B $99, $99, $99, $99, $99, $99, $99, $00

negLogEValue13 
              DC.B $99, $99, $99, $99, $99, $99, $99, $90

negLogEValue14 
              DC.B $99, $99, $99, $99, $99, $99, $99, $99

negLogEValue15 
              DC.B $00 
              
tanAngles     DC.W tanAngle1, tanAngle2, tanAngle3, tanAngle4, tanAngle5, tanAngle6, tanAngle7, tanAngle8
              DC.W tanAngle9, tanAngle10, tanAngle11, tanAngle12, tanAngle13, tanAngle14, tanAngle15 

tanAngle1     DC.B $00, $07, $85, $39, $81, $63, $39, $74 

tanAngle2     DC.B $00, $00, $99, $66, $86, $52, $49, $12 

tanAngle3     DC.B $00, $00, $09, $99, $96, $66, $68, $67 

tanAngle4     DC.B $00, $00, $00, $99, $99, $99, $66, $67

tanAngle5     DC.B $00, $00, $00, $09, $99, $99, $99, $97

tanAngle6     DC.B $00, $00, $00, $01, $00, $00, $00, $00

tanAngle7     DC.B $00, $00, $00, $00, $10, $00, $00, $00

tanAngle8     DC.B $00, $00, $00, $00, $01, $00, $00, $00

tanAngle9     DC.B $00, $00, $00, $00, $00, $10, $00, $00

tanAngle10    DC.B $00, $00, $00, $00, $00, $01, $00, $00

tanAngle11    DC.B $00, $00, $00, $00, $00, $00, $10, $00

tanAngle12    DC.B $00, $00, $00, $00, $00, $00, $01, $00

tanAngle13    DC.B $00, $00, $00, $00, $00, $00, $00, $10

tanAngle14    DC.B $00, $00, $00, $00, $00, $00, $00, $01

tanAngle15    DC.B $00

negTanAngles  DC.W negTanAngle1, negTanAngle2, negTanAngle3, negTanAngle4, negTanAngle5, negTanAngle6 
              DC.W negTanAngle7, negTanAngle8, negTanAngle9, negTanAngle10, negTanAngle11, negTanAngle12
              DC.W negTanAngle13, negTanAngle14, negTanAngle15
              
negTanAngle1  DC.B $99, $92, $14, $60, $18, $36, $60, $26

negTanAngle2  DC.B $99, $99, $00, $33, $13, $47, $50, $88

negTanAngle3  DC.B $99, $99, $90, $00, $03, $33, $31, $33

negTanAngle4  DC.B $99, $99, $99, $00, $00, $00, $33, $33

negTanAngle5  DC.B $99, $99, $99, $90, $00, $00, $00, $03

negTanAngle6  DC.B $99, $99, $99, $99, $00, $00, $00, $00

negTanAngle7  DC.B $99, $99, $99, $99, $90, $00, $00, $00

negTanAngle8  DC.B $99, $99, $99, $99, $99, $00, $00, $00

negTanAngle9  DC.B $99, $99, $99, $99, $99, $90, $00, $00

negTanAngle10 DC.B $99, $99, $99, $99, $99, $99, $00, $00

negTanAngle11 DC.B $99, $99, $99, $99, $99, $99, $90, $00

negTanAngle12 DC.B $99, $99, $99, $99, $99, $99, $99, $00

negTanAngle13 DC.B $99, $99, $99, $99, $99, $99, $99, $90

negTanAngle14 DC.B $99, $99, $99, $99, $99, $99, $99, $99

negTanAngle15 DC.B $00

              DC.B $01, $43, $1E, $0F, $AE, $6D, $72, $17, $CA, $A0, $00, $00 
Ten29End      DC.B $00                                        ;01 43 1E 0F AE 6D 72 17 CA A0 00 00 00 =
                                                              ;100,000,000,000,000,000,000,000,000,000 = 10^29
                                                              
              DC.B $00, $20, $4F, $CE, $5E, $3E, $25, $02, $61, $10, $00, $00
Ten28End      DC.B $00                                        ;00 20 4F CE 5E 3E 25 02 61 10 00 00 00 = 
                                                              ;10,000,000,000,000,000,000,000,000,000 = 10^28
                                                                            
              DC.B $00, $03, $3B, $2E, $3C, $9F, $D0, $80, $3C, $E8, $00, $00
Ten27End      DC.B $00                                        ;00 03 3B 2E 3C 9F D0 80 3C E8 00 00 00 = 
                                                              ;1,000,000,000,000,000,000,000,000,000 = 10^27
                                                                           
              DC.B $00, $00, $52, $B7, $D2, $DC, $C8, $0C, $D2, $E4, $00, $00
Ten26End      DC.B $00                                        ;00 00 52 B7 D2 DC C8 0C D2 E4 00 00 00 = 
                                                              ;100,000,000,000,000,000,000,000,000 = 10^26
                                                                            
              DC.B $00, $00, $08, $45, $95, $16, $14, $01, $48, $4A, $00, $00
Ten25End      DC.B $00                                        ;00 00 08 45 95 16 14 01 48 4A 00 00 00 = 
                                                              ;10,000,000,000,000,000,000,000,000 = 10^25
                                                                             
              DC.B $00, $00, $00, $D3, $C2, $1B, $CE, $CC, $ED, $A1, $00, $00
Ten24End      DC.B $00                                        ;00 00 00 D3 C2 1B CE CC ED A1 00 00 00 = 
                                                              ;1,000,000,000,000,000,000,000,000 = 10^24
                                                                           
              DC.B $00, $00, $00, $15, $2D, $02, $C7, $E1, $4A, $F6, $80, $00
Ten23End      DC.B $00                                        ;00 00 00 15 2D 02 C7 E1 4A F6 80 00 00 =
                                                              ;100,000,000,000,000,000,000,000 = 10^23 
              
              DC.B $00, $00, $00, $02, $1E, $19, $E0, $C9, $BA, $B2, $40, $00
Ten22End      DC.B $00                                        ;00 00 00 02 1E 19 E0 C9 BA B2 40 00 00 = 
                                                              ;10,000,000,000,000,000,000,000 = 10^22
                                                                            
              DC.B $00, $00, $00, $00, $36, $35, $C9, $AD, $C5, $DE, $A0, $00
Ten21End      DC.B $00                                        ;00 00 00 00 36 35 C9 AD C5 DE A0 00 00 = 
                                                              ;1,000,000,000,000,000,000,000 = 10^21
                                                                            
              DC.B $00, $00, $00, $00, $05, $6B, $C7, $5E, $2D, $63, $10, $00               
Ten20End      DC.B $00                                        ;00 00 00 00 05 6B C7 5E 2D 63 10 00 00 = 
                                                              ;100,000,000,000,000,000,000  = 10^20
                                                            
              DC.B $00, $00, $00, $00, $00, $8A, $C7, $23, $04, $89, $E8, $00               
Ten19End      DC.B $00                                        ;00 00 00 00 00 8A C7 23 04 89 E8 00 00 = 
                                                              ;10,000,000,000,000,000,000 = 10^19
 
              DC.B $00, $00, $00, $00, $00, $0D, $E0, $B6, $B3, $A7, $64, $00               
Ten18End      DC.B $00                                        ;00 00 00 00 00 0D E0 B6 B3 A7 64 00 00 = 
                                                              ;1,000,000,000,000,000,000 = 10^18

              DC.B $00, $00, $00, $00, $00, $01, $63, $45, $78, $5D, $8A, $00               
Ten17End      DC.B $00                                        ;00 00 00 00 00 01 63 45 78 5D 8A 00 00 = 
                                                              ;100,000,000,000,000,000 = 10^17

              DC.B $00, $00, $00, $00, $00, $00, $23, $86, $F2, $6F, $C1, $00               
Ten16End      DC.B $00                                        ;00 00 00 00 00 00 23 86 F2 6F C1 00 00 = 
                                                              ;10,000,000,000,000,000 = 10^16
                                                              
              DC.B $00, $00, $00, $00, $00, $00, $03, $8D, $7E, $A4, $C6, $80               
Ten15End      DC.B $00                                        ;00 00 00 00 00 00 03 8D 7E A4 C6 80 00 = 
                                                              ;1,000,000,000,000,000 = 10^15                

              DC.B $00, $00, $00, $00, $00, $00, $00, $5A, $F3, $10, $7A, $40               
Ten14End      DC.B $00                                        ;00 00 00 00 00 00 00 5A F3 10 7A 40 00 =
                                                              ;100,000,000,000,000 = 10^14
                                                              
                                                              
              DC.B $00, $00, $00, $00, $00, $00, $00, $09, $18, $4E, $72, $A0               
Ten13End      DC.B $00

              
              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $E8, $D4, $A5, $10              
Ten12End      DC.B $00
              

              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $17, $48, $76, $E8              
Ten11End      DC.B $00

             
              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $02, $54, $0B, $E4             
Ten10End      DC.B $00

              
              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $00, $3B, $9A, $CA             
Ten9End       DC.B $00
              

              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $F5, $E1             
Ten8End       DC.B $00
              

              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $98, $96            
Ten7End       DC.B $80


              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $0F, $42            
Ten6End       DC.B $40


              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $01, $86            
Ten5End       DC.B $A0


              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $27            
Ten4End       DC.B $10


              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $03            
Ten3End       DC.B $E8


              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00            
Ten2End       DC.B $64


              DC.B $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00            
Ten1End       DC.B $0A

              DC.B $23, $86, $F2, $6F, $C1, $00
Ten16End2     DC.B $00                                        ;23 86 F2 6F C1 00 00 = 10,000,000,000,000,000 = 10^16
              
              DC.B $03, $8D, $7E, $A4, $C6, $80
Ten15End2     DC.B $00                                        ;03 8D 7E A4 C6 80 00 = 1,000,000,000,000,000 = 10^15
              
              DC.B $00, $5A, $F3, $10, $7A, $40 
Ten14End2     DC.B $00                                        ;00 5A F3 10 7A 40 00 = 100,000,000,000,000 = 10^14

              DC.B $00, $09, $18, $4E, $72, $A0
Ten13End2     DC.B $00                                        ;00 09 18 4E 72 A0 00 = 10,000,000,000,000 = 10^13

              DC.B $00, $00, $E8, $D4, $A5, $10
Ten12End2     DC.B $00                                        ;00 00 E8 D4 A5 10 00 = 1,000,000,000,000 = 10^12
        
              DC.B $00, $00, $17, $48, $76, $E8
Ten11End2     DC.B $00                                        ;00 00 17 48 76 E8 00 = 100,000,000,000 = 10^11

              DC.B $00, $00, $02, $54, $0B, $E4
Ten10End2     DC.B $00                                        ;00 00 02 54 0B E4 00 = 10,000,000,000 = 10^10

              DC.B $00, $00, $00, $3B, $9A, $CA
Ten9End2      DC.B $00                                        ;00 00 00 3B 9A CA 00 = 1,000,000,000 = 10^9

              DC.B $00, $00, $00, $05, $F5, $E1
Ten8End2      DC.B $00                                        ;00 00 00 05 F5 E1 00 = 100,000,000 = 10^8

              DC.B $00, $00, $00, $00, $98, $96
Ten7End2      DC.B $80                                        ;00 00 00 00 98 96 80 = 10,000,000 = 10^7

              DC.B $00, $00, $00, $00, $0F, $42
Ten6End2      DC.B $40                                        ;00 00 00 00 0F 42 40 = 1,000,000 = 10^6

              DC.B $00, $00, $00, $00, $01, $86
Ten5End2      DC.B $A0                                        ;00 00 00 00 01 86 A0 = 100,000 = 10^5

              DC.B $00, $00, $00, $00, $00, $27
Ten4End2      DC.B $10                                        ;00 00 00 00 00 27 10 = 10,000 = 10^4

              DC.B $00, $00, $00, $00, $00, $03
Ten3End2      DC.B $E8                                        ;00 00 00 00 00 03 E8 = 1,000 = 10^3

              DC.B $00, $00, $00, $00, $00, $00
Ten2End2      DC.B $64                                        ;00 00 00 00 00 00 64 = 100 = 10^2

              DC.B $00, $00, $00, $00, $00, $00
Ten1End2      DC.B $0A                                        ;00 00 00 00 00 00 0A = 10 = 10^1

TwoPI         DC.B $00, $62, $83, $18, $53, $07, $17
TwoPIEnd      DC.B $96

negTwoPI      DC.B $99, $37, $16, $81, $46, $92, $82
negTwoPIEnd   DC.B $04

;****************End Constant Table***************

;*Table used in dbgProg and stoFPN subroutines,key178,key 192 and key36 toggle menu labels*

DbgMenu       DC.B $00                                        ;21 columns 
              DC.B $00, $8C, $92, $92, $92, $62               ;S
              DC.B $00, $02, $02, $FE, $02, $02               ;T
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FF                                   ;line             
                            
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
                                          
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00                              ;                            

DigitVal2     DC.B $00, $01, $02, $03, $04, $00, $05, $06
              DC.B $07, $08, $09, $00, $0A, $0B, $0C, $0D
              DC.B $0E, $00, $0F, $10, $11, $12, $13, $00
              DC.B $14, $15, $16, $17, $18, $19
              
Error         DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $09, $19, $29, $46               ;R

KeyNO         DC.B $00, $01, $02, $03, $04, $05, $06, $07
              DC.B $08, $09, $10, $11, $12, $13, $14, $15
              DC.B $16, $17, $18, $19, $20, $21, $22, $23
              DC.B $24, $25, $26, $27, $28, $29, $30, $31
              DC.B $32, $33, $34, $35, $36, $37, $38, $39
              DC.B $40, $41, $42, $43, $44, $45, $46, $47
              
NxtMenu       DC.B $00, $02, $01, $04, $03, $06, $05, $08 
              DC.B $07, $0A, $09, $0C, $0B, $0E, $0D, $10
              DC.B $0F, $12, $11, $14, $13, $16, $15, $18
              DC.B $17, $1A, $19, $1C, $1B, $1E, $1D, $20
              DC.B $1F, $22, $21, $24, $23     

;******************Program Table******************

ACHPrg        DC.B $FE, $03, $03, $00, $0C, $10, $F0, $03
              DC.B $03, $00, $15, $AA, $F2, $03, $03, $00
              DC.B $14, $01, $7A, $01        

              DC.B $09, $10, $A7, $F8, $03, $03, $00, $1F     ;arccosh x 
              DC.B $EF, $08, $20, $40, $06, $50, $00, $49
              DC.B $7A

ASHPrg        DC.B $FE, $03, $03, $00, $0C, $10, $F0, $03
              DC.B $03, $00, $15, $AA, $F2, $03, $03, $00
              DC.B $14, $01, $7A, $01 

              DC.B $10, $20, $09, $00, $50, $00, $49, $7A     ;arcsinh x 

ATHPrg        DC.B $FE, $03, $03, $00, $0C, $10, $F0, $03
              DC.B $03, $00, $15, $AA, $F2, $03, $03, $00
              DC.B $14, $01, $7A, $01 

              DC.B $10, $09, $10, $A7, $C1, $F5, $03, $03     ;arctanh x 
              DC.B $00, $21, $EF, $08, $01, $00, $09, $10
              DC.B $A2, $06, $12, $49, $02, $0E, $0C, $7A
              
COM           DC.B $FE, $03, $03, $00, $07, $10, $AA, $08
              DC.B $10, $F7, $03, $03, $00, $11, $A3, $7A
              DC.B $A3

              DC.B $10, $4E, $A4, $A7, $4E, $A4, $06, $4E     ;nCr 
              DC.B $12, $40, $12, $7A

CPXCarPrg     DC.B $EF, $0A, $A6, $1C, $0C, $A4, $1D
              DC.B $0C, $EF, $05, $81, $7A

CPXDivPrg     DC.B $10, $7D, $F1, $03, $03, $00, $31, $20     ;divide complex numbers
              DC.B $88, $01, $C6, $A0, $01, $A1, $01, $C6
              DC.B $EF, $0A, $A6, $79, $78, $A2, $0C, $A4
              DC.B $0C, $00, $A4, $78, $79, $A2, $0C, $A4
              DC.B $0C, $06, $60, $12, $40, $60, $12, $40
              DC.B $EF, $05, $81, $F0, $03, $03, $00, $34
              DC.B $01, $EF, $08, $7A

CPXModPrg     DC.B $C6, $EF, $0A, $20, $40, $20, $00, $50     ;modulus of complex number
              DC.B $EF, $05, $7A

CPXMulPrg     DC.B $C6, $A0, $40, $A1, $A3, $C6, $EF, $0A     ;multiply complex numbers 
              DC.B $A6, $79, $78, $A2, $0C, $A4, $0C, $40
              DC.B $06, $A4, $78, $79, $A2, $0C, $A4, $0C
              DC.B $00, $EF, $05, $81, $7A
              
CPXPlrPrg     DC.B $10, $7D, $F1, $03, $09, $00, $68, $88     ;polar form 
              DC.B $01, $C6, $EF, $0A, $F1, $03, $03, $00
              DC.B $34, $40, $F1, $03, $03, $00, $4F, $60
              DC.B $12, $4C, $40, $03, $10, $F5, $03, $03
              DC.B $00, $2C, $A3, $04, $60, $40, $F0, $03
              DC.B $09, $00, $65, $A3, $60, $40, $F0, $03
              DC.B $09, $00, $65, $01, $03, $10, $F5, $03
              DC.B $03, $00, $46, $A3, $60, $09, $04, $4C
              DC.B $F0, $03, $09, $00, $65, $A3, $60, $03
              DC.B $10, $F0, $03, $09, $00, $65, $01, $03
              DC.B $10, $F5, $03, $03, $00, $61, $A3, $60
              DC.B $03, $4C, $04, $F0, $03, $09, $00, $65
              DC.B $A3, $60, $03, $4C, $EF, $05, $7A, $01
              DC.B $EF, $08, $7A

CSH           DC.B $FE, $03, $03, $00, $0C, $10, $F0, $03
              DC.B $03, $00, $15, $AA, $F2, $03, $03, $00
              DC.B $14, $01, $7A, $01         

              DC.B $10, $19, $40, $04, $19, $00, $08, $12     ;cosh x 
              DC.B $7A
              
LCMPrg        DC.B $FE, $03, $03, $00, $07, $10, $AA, $08
              DC.B $10, $F7, $03, $03, $00, $11, $A3, $7A
              DC.B $A3        

              DC.B $A6, $C9, $A4, $0C, $40, $12, $7A          ;LCM

MEANXPrg      DC.B $6F, $09, $00, $03, $10, $AD, $00
              DC.B $AF, $6F, $F1, $03, $03, $00, $15
              DC.B $01, $F0, $03, $03, $00, $06, $01
              DC.B $AD, $00, $40, $10, $09, $06, $97
              DC.B $01, $12, $7A 

PER           DC.B $FE, $03, $03, $00, $07, $10, $AA, $08
              DC.B $10, $F7, $03, $03, $00, $11, $A3, $7A
              DC.B $A3

              DC.B $A7, $4E, $A4, $06, $4E, $12, $7A          ;nPr

SNH           DC.B $FE, $03, $03, $00, $0C, $10, $F0, $03
              DC.B $03, $00, $15, $AA, $F2, $03, $03, $00
              DC.B $14, $01, $7A, $01

              DC.B $10, $19, $40, $04, $19, $06, $08, $12     ;sinh x 
              DC.B $7A
              
TNH           DC.B $FE, $03, $03, $00, $0C, $10, $F0, $03
              DC.B $03, $00, $15, $AA, $F2, $03, $03, $00
              DC.B $14, $01, $7A, $01          

              DC.B $10, $10, $19, $40, $04, $19, $06, $40     ;tanh x 
              DC.B $10, $19, $40, $04, $19, $00, $12, $7A 
              
ToDMSPrg      DC.B $FE, $03, $03, $00, $0C, $10, $F0, $03
              DC.B $03, $00, $15, $AA, $F2, $03, $03, $00
              DC.B $14, $01, $7A, $01     

              DC.B $10, $BF, $10, $A4, $06, $0D, $03, $0C     ;decimal -> degrees, minutes, seconds 
              DC.B $10, $BF, $10, $A4, $06, $0D, $03, $0C
              DC.B $09, $03, $03, $12, $00, $09, $03, $03
              DC.B $12, $00, $7A

DMSToPrg      DC.B $FE, $03, $03, $00, $0C, $10, $F0, $03
              DC.B $03, $00, $15, $AA, $F2, $03, $03, $00
              DC.B $14, $01, $7A, $01       

              DC.B $10, $BF, $10, $A4, $06, $09, $03, $03     ;degrees, minutes, seconds -> decimal 
              DC.B $0C, $10, $BF, $10, $A4, $06, $02, $0D
              DC.B $12, $00, $0D, $03, $12, $00, $7A

;*****************End Program Table***************

;************************************************
;*                 Interrupts                   *
;************************************************

;RTIisr: blinks the cursor and determines if a key has been pressed 

RTIisr:       BSET CRGFLG,#BIT7                  ;clear RTI Flag

              BRSET flag1,#BIT7,RTIisr_2         ;do not display the cursor if curOff flag set      

              LDD cursorRate
              SUBD #$0001
              STD cursorRate                     ;copy the value in D to cursorRate
              BNE RTIisr_2                       ;branch if cursorRate is <> 0
                                                 ;otherwise toggle the cursor               
              
              COM cursorValue                    ;complement colValue
					    LDAA cursorValue 					    
					    MOVB #$08,colNumber                ;colNumber = 8 pixel font width		    
					     
RTIisr_1:     JSR sendByte                       ;set/clear the cursor column (does not affect Ycoord)

              DEC colNumber           
              BNE RTIisr_1                        
					    
					    JSR setY                           ;reset Y to Ycoord
					    
					    MOVW #$0BA0,cursorRate             ;reset the blink rate

RTIisr_2:     BCLR PT1AD0,#BIT0                  ;clear all keypad rows
              BCLR PT1AD0,#BIT1
              BCLR PT1AD0,#BIT2
              BCLR PT1AD0,#BIT3
              BCLR PT1AD0,#BIT4
              BCLR PT1AD0,#BIT5
              BCLR PT1AD0,#BIT6
              BCLR PT1AD0,#BIT7
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS4: simulate key press              
              ;MOVB #$00,PTP               
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
                            
              LDAA PTP                           ;PTP at 0x0258
              COMA
                            
              BEQ RTIisr_4                       ;if keypad not pressed (Port P = $FF) exit                                            
              
              JSR scanKey                        ;otherwise scan keypad                      
             
              BRCLR flag1,#BIT2,RTIisr_4         ;exit if pressed key was not detected    

              BCLR PT1AD0,#BIT0                  ;otherwise clear all keypad rows
              BCLR PT1AD0,#BIT1
              BCLR PT1AD0,#BIT2
              BCLR PT1AD0,#BIT3
              BCLR PT1AD0,#BIT4
              BCLR PT1AD0,#BIT5
              BCLR PT1AD0,#BIT6
              BCLR PT1AD0,#BIT7
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uncomment for FCS
              
              MOVB #$FF,PTP
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
             
RTIisr_3:     LDAA PTP
              COMA
              BNE RTIisr_3                       ;loop until pressed key is released               
                           
              BCLR flag1,#BIT2                   ;clear keyPressed       

RTIisr_4:     RTI

;TIMERisr: increment tcntOvrflw each time interrupt occurs to determine program execution time

TIMERisr:     MOVB #BIT7,TIM_TFLG2               ;set TFLG2.7 = TOF to clear the timer overflow flag (TOF)     

              CLR TIM_TSCR1                      ;timer disabled   

              LDD tcntOvrflw
              ADDD #$0001
              STD tcntOvrflw
              BCC TIMERisr_1                     ;branch if tcntOvflw did not overflow
              
              LDD tcntOvrflw2                    ;otherwise increment tcntOvflw2 
              ADDD #$0001
              STD tcntOvrflw2
              
TIMERisr_1:   MOVB #$80,TIM_TSCR1                ;TSCR1 = A = 1000 0000,timer enabled  
 
              RTI
              
;************************************************
;*              Interrupt Vectors               *
;************************************************

              ORG $FFDE
              DC.W TIMERisr                      ;TIMER Vector
              
              ORG $FFF0
              DC.W RTIisr                        ;RTI Vector
              
              ORG $FFFE
              DC.W entry                         ;Reset Vector
              
;*************************************************
;*                 Paged Memory                  *
;*************************************************

;*********************PAGE_FB*********************code related to keypad scanning, updating the display in user mode, 
                                                 ;updating the display in program edit mode (line number code only) 
                                                 ;and non-mathematical subroutines not used during program execution                                                                                                         
              ORG $FB8000
              
;backY: move the cursor one digit to the left of the savedY position

backY:        LDAA savedY                        ;PAGE_FB
              SUBA #wFont
              STAA Ycoord
              STAA savedY
              JSR setY
              
              RTS
              
;backYSL: move the cursor one digit to the left of the savedY position in SL font

backYSL:      LDAA savedY                        ;PAGE_FB
              SUBA #wFontSL
              STAA Ycoord
              STAA savedY
              JSR setY
              
              RTS
              
;clearStack: clear pages 1 - 5 of the ST7565 GLCD;
                                                 ;PAGE_FB
clearStack:   MOVB #$05,counter1   

              MOVB #$B1,pageNumber               ;page 1 
			  
clearStack_1: BCLR PTH,#BIT0                     ;A0 = 0, send command	
           
              LDAA pageNumber                    ;A = pageNumber
              JSR sendByte                       ;set the page
           
              JSR clearPage          
              
              INC pageNumber                     ;set the next page
              
              DEC counter1                       
              BNE clearStack_1           
              
              RTS

;clearStack2: clear pages 0 - 6 of the ST7565 GLCD
                                                 ;PAGE_FB
clearStack2:  MOVB #$07,counter1                   

              MOVB #$B0,pageNumber               ;page 0 
			  
clearStack2_1:BCLR PTH,#BIT0                     ;A0 = 0, send command	
           
              LDAA pageNumber                    ;A = pageNumber
              JSR sendByte                       ;set the page
           
              JSR clearPage          
              
              INC pageNumber                     ;set the next page
              
              DEC counter1                       
              BNE clearStack2_1           
              
              RTC

;clrChar: clear the command line/stack character at the current Y position

clrChar:      LDX #Space                         ;PAGE_FB                      
              MOVB #wFont,colNumber
              JSR sendData                                 

              RTC
              
;clrCharSL: clear the status line character at the current Y position

clrCharSL:    LDX #Space                         ;PAGE_FB
              MOVB #wFontSL,colNumber            
              JSR sendData2
              
              RTC
              
;clrComL: clears the command line and resets Ycoord and Y 
                                                 ;PAGE_FB
clrComL:      BCLR PTH,#BIT0                     ;A0 = 0,send command
            
						  LDAA #$B6
						  JSR sendByte                       ;set to page 6
							
					  	JSR clearPage                      ;clear page 6    
							
							MOVB #$08,Ycoord                   ;set Ycoord and Y to 8
              JSR setY               

              RTC

;clrExp: clear the exponent field and cursor

clrExp:       LDAA noDigExp                      ;PAGE_FB
              INCA                      
              LDAB #wFont
              MUL                                ;B = (noDigExp + 1) * wFont
              
              LDAA Ycoord
              SBA                                ;A - B -> A,i.e. Ycoord - (noDigExp + 1) * wFont -> A
              STAA Ycoord
              STAA savedY
              JSR setY
              
              CALL clrChar 
              CALL clrChar 
              CALL clrChar 
              CALL clrChar                                  
              
              MOVB savedY,Ycoord
              JSR setY                           ;set Y to the correct position for the blinking cursor             
              
              CLR e_com                          ;set e_com = 0
              
              CLR noDigExp                       ;set noDigExp = 0
              
              BCLR flag2,#BIT0                   ;clear expPressed flag
              
              MOVB savedY,Ycoord
              JSR setY                           ;set Y to end of mantissa
              
              RTC 

;clrImagStk: sets the corresponding imaginary parts in the imaginary number stack to 0

clrImagStk:   LDD usPointer                      ;PAGE_FB
              CPD #ms_end
              BEQ clrImagStk_exit                ;exit if the user stack is empty
              
clrImagStk_1: PSHD
              
              ADDD #$1301                        
              
              TFR D,X                            ;X points to the corresponding imaginary part
              
              CLRA
              MOVB #lenFPNBytes,counter1
              
clrImagStk_2: STAA 1,X+                          ;set to 0 ->
              DEC counter1
              BNE clrImagStk_2                   ;<-
              
              PULD
              ADDD #lenFPNBytes
              CPD #ms_end
              BEQ clrImagStk_exit                ;exit if the user stack is empty
              
              BRA clrImagStk_1
              
clrImagStk_exit:
              RTC                            

;clrStatus: clears "Shift"/"Alpha"/ERROR"/"END"/"STO" from the status line. Returns to normal stack display 
;when any key is pressed after viewing memory contents, program execution time or the about page

                                                 ;PAGE_FB
clrStatus:    BRCLR flag1,#BIT4,clrStatus_1      ;branch if the MEM flag is clear
                            
              MOVB #$7F,keyNumber                ;otherwise simulate MEM key press (key 127) and exit
              BRA clrStatus_exit

clrStatus_1:  BRCLR flag4,#BIT5,clrStatus_2      ;branch if the time flag is clear
                            
              MOVB #$80,keyNumber                ;otherwise simulate TME key press (key 128) and exit
              BRA clrStatus_exit

clrStatus_2:  BRCLR flag5,#BIT6,clrStatus_3      ;branch if the ABT flag is clear

              MOVB #$86,keyNumber                ;otherwise simulate ABT key press (key 134) and exit
              BRA clrStatus_exit

clrStatus_3:  LDX #clrShift              
              MOVB #$24,colNumber              
              CALL dispStatLI                    ;clear "Shift"/"Alpha"/"ERROR"/"END"/"STO" annunciators
              BCLR flag2,#BIT7                   ;clear the usPDec flag
              ;BSET PORTE,#BIT1                   ;turn off ERROR LED on pin PE1
              ;BSET PORTD,#BIT1                   ;turn off ERROR LED on pin PD1 (prototype) 
              
clrStatus_exit:  
              RTC

;cplProg: convert keystroke numbers to offsets for branching instructions

cplProg:      LDX #ms_start_LS                   ;PAGE_FB

cplProg_1:    INX
              
              LDAA 0,X                           ;A = instruction code
              CMPA #$EF
              LBEQ cplProg_3                     ;branch if instruction is not a 1 byte instruction
              
              CMPA #$F0               
              BLO cplProg_2                      ;branch if instruction is not a branch instruction
              
              INX                                ;convert next 4 bytes to binary and store in 2 bytes ->
              
              MOVB #lenManBytes,counter1         ;set m_a to 0 ->
              CLRA
              LDY #m_a
               
cplProg_1_1:  STAA 1,Y+
              DEC counter1
              BNE cplProg_1_1                     ;<- 
              
              LDAB 1,X+                          ;B = 1st keynumber
              PSHX
              
              LDX #DigitVal
              ABX                                ;X = DigitVal + keynumber             
              
              LDAA 0,X                           ;A = value corresponding to keynumber (e.g. keynumber = 9 -> A = 1)
              
              ASLA
              ASLA
              ASLA
              ASLA
              
              PULX
              LDAB 1,X+                          ;B = 2nd keynumber
              PSHX
              
              LDX #DigitVal
              ABX                                ;X = DigitVal + keynumber             
              
              LDAB 0,X                           ;B = value corresponding to keynumber (e.g. keynumber = 8 -> A = 2) 
              
              ABA                                ;A + B -> A, i.e. A = MS byte in BCD
              
              DEY
              DEY                                ;Y points to second LS byte of m_a
              
              STAA 1,Y+                          ;second LS byte of m_a = MS byte in BCD
              
              PULX
              LDAB 1,X+                          ;B = 3rd keynumber
              PSHX
              
              LDX #DigitVal
              ABX                                ;X = DigitVal + keynumber             
              
              LDAA 0,X                           ;A = value corresponding to keynumber (e.g. keynumber = 7 -> A = 3)
              
              ASLA
              ASLA
              ASLA
              ASLA
              
              PULX
              LDAB 0,X                           ;B = 4th keynumber
              PSHX
              
              LDX #DigitVal
              ABX                                ;X = DigitVal + keynumber             
              
              LDAB 0,X                           ;B = value corresponding to keynumber (e.g. keynumber = 15 -> A = 4) 
              
              ABA                                ;A + B -> A, i.e. A = LS byte in BCD
              
              STAA 0,Y                           ;LS byte of m_a = LS byte in BCD
              
              MOVW #m_a,memAddr2
              MOVW #m_c,memAddr1
              
              MOVB #lenManBBytes,lenMemBytes     ;lenMemBytes = lenManBBytes for BCDToBin subroutine
              
              JSR BCDToBin                       ;convert mantissa of m_a to binary and store in m_c
              
              MOVB #lenExpBytes,lenMemBytes      ;lenMemBytes = lenExpBytes to update value of exponent when entering
                                                 ;values on the command line
              
              LDY #endm_c                        ;Y is pointing to LS byte of m_c
              
              PULX                               ;X is pointing to 4th byte
              
              LDAA 1,Y-                          ;A = LS byte of m_c
              STAA 1,X-                          ;4th byte = LS byte of m_c
              
              LDAA 0,Y                           ;A = second LS byte of m_c
              STAA 0,X                           ;3rd byte = second LS byte of m_c
              
              INX                                ;X is pointing to 4th byte <-        
              
              BRA cplProg_4
              
cplProg_2:    CMPA #$8F
              BNE cplProg_4                      ;branch if not PICK instruction
              
              INX                                ;convert next 2 bytes to binary and store in MS byte ->
              LDAB 1,X+                          ;B = 1st keynumber
              PSHX
              
              LDX #DigitVal
              ABX                                ;X = DigitVal + keynumber             
              
              LDAA 0,X                           ;A = value corresponding to keynumber (e.g. keynumber = 9 -> A = 1)
              
              ASLA
              TAB                                ;B = 2 * value corresponding to keynumber
              
              ASLA             
              ASLA                               ;A = 8 * value corresponding to keynumber
              
              ABA                                ;A + B -> A, i.e. A = 10 * value corresponding to keynumber
              
              PULX
              PSHX                               ;
              LDAB 0,X                           ;B = 2nd keynumber
              
              LDX #DigitVal
              ABX                                ;X = DigitVal + keynumber             
              
              LDAB 0,X                           ;B = value corresponding to keynumber (e.g. keynumber = 7 -> B = 3)
              
              ABA                                ;A + B -> A, i.e. A = pick stack level value in binary
              
              PULX
              
              STAA 0,X                           ;pick stack level in binary stored in MS byte <- 
              
              BRA cplProg_4 
              
cplProg_3:    INX               
              
cplProg_4:    CPX #ps_end
              
              LBNE cplProg_1                     ;loop until last program instruction checked                   

              RTC

;dcplProg: convert offsets to keystroke numbers for branching instructions

dcplProg:     LDX #ms_start_LS                   ;PAGE_FB

dcplProg_1:   INX
              
              LDAA 0,X                           ;A = instruction code
              CMPA #$EF
              BEQ dcplProg_3                     ;branch if instruction is not a 1 byte instruction
              
              CMPA #$F0               
              BLO dcplProg_2                     ;branch if instruction is not a branch instruction
              
              INX                                ;set bytes 3 and 4 to corresponding keynumbers ->
              INX
              INX                                ;X is pointing to the 3rd byte
              
              MOVB #lenManBBytes,counter1        ;set m_e to 0 ->
              CLRA
              LDY #m_e
               
dcplProg_1_1: STAA 1,Y+
              DEC counter1
              BNE dcplProg_1_1                   ;<-
              
              LDAA 1,X+                          ;A = MS byte of binary address value
              
              DEY
              DEY                                ;Y is pointing to the second LS byte of m_e
              
              STAA 1,Y+                          ;second LS byte of m_e = MS byte of binary address value
              
              LDAA 0,X                           ;A = LS byte of binary address value
              
              STAA 0,Y                           ;LS byte of m_e = LS byte of binary address value
              
              PSHX
              
              JSR BinToBCD2                      ;convert m_e to BCD and store in m_a
              
              LDY #m_aEnd
              LDAA 0,Y
              
              ANDA #$0F                          ;A = LS digit of address in BCD              
              TAB                                ;B = LS digit of address in BCD

              LDX #DigitValInv
              ABX
              
              LDAA 0,X                           ;A = keynumber corresponding to value (e.g. value = 4 -> A = 15)
              
              PULX 

              STAA 1,X-                          ;fourth byte = keynumber corresponding to LS digit of address in BCD
              
              PSHX
              
              LDAA 0,Y
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F                          ;A = second LS digit of address in BCD
              TAB                                ;B = second LS digit of address in BCD
              
              LDX #DigitValInv
              ABX
              
              LDAA 0,X                           ;A = keynumber corresponding to value (e.g. value = 3 -> A = 7)
              
              PULX 

              STAA 0,X                           ;third byte = keynumber corresponding to second LS digit of address 
                                                 ;in BCD <-                                                 
              INX 
              
              BRA dcplProg_4
              
dcplProg_2:   CMPA #$8F
              BNE dcplProg_4                     ;branch if not PICK instruction
              
              INX
              INX                                ;X points to second byte
              
              LDAA 0,X              
              
dcplProg_2_1: SUBA #$0A                          ;subtract 10
              BCS dcplProg_2_2                   ;result < 0 -> exit loop and add 10              
              BRA dcplProg_2_1                   ;repeat
              
dcplProg_2_2: ADDA #$0A                          ;after adding 10 A is equal to the 1's place digit
              TAB                                ;B = 1's place digit

              PSHX
              
              LDX #DigitValInv
              ABX
              
              LDAA 0,X                           ;A = keynumber corresponding to value (e.g. value = 2 -> A = 8)
              
              PULX 

              STAA 0,X                           ;second byte = keynumber 
              
              BRA dcplProg_4 
              
dcplProg_3:   INX               
              
dcplProg_4:   CPX #ps_end
              
              BNE dcplProg_1                    ;loop until last program instruction checked       

              RTC

;dispAbtPge: display the about page;;;;;;;;;;;;;;

                                                 ;PAGE_FB
dispAbtPge:   BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B7                          ;set to page 7
              JSR sendByte              
              
              JSR clearPage                      ;clear page 7 

              MOVB #$06,counter1
			        JSR clearStack                     ;clear pages 1 - 6
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B0                          ;set to page 0
              JSR sendByte              
              
              JSR clearPage                      ;clear page 0
			        
			        MOVB #$0C,Ycoord
			        JSR setY                           ;Y = 12
			        
			        LDX #AriCal
			        MOVB #$68,colNumber                
			        JSR sendData                       ;display "AriCalculator"
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B1                          ;set to page 1
              JSR sendByte              
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Line1
			        MOVB #$78,colNumber                
			        JSR sendData                       ;display "Original concept and"
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B2                          ;set to page 2
              JSR sendByte              
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Line2
			        MOVB #$5A,colNumber                
			        JSR sendData                       ;display "engineering by:"
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B3                          ;set to page 3
              JSR sendByte              
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Line3
			        MOVB #$54,colNumber                
			        JSR sendData                       ;display "Dirk Heisswolf"
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B4                          ;set to page 4
              JSR sendByte              
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Line4
			        MOVB #$7E,colNumber                
			        JSR sendData                       ;display "Firmware beta 1.0 by:"
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B5                          ;set to page 5
              JSR sendByte              
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Line5
			        MOVB #$6C,colNumber                
			        JSR sendData                       ;display "Daniel Milutinovic"
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B6                          ;set to page 6
              JSR sendByte              
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Line6
			        MOVB #$7E,colNumber                
			        JSR sendData                       ;display "http://hotwolf.github"
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B7                          ;set to page 7
              JSR sendByte              
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Line7
			        MOVB #$66,colNumber                
			        JSR sendData                       ;display ".io/AriCalculator"			        
			        
              RTS

;dispBin: display the binary value of counter2 bytes of m_c (SL font)

dispBin:      LDX #m_c                           ;PAGE_FB
              LDAB #lenManBBytes
              DECB
              ABX                                
              STX memAddr1_LSBY                  ;X points to the LS byte of the binary value at m_c

dispBin_1:    MOVB #$08,counter3              
              
dispBin_2:    MOVB #lenManBBytes,counter4
              DEC counter4
              
              ASL 1,X-
              
dispBin_3:    ROL 1,X-
              DEC counter4
              BNE dispBin_3
              
              LDX #DigitSL
              
              BCS dispBin_4                      ;branch if "1" should be displayed 
              
              BRA dispBin_5                      ;otherwise display "0"
              
dispBin_4:    LDAB #wFontSL
              ABX
              
dispBin_5:    MOVB #wFontSL,colNumber
              JSR sendData
              
              LDX memAddr1_LSBY                  ;X points to the LS byte of the binary value at m_c
              
              DEC counter3
              BNE dispBin_2
              
              MOVB #$50,Ycoord
              JSR setY                           ;Y = 80, to display the next byte
              
              DEC counter2
              BNE dispBin_1 
              
              RTS 
              
;dispBin2: display the 2 LS bytes of m_a in binary value (SL font), in blocks of four digits 

dispBin2:     LDAA counter4                      ;PAGE_FB
              PSHA    

              MOVB #$04,counter2                   
  
              MOVB #$0F,counter3              
              
dispBin2_2:   LDX #m_a   

              MOVB #lenManBytes,counter4
              DEC counter4
              
              ASR 1,X+
              
dispBin2_3:   ROR 1,X+
              DEC counter4
              BNE dispBin2_3
              
              LDX #DigitSL
              
              BCS dispBin2_4                     ;branch if "1" should be displayed 
              
              BRA dispBin2_5                     ;otherwise display "0"
              
dispBin2_4:   LDAB #wFontSL
              ABX
              
dispBin2_5:   MOVB #wFontSL,colNumber
              JSR sendData
              
              JSR backYSL                        ;move Y one digit to the left in SL font
              
              DEC counter2
              BNE dispBin2_6
              
              LDX #Space                          
              MOVB #wFontSL,colNumber
              JSR sendData                       ;otherwise insert a space 
              
              JSR backYSL                        ;move Y one digit to the left in SL font
              
              MOVB #$04,counter2 
              
dispBin2_6:   DEC counter3
              BNE dispBin2_2
              
              LDX #m_aEnd                        ;display MS bit of 2 byte value   

              ROR 0,X
              
              LDX #DigitSL
              
              BCS dispBin2_7                     ;branch if "1" should be displayed 
              
              BRA dispBin2_8                     ;otherwise display "0"
              
dispBin2_7:   LDAB #wFontSL
              ABX
              
dispBin2_8:   MOVB #wFontSL,colNumber
              JSR sendData
              
              PULA
              STAA counter4                      ;restore counter4
              
              RTS

;dispCpx: display FPN_a as a complex number on the current page 

dispCpx:      MOVB #$78,Ycoord                   ;PAGE_FB
						  MOVB Ycoord,savedY
						  JSR setY                           ;Y = 120
						  
						  LDX #Imag
              MOVB #wFont,colNumber
              JSR sendData
              
              MOVB #$70,Ycoord
						  MOVB Ycoord,savedY
						  JSR setY                           ;Y = 112						  
						  
						  LDD memAddr1                       
              PSHD                               ;push memAddr1 onto the stack
              
              ADDD #$1301                        ;D = address of imaginary part
              
              STD memAddr1
						  MOVW #m_a,memAddr2
						  
						  JSR copyFPN                        ;FPN_a = imaginary part
            
              BCLR flag2,#BIT3                   ;clear manNeg and expNeg flags
              BCLR flag2,#BIT4
              
              MOVW #m_a,memAddr1                 ;display the imaginary part ->
              
              JSR absFPN                         ;set FPN_a to its absolute value and set manNeg flag if required
              
              JSR lzMan                          ;determine the number of leading zeros in FPN_a
              LDAA noZero          
              CMPA #lenMan
              BNE dispCpx_1                      ;branch if noZero <> lenMan, i.e. if FPN_a <> 0
              
              MOVB #$78,Ycoord
						  MOVB Ycoord,savedY
						  JSR setY                           ;Y = 120
						  
						  BSET flag5,#BIT5                   ;set the iz flag
              
              CALL clrChar                       ;clear "i" and display the real part only
              
              MOVB #$78,Ycoord
						  MOVB Ycoord,savedY
						  JSR setY                           ;Y = 120
              
              BRA dispCpx_4_1             

dispCpx_1:    JSR shFPN                          ;set FPN_a to a 10-digit mantissa for display

              JSR tzFPN                          ;eliminate trailing zeros in FPN_a 
              
              BRCLR flag1,#BIT3,dispCpx_2        ;branch if sci flag not set
              
              JSR dispSci                        ;otherwise display the value of FPN_a in scientific format
              
              BRA dispCpx_3
              
dispCpx_2:    JSR dispDec                        ;display the value of FPN_a in decimal format                 
           
dispCpx_3:    BRSET flag2,#BIT4,dispCpx_4        ;branch if manNeg flag is set
              
              BSET flag5,#BIT4                   ;set the ip flag
              
              LDX #Plus
              MOVB #wFont,colNumber
              JSR sendData                       ;<-              

dispCpx_4:    BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set in absFPN subroutine above
              BCLR flag2,#BIT3                   ;clear expNeg flag in case it was set in dispDec subroutine above
              						  
						  JSR backY
						  
dispCpx_4_1:  PULD                               ;D = memAddr1 (current position on the user stack)
						  PSHD
						  
						  STD memAddr1
						  MOVW #m_a,memAddr2
						  
						  JSR copyFPN                        ;FPN_a = real part
						  
						  MOVW #m_a,memAddr1                 ;display the real part ->
              
              JSR absFPN                         ;set FPN_a to its absolute value and set manNeg flag if required
              
              JSR lzMan                          ;determine the number of leading zeros in FPN_a
              LDAA noZero          
              CMPA #lenMan
              BNE dispCpx_5                      ;branch if noZero <> lenMan, i.e. if FPN_a <> 0
              
              BRSET flag5,#BIT5,dispCpx_4_2      ;display "0" only as the imaginary part = 0
                            
              BRCLR flag5,#BIT4,dispCpx_7        ;exit if the imaginary part < 0                
              
              CALL clrChar                       ;otherwise delete "+"
              CALL clrChar
              
              BRA dispCpx_7                      ;exit
              
dispCpx_4_2:  JSR dispZero                       
              
              BRA dispCpx_7             

dispCpx_5:    JSR shFPN                          ;set FPN_a to a 10-digit mantissa for display

              JSR tzFPN                          ;eliminate trailing zeros in FPN_a 
              
              BRCLR flag1,#BIT3,dispCpx_6        ;branch if sci flag not set
              
              JSR dispSci                        ;otherwise display the value of FPN_a in scientific format
              
              BRA dispCpx_7
              
dispCpx_6:    JSR dispDec                        ;display the value of FPN_a in decimal format
                                                 ;<-                 
           
dispCpx_7:    BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set in absFPN subroutine above
              BCLR flag2,#BIT3                   ;clear expNeg flag in case it was set in dispDec subroutine above
              
              BCLR flag5,#BIT4                   ;clear the ip flag
              BCLR flag5,#BIT5                   ;clear the iz flag                 

              BCLR PTH,#BIT0                     ;A0 = 0,send command

              PULD                               ;D = memAddr1 (current position on the user stack)

              RTS  

;dispDec: display the value of FPN_a in decimal format

dispDec:      LDAA e_a                           ;PAGE_FB
              BMI dispDec_5                      ;branch if e_a < 0
              
              LDAA noZero                        ;e_a >= 0 ->
              CMPA e_a
              BLT dispDec_4                      ;branch if noZero < e_a to display in scientific format, e.g.
                                                 ;FPN_a = 123 8
              TST e_a                            ;otherwise display in decimal format, e.g. FPN_a = 123 5
              BEQ dispDec_2                      ;branch if e_a = 0
              
dispDec_1:    JSR dispZero                       ;otherwise display trailing zeros ->
              DEC e_a
              BNE dispDec_1                      ;<-
              
dispDec_2:    LDAA #maxLenMan
              SUBA noZero
              STAA counter3
              JSR dispManDgt
              
              BRCLR flag2,#BIT4,dispDec_3
              JSR dispNeg
              
dispDec_3:    BRA dispDec_11                     ;<-              
              
dispDec_4:    JSR dispSci                        
              BRA dispDec_11                     ;<-             
                                 
dispDec_5:    NEG e_a                            ;e_a < 0 -> e_a > 0                                                       
              
              LDAA #maxLenMan
              SUBA noZero                        
              CMPA e_a
              BGT dispDec_6                      ;branch if maxLenMan - noZero > |e_a|
              
              LDAA #maxLenMan                    ;maxLenMan - noZero <= |e_a| ->
              LDAB e_a
              INCB                               ;B = |e_a| + 1
              
              CBA                                
              BPL dispDec_8                      ;branch if |e_a| + 1 <= maxLenMan
              
              NEG e_a                            ;otherwise make e_a negative again and display in scientific format
              JSR dispSci                        
              BRA dispDec_11                     ;<- 
              
dispDec_6:    SUBA e_a                           ;e.g. FPN_a = 123 -2
              PSHA                               ;A = 3 - 2 = 1 
              MOVB e_a,counter3                  ;counter3 = 2
              JSR dispManDgt                     ;display: "23"
              JSR dispDp                         ;display: ".23"
              JSR backY                          ;shift Y one digit to the left
              
              PULA                               ;A = 1
              STAA counter3                
              JSR dispManDgt                     ;display: "1.23"
              BRCLR flag2,#BIT4,dispDec_7
              JSR dispNeg
                              
dispDec_7:    BRA dispDec_11                       

dispDec_8:    SUBA noZero                        ;e.g. FPN_a = 1 -2
              PSHA                               ;A = 1
              STAA counter3
              JSR dispManDgt                     ;display: "1"
              LDAB e_a                           ;B = 2
              SUBB 1,SP+                         ;B = 2 - 1 = 1
              BEQ dispDec_10
              STAB counter1
              
dispDec_9:    JSR dispZero
              DEC counter1
              BNE dispDec_9
                  
dispDec_10:   JSR dispDp                         ;display: ".123"
              JSR backY                          ;shift Y one digit to the left                          
              JSR dispZero                       ;display: "0.123"
              BRCLR flag2,#BIT4,dispDec_11               
              JSR dispNeg
              
dispDec_11:   RTS

;dispExact: display FPN_a as a rational number on the current page  

dispExact:    MOVB #$78,Ycoord                   ;PAGE_FB
						  MOVB Ycoord,savedY
						  JSR setY                           ;Y = 120
						  
						  LDD memAddr1                       
              PSHD                               ;push memAddr1 onto the stack
              
              ADDD #$13B5                        ;D = address of denominator
              
              STD memAddr1
						  MOVW #m_a,memAddr2
						  
						  JSR copyFPN                        ;FPN_a = denominator
              
              MOVW #m_a,memAddr1                 ;display the denominator ->
              
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_a -> FPN_f
              
              CLRA
              LDX #m_b
              MOVB #lenManBBytes,counter1
              
dispExact_1:  STAA 1,X+                          ;set FPN_b = 1 ->
              DEC counter1
              BNE dispExact_1
              
              MOVB #$01,1,X+
              
              STAA 0,X                           ;<-              
              
              JSR subFPN                         ;FPN_a - FPN_b -> FPN_a
              
              BCLR flag2,#BIT3                   ;clear manNeg and expNeg flags in case they were set in subFPN 
              BCLR flag2,#BIT4                   ;subroutine
              
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BEQ dispExact_3                    ;display numerator only if denominator = 1               
                            
              MOVW #m_f,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_f -> FPN_a
              
              MOVW #m_a,memAddr1
              
              JSR shFPN                          ;set FPN_a to a 10-digit mantissa for display

              JSR tzFPN                          ;eliminate trailing zeros in FPN_a
              
              JSR dispDec                        ;display FPN_a = denominator in decimal format                 
           
              LDX #Div
              MOVB #wFont,colNumber
              JSR sendData                       ;display "/"
              
              JSR backY 
						  
dispExact_3:  PULD                               ;D = memAddr1 (current position on the user stack)
						  PSHD
						  
						  STD memAddr1
						  MOVW #m_a,memAddr2
						  
						  JSR copyFPN                        ;FPN_a = numerator
						  
						  MOVW #m_a,memAddr1                 ;display the numerator ->
              
              JSR absFPN                         ;set FPN_a to its absolute value and set manNeg flag if required
              
              JSR lzMan                          ;determine the number of leading zeros in FPN_a
              LDAA noZero          
              CMPA #lenMan
              BNE dispExact_4                    ;branch if noZero <> lenMan, i.e. if FPN_a <> 0
              
              JSR dispZero                       ;otherwise display "0" and exit
              BRA dispExact_exit             

dispExact_4:  JSR shFPN                          ;set FPN_a to a 10-digit mantissa for display

              JSR tzFPN                          ;eliminate trailing zeros in FPN_a 
              
              JSR dispDec                        ;display the value of FPN_a in decimal format
                                                 ;<-
dispExact_exit:    
              BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set in absFPN subroutine above
              BCLR flag2,#BIT3                   ;clear expNeg flag in case it was set in dispDec subroutine above                 

              BCLR PTH,#BIT0                     ;A0 = 0,send command

              PULD                               ;D = memAddr1 (current position on the user stack)

              RTS 

;dispExp: displays the exponent in e_a and its sign

dispExp:      LDAA e_a                           ;PAGE_FB
              BPL dispExp_1                      ;branch if exponent is non-negative
              NEGA                               ;otherwise negate A and set expNeg flag
              BSET flag2,#BIT3
  
dispExp_1:    CLR counter1                       ;counter1 stores the 10's place digit     
              
dispExp_2:    SUBA #$A                           ;subtract 10
              BCS dispExp_3                      ;result < 0 -> exit loop and add 10
              INC counter1                       ;otherwise increment counter1 and repeat
              BRA dispExp_2 
              
dispExp_3:    ADDA #$A                           ;after adding 10 A is equal to 1's place digit                            
              
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display the 1's place digit of the exponent
              JSR sendData
              
              JSR backY                          ;move Y one digit to the left
              
              TST counter1
              BEQ dispExp_4                      ;do not display the 10's place digit if it is zero
              
              LDAA counter1                      
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              
              JSR sendData                       ;display the 10's place digit of the exponent
              
              JSR backY                          ;decrement Y                      
                         
dispExp_4:    BRCLR flag2,#BIT3,dispExp_5        ;do not display "-" if expNeg flag is clear                     
              
              JSR dispNeg                        ;otherwise display "-"             

dispExp_5:    JSR backY                          ;move Y one digit to the left   

              RTS

;dispExpSL: displays the exponent in e_a and its sign in SL font

dispExpSL:    LDAA e_a                           ;PAGE_FB
              BPL dispExpSL_1                    ;branch if exponent is non-negative
              NEGA                               ;otherwise negate A and set expNeg flag
              BSET flag2,#BIT3
  
dispExpSL_1:  CLR counter1                       ;counter1 stores the 10's place digit     
              
dispExpSL_2:  SUBA #$A                           ;subtract 10
              BCS dispExpSL_3                    ;result < 0 -> exit loop and add 10
              INC counter1                       ;otherwise increment counter1 and repeat
              BRA dispExpSL_2 
              
dispExpSL_3:  ADDA #$A                           ;after adding 10 A is equal to 1's place digit                            
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X
              
              MOVB #wFontSL,colNumber            ;display the 1's place digit of the exponent
              JSR sendData
              
              JSR backYSL                        ;move Y one digit to the left
              
              LDAA counter1                      
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X
              
              MOVB #wFontSL,colNumber              
              JSR sendData                       ;display the 10's place digit of the exponent
              
              JSR backYSL                        ;move Y one digit to the left                     
                         
dispExpSL_4:  BRCLR flag2,#BIT3,dispExpSL_5      ;do not display "-" if expNeg flag is clear                     
              
              LDX #Hyp                           ;otherwise display "-"
              MOVB #wFontSL,colNumber
              JSR sendData
              
dispExpSL_5:  JSR backYSL                        ;move Y one digit to the left  

              RTS

;dispHex: displays the value of FPN_a in hexadecimal/binary on the current page

dispHex:      MOVB #$7A,Ycoord                   ;PAGE_FB
						  MOVB Ycoord,savedY
						  JSR setY                           ;Y = 122     

              LDD memAddr1
              PSHD                               ;push memAddr1 onto the stack
            
              MOVW #m_a,memAddr1
              
              JSR lzMan                          ;determine the number of leading zeros in FPN_a
              LDAA noZero          
              CMPA #lenMan
              BNE dispHex_1                      ;branch if noZero <> lenMan, i.e. if FPN_a <> 0
              
              JSR dispZero2                      ;otherwise display "0000 0000 0000 0000" and exit
              LBRA dispHex_5         

dispHex_1:    JSR tzFPN                          ;eliminate trailing zeros in FPN_a

              LDAA e_a
              BPL dispHex_2                      ;branch if e_a >= 0, i.e. if FPN_a is an integer
              
dispHex_1_1:  LDX #Minus
              MOVB #wFont,colNumber
              JSR sendData                       ;otherwise display "-" and exit
              
              LBRA dispHex_5                                   
              
dispHex_2:    MOVW #m_a,memAddr1
              MOVW #m_f,memAddr2
              JSR copyFPN                        ;FPN_f = FPN_a     

              LDX #m_b                           ;set FPN_b = 09 99 99 99 99 99 99 99 00 ->
              MOVB #$09,1,X+
                            
              LDAA #$99
              STAA 1,X+
              STAA 1,X+
              STAA 1,X+
              STAA 1,X+
              STAA 1,X+
              STAA 1,X+
              STAA 1,X+
                            
              CLRA
              STAA 0,X                           ;<-             
              
              JSR cmpFPN_LE                      ;sets le flag if FPN_a <= FPN_b
                                                 ;i.e. if FPN_a <= 999,999,999,999,999 
              
              BRSET flag5,#BIT1,dispHex_2_1      ;branch if le flag set, i.e. if FPN_a <= 999,999,999,999,999

              BRA dispHex_1_1                    ;otherwise display "-" and exit
              
dispHex_2_1:  MOVW #m_f,memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_f
              
              LDX #m_b                           ;set FPN_b = 90 00 00 00 00 00 00 01 00 ->
              MOVB #$90,1,X+
              
              CLRA
              STAA 1,X+
              STAA 1,X+
              STAA 1,X+             
              STAA 1,X+
              STAA 1,X+
              STAA 1,X+
                            
              MOVB #$01,1,X+
              
              STAA 0,X                           ;<- 
              
              JSR cmpFPN_GE                      ;sets ge flag if FPN_a >= FPN_b
                                                 ;i.e. if FPN_a >= -999,999,999,999
                                                 
              BRSET flag5,#BIT0,dispHex_3        ;branch if ge flag set, i.e. if FPN_a >= -999,999,999,999
              
              BRA dispHex_1_1                    ;otherwise display "-" and exit                                  
              
dispHex_3:    BCLR flag2,#BIT4                   ;clear manNeg flag
              
              MOVW #m_f,memAddr1
              
              JSR absFPN                         ;set FPN_f to its absolute value and set manNeg flag if required
              
              TST e_f
              BEQ dispHex_3_4                    ;branch if e_f = 0 (FPN_f is in integer form)
              
dispHex_3_3:  JSR multMan10                      ;multiply FPN_f by 10
              DEC e_f                            ;decrement e_f to maintain equality
              BNE dispHex_3_3       
              
dispHex_3_4:  MOVB #lenManBytes,lenMemBytes      ;lenMemBytes = lenManBytes for BCDToBin2 subroutine  

              MOVW #m_f,memAddr2
              MOVW #m_a,memAddr1
              
              JSR BCDToBin2                      ;convert m_f to binary and store in m_a
              
              MOVB #lenExpBytes,lenMemBytes      ;lenMemBytes = lenExpBytes to update value of exponent when entering
                                                 ;values on the command line
              
              BRCLR flag2,#BIT4,dispHex_4        ;branch if FPN_f was positive
              
              MOVB #$07,counter1                 ;otherwise set m_a = FF FF FF FF FF FF FF FF - m_a ->
                            
              LDX #m_a
              
dispHex_3_1:  LDAA #$FF
              SUBA 0,X
              STAA 1,X+                                        
              DEC counter1
              BNE dispHex_3_1                                   
              
              LDAA #$FF
              SUBA 0,X
              STAA 0,X                           ;<-
              
              ADDA #$01                          ;set m_a = m_a + 1 ->
              STAA 1,X-
              
              MOVB #$07,counter1
              
dispHex_3_2:  LDAA 0,X
              ADCA #$00
              STAA 1,X-                                   
              DEC counter1
              BNE dispHex_3_2                    ;<-                        
              
dispHex_4:    BRCLR flag4,#BIT0,dispHex_4_1      ;branch if bin flag clear
 
              JSR dispBin2                       ;otherwise display 4 LS digits of m_a in binary 
              
              BRA dispHex_4_2   

dispHex_4_1:  MOVB #lenMan,counter3  

              JSR dispManDgt2                    ;display counter3 digits of m_a, from LS to MS digit
              
dispHex_4_2:  BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set in absFPN subroutine above                 
           
dispHex_5:    BCLR PTH,#BIT0                     ;A0 = 0,send command

              PULD                               ;D = memAddr1 (current position on the calculator stack)
                                      
              RTS              

;DISPinit: initialise the ST7565 GLCD;;;;;;;;;;;;;
                                                 ;PAGE_FB
DISPinit:     BCLR PORTA,#BIT0                   ;RST = 0
                          
              JSR delay                          ;delay 
            
              BSET PORTA,#BIT0                   ;RST = 1
              
              BCLR PTH,#BIT0                     ;A0 = 0, send command            
                          
              LDAA #$A3
            
              JSR sendByte                       ;set bias to 1/7                 
            
              LDAA #$A1                   
            
              JSR sendByte                       ;set display to reverse (complements COM output scan direction)
            
              LDAA #$C0                   
            
              JSR sendByte                       ;set COM output scan direction to normal
            
              LDAA #$A6                   
            
              JSR sendByte                       ;set display to normal (i.e. not reverse)
            
              LDAA #$60                   
            
              JSR sendByte                       ;set RAM display start line to 32 (01 100000)
              
              LDAA #$2C                   
            
              JSR sendByte               
            
              JSR delay                          ;delay
            
              LDAA #$2F                   
            
              JSR sendByte               
            
              JSR delay                          ;delay
            
              LDAA #$AF                   
            
              JSR sendByte                       ;display on
            
              LDAA #$A4                   
            
              JSR sendByte                       ;normal display (i.e. not all pixels on)     

              RTC
              
;dispLbl2: displays program line number stored in D on the specified page and Y value

                                                 ;PAGE_FB
dispLbl2:     CLR counter4                       ;counter4 stores the 1000's place digit of the number
              CLR counter3                       ;counter3 stores the 100's place digit of the number      
              CLR counter1                       ;counter1 stores the 10's place digit of the value/number
              
dispLbl2_4:   SUBD #$03E8                        ;subtract 1000
              BCS dispLbl2_5                     ;result < 0 -> exit loop and add 1000
              INC counter4                       ;otherwise increment counter4 and repeat
              BRA dispLbl2_4
               
dispLbl2_5:   ADDD #$03E8

dispLbl2_0:   SUBD #$64                          ;subtract 100
              BCS dispLbl2_0_0                   ;result < 0 -> exit loop and add 100
              INC counter3                       ;otherwise increment counter3 and repeat
              BRA dispLbl2_0                   
              
dispLbl2_0_0: ADDD #$64                           

dispLbl2_1:   SUBD #$0A                          ;subtract 10
              BCS dispLbl2_2                     ;result < 0 -> exit loop and add 10
              INC counter1                       ;otherwise increment counter1 and repeat
              BRA dispLbl2_1 
              
dispLbl2_2:   ADDD #$0A                          ;after adding 10 B is equal to the 1's place digit
              
              PSHB                               ;push the 1's place digit of the stack label value onto the stack
              
              TST counter4
              BEQ dispLbl2_6                     ;branch if the 1000's place digit = 0 
                            
              INS
              INS
              INS
              PULX                               ;pull digits address into X
              DES
              DES
              DES
              DES
              DES                                ;SP points to 1's place digit          
              
              LDAA counter4
                           
              LDAB #wFont 
                                                    
              MUL              
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              
               
              JSR sendData                       ;display the 1000's place digit of the stack label value
              
              BRA dispLbl2_7           
              
dispLbl2_6:   TST counter3
              BEQ dispLbl2_2_1                   ;branch if the 100's place digit = 0
              
dispLbl2_7:   INS
              INS
              INS
              PULX                               ;pull digits address into X
              DES
              DES
              DES
              DES
              DES                                ;SP points to 1's place digit                              
              
              LDAA counter3
                           
              LDAB #wFont 
                                                    
              MUL              
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              
               
              JSR sendData                       ;display the 100's place digit of the stack label value
              
              BRA dispLbl2_2_2
              
dispLbl2_2_1: TST counter1
              BEQ dispLbl2_3                     ;branch if the 10's place digit = 0
              
dispLbl2_2_2: INS
              INS
              INS
              PULX                               ;pull digits address into X
              DES
              DES
              DES
              DES
              DES                                ;SP points to 1's place digit
              
              LDAA counter1
                            
              LDAB #wFont
              
              MUL              
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber
                                          
              JSR sendData                       ;display the 10's place digit of the stack label value
              
dispLbl2_3:   PULA                               ;A = 1's place digit

              INS
              INS
              PULX                               ;pull digits address into X
              DES
              DES
              DES
              DES                                ;SP points to return address
                               
              LDAB #wFont
              
              MUL     
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber
                      
              JSR sendData                       ;display the 1's place digit of the stack label value
              
              RTS

;dispLblH: displays the program instruction code stored in A in hexadecimal on the specified page and Y value 

dispLblH:     PSHA                               ;PAGE_FB
              
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDX #DigitSL
                            
              LDAB #wFontSL
                                      
              MUL              
              ABX                                ;add B to X
              
              MOVB #wFontSL,colNumber
 
              JSR sendData                       ;display the MS digit of the instruction code
              
              PULA                               
              ANDA #$0F
              
              LDX #DigitSL
                            
              LDAB #wFontSL
                                      
              MUL              
              ABX                                ;add B to X
              
              MOVB #wFontSL,colNumber
 
              JSR sendData                       ;display the LS digit of the instruction code
              
              RTS     

;dispManDgt: display counter3 digits of the mantissa of FPN_M1, from LS to MS digit

                                                 ;PAGE_FB
dispManDgt:   JSR divMan10                       ;shift LS digit of mantissa of FPN_M1 into A
              
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              
              JSR sendData                       ;display the LS digit of mantissa of FPN_M1
              
              JSR backY                          ;move Y one digit to the left
              
              DEC counter3
              BNE dispManDgt
              
              RTS
              
;dispManDgt2: display counter3 digits of the mantissa of FPN_M1, in blocks of 4 and in SL font, from LS to MS digit

dispManDgt2:  LDAA counter4                      ;PAGE_FB
              PSHA
                
              DEC counter3  
              MOVB #$04,counter4  

dispManDgt2_1:
              JSR divMan10                       ;shift LS digit of mantissa of FPN_M1 into A
              
              LDAB #wFontSL
              MUL
              
              LDX #DigitSL
              ABX                                ;add B to X
              
              MOVB #wFontSL,colNumber              
              JSR sendData                       ;display the LS digit of mantissa of FPN_M1
              
              JSR backYSL                        ;move Y one digit to the left
              
              DEC counter4
              BNE dispManDgt2_2                  
              
              LDX #Space                          
              MOVB #wFontSL,colNumber
              JSR sendData                       ;otherwise insert a space 
              
              JSR backYSL                        ;move Y one digit to the left
              
              MOVB #$04,counter4 
              
dispManDgt2_2:
              DEC counter3
              BNE dispManDgt2_1
              
              JSR divMan10                       ;shift LS digit of mantissa of FPN_M1 into A
              
              LDAB #wFontSL
              MUL
              
              LDX #DigitSL
              ABX                                ;add B to X
              
              MOVB #wFontSL,colNumber              
              JSR sendData                       ;display the MS digit of mantissa of FPN_M1
              
              PULA
              STAA counter4                      ;restore counter4
              
              RTS
              
;dispManDgtSL: display counter3 digits of the mantissa of FPN_M1 in SL font, from LS to MS digit

                                                 ;PAGE_FB
dispManDgtSL: JSR divMan10                       ;shift LS digit of mantissa of FPN_M1 into A
              
              LDAB #wFontSL
              MUL
                             
              LDX #DigitSL
              ABX                                ;add B to X
              
              MOVB #wFontSL,colNumber              
              JSR sendData                       ;display the LS digit of mantissa of FPN_M1
              
              JSR backYSL                        ;move Y one digit to the left
              
              DEC counter3
              BNE dispManDgtSL
              
              RTS

;dispMem: display memory at FPN_1;;;;;;;;;;;;;;;;;

                                                 ;PAGE_FB
dispMem:      CALL clearStack2                   ;clear pages 0 - 6

              BCLR PTH,#BIT0                     ;A0 = 0, send command	

			        LDAA #$B0                          ;page 0  
              JSR sendByte                       ;set the page
			        
			        JSR setY                           ;Y = 0
			        
			        LDX #Addr
			        MOVB #$30,colNumber                ;colNumber = 48
			        JSR sendData                       ;display "Address:"
			        
			        MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
              
              LDX #Doll
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "$" 
			        
			        LDD usPointer
              PSHD
              PSHD                     
              PSHD
              PSHD
              PSHD                               ;usPointer is pushed onto the stack five times
              
              MOVB #$02,counter1                                                     
              
dispMem_1:    LDAA 0,SP                          ;display the starting address ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispMem_1                      ;<-
              
              LDX #Hyp
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "-" 
			        
			        LDX #Doll
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "$" 
			        
			        PULD
			        ADDD #lenManBytes
			        PSHD                               ;the end address is pushed onto the stack
			        
			        MOVB #$02,counter1   
			        
dispMem_2:    LDAA 0,SP                          ;display the end address ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispMem_2                      ;<-
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B7                          ;set to page 7
              JSR sendByte              
              
              JSR clearPage                      ;clear page 7
			        
			        BCLR PTH,#BIT0                     ;A0 = 0, send command
              
              LDAA #$B1
              JSR sendByte                       ;set to page 1
              
              MOVB #$0E,Ycoord
              JSR setY                           ;Y = 14
              
              PULY                               ;Y = usPointer address
              
              MOVB #lenManBytes,counter1                            
              
dispMem_3:    LDAA 0,Y                           ;display the mantissa in BCD ->
              
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData         
              
              LDAA 1,Y+
              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData         
              
              DEC counter1
              BNE dispMem_3                      ;<-               
              
              MOVB #$74,Ycoord
              JSR setY                           ;Y = 116
              
              LDAA 0,Y                           ;display the exponent in hexadecimal ->
              
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData         
              
              LDAA 0,Y
              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData                       ;<-
              
              BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B2                          ;set to page 2
              JSR sendByte
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Deci			        
              MOVB #$18,colNumber
              JSR sendData                       ;display "Dec:" at the beginning of page 2                       
                             
              MOVB #$7A,savedY
              MOVB savedY,Ycoord
              JSR setY                           ;Y = 122
              
              PULY                               ;Y = usPointer address
              STY memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = (usPointer)
              
              MOVW #m_a,memAddr1
              BCLR flag2,#BIT4                   ;clear manNeg flag
              JSR absFPN                         ;|FPN_a| -> FPN_a
              
              JSR lzMan                          ;determine number of leading zeros in FPN_a and store in noZero
              
              LDAA noZero          
              CMPA #lenMan
              BNE dispMem_4                      ;branch if noZero <> lenMan, i.e. if FPN_a <> 0
              
              JSR dispZeroSL                     ;otherwise display "0" and branch
              BRA dispMem_5    
              
dispMem_4:    JSR tzFPN                          ;eliminate any trailing zeros in FPN_a. e_a and noZero are 
                                                 ;adjusted accordingly            
              
              JSR dispExpSL                      ;display the decimal value of the exponent
              
              LDAA #lenMan
              SUBA noZero
              STAA counter3
              JSR dispManDgtSL                   ;display counter3 digits of FPN_a in decimal
               
              BRCLR flag2,#BIT4,dispMem_5        ;branch if the mantissa is non-negative
              LDX #Hyp                           ;otherwise display "-" before exiting
              MOVB #wFontSL,colNumber
              JSR sendData                                   

dispMem_5:    BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B3                          ;set to page 3
              JSR sendByte
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Hexi			        
              MOVB #$18,colNumber
              JSR sendData                       ;display "Hex:" at the beginning of page 3 
              
              MOVB #$74,Ycoord
              JSR setY                           ;Y = 116
              
              PULY                               ;Y = usPointer address
              
              STY memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_Y               
              
              LDAA e_a                           ;display the exponent in hexadecimal ->
              
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData         
              
              LDAA e_a
              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData                       ;<-          
              
              MOVB #lenManBBytes,lenMemBytes     ;lenMemBytes = lenManBBytes for BCDToBin subroutine
              
              MOVW #m_a,memAddr2
              MOVW #m_c,memAddr1 
              
              JSR BCDToBin                       ;convert FPN_a mantissa to binary and store in FPN_c
              
              MOVB #lenExpBytes,lenMemBytes      ;lenMemBytes = lenExpBytes to update value of exponent when entering
                                                 ;values on the command line 
                                                 
              MOVB #$1A,Ycoord
              JSR setY                           ;Y = 26              
              
              MOVB #lenManBBytes,counter1
              
              LDY #m_c                            
              
dispMem_6:    LDAA 0,Y                           ;display the mantissa in hexadecimal ->
              
              ASRA
              ASRA
              ASRA
              ASRA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData         
              
              LDAA 1,Y+
              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData         
              
              DEC counter1
              BNE dispMem_6                      ;<-
              
              MOVW #m_c,memAddr1
              
              BCLR PTH,#BIT0                     ;A0 = 0,send command
              
              LDAA #$B4                          ;set to page 4
              JSR sendByte
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Bini			        
              MOVB #$18,colNumber
              JSR sendData                       ;display "Bin:" at the beginning of page 4
              
              MOVB #$B4,pageNumber
              
              MOVB #$03,counter1
 
dispMem_7:    MOVB #$02,counter2                 ;number of bytes to be displayed
              
              MOVB #$1A,Ycoord
              JSR setY                           ;Y = 26 
              
              JSR dispBin                        ;display the binary value of two of the bytes in the mantissa
              
              INC pageNumber                     ;go to the next page
              
              BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA pageNumber                    ;set the page
              JSR sendByte
              
              DEC counter1
              BNE dispMem_7
              
              MOVB #$01,counter2                 ;one (last) byte of mantissa to be displayed
              
              MOVB #$1A,Ycoord
              JSR setY                           ;Y = 26 
              
              JSR dispBin                        ;display the binary value of the last byte in the mantissa
              
              LDX #m_c
              
              MOVB e_a,0,X                       ;MS byte of m_c = e_a
              
              MOVB #$01,counter2                 ;exponent to be displayed in binary 
              
              JSR dispBin                        ;display the binary value of the exponent                  

              RTS

;dispMemCpx: display the complex number memory contents

                                                 ;PAGE_FB
dispMemCpx:   CALL clearStack2                   ;clear pages 0 - 6

              BCLR PTH,#BIT0                     ;A0 = 0, send command	

			        LDAA #$B0                          ;page 0  
              JSR sendByte                       ;set the page
			        
			        JSR setY                           ;Y = 0
			        
			        LDX #Addr
			        MOVB #$30,colNumber                ;colNumber = 48
			        JSR sendData                       ;display "Address:"
			        
			        MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
              
              LDX #Doll
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "$" 
			        
			        LDD usPointer
              PSHD
              PSHD
              PSHD
              PSHD
              PSHD
              PSHD                               ;usPointer is pushed onto the stack six times
              
              MOVB #$02,counter1                                                     
              
dispMemCpx_1: LDAA 0,SP                          ;display the starting address ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispMemCpx_1                   ;<-
              
              LDX #Hyp
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "-" 
			        
			        LDX #Doll
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "$" 
			        
			        PULD
			        ADDD #lenManBytes
			        PSHD                               ;the end address is pushed onto the stack
			        
			        MOVB #$02,counter1   
			        
dispMemCpx_2: LDAA 0,SP                          ;display the end address ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispMemCpx_2                   ;<-
              
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B7                          ;set to page 7
              JSR sendByte              
              
              JSR clearPage                      ;clear page 7
			        
			        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B1                          ;set to page 1
              JSR sendByte
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Rez			        
              MOVB #$24,colNumber
              JSR sendData                       ;display "Re(z)=" at the beginning of page 1
			        
			        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			        
			        BCLR PTH,#BIT0                     ;A0 = 0, send command
              
              LDAA #$B2
              JSR sendByte                       ;set to page 2
              
              PULY                               ;Y = usPointer address
              STY memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              JSR dispNum                        ;display the real part of z
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              BCLR PTH,#BIT0                     ;A0 = 0, send command	

			        LDAA #$B4                          ;page 4  
              JSR sendByte                       ;set the page
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              					    
			        LDX #Addr
			        MOVB #$30,colNumber                ;colNumber = 48
			        JSR sendData                       ;display "Address:"
			        
			        MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
              
              LDX #Doll
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "$"
			        
			        PULD 
			        ADDD #$1301                        ;D points to the imaginary part mantissa
			        PSHD 
			        
			        MOVB #$02,counter1                                                     
              
dispMemCpx_5: LDAA 0,SP                          ;display the starting address ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispMemCpx_5                   ;<-
              
              LDX #Hyp
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "-" 
			        
			        LDX #Doll
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "$" 
			        
			        PULD
			        ADDD #$1301                        ;D points to the imaginary part mantissa		         
			        ADDD #lenManBytes                  ;D points to the imaginary part exponent
			        PSHD		                                      
			        
			        MOVB #$02,counter1   
			        
dispMemCpx_6: LDAA 0,SP                          ;display the end address ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispMemCpx_6                   ;<-
			        
			        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B5                          ;set to page 5
              JSR sendByte
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Imz			        
              MOVB #$24,colNumber
              JSR sendData                       ;display "Im(z)=" at the beginning of page 5
			        
			        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              BCLR PTH,#BIT0                     ;A0 = 0, send command
              
              LDAA #$B6
              JSR sendByte                       ;set to page 6
              
              PULD
              ADDD #$1301                        ;D points to the imaginary part mantissa
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              JSR dispNum                        ;display the imaginary part of z
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              RTS
              
;dispMemRat: display the rational number memory contents

                                                 ;PAGE_FB
dispMemRat:   CALL clearStack2                   ;clear pages 0 - 6

              BCLR PTH,#BIT0                     ;A0 = 0, send command	

			        LDAA #$B0                          ;page 0  
              JSR sendByte                       ;set the page
			        
			        JSR setY                           ;Y = 0
			        
			        LDX #Addr
			        MOVB #$30,colNumber                ;colNumber = 48
			        JSR sendData                       ;display "Address:"
			        
			        MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
              
              LDX #Doll
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "$" 
			        
			        LDD usPointer
              PSHD
              PSHD
              PSHD
              PSHD
              PSHD
              PSHD                               ;usPointer is pushed onto the stack six times
              
              MOVB #$02,counter1                                                     
              
dispMemRat_1: LDAA 0,SP                          ;display the starting address ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispMemRat_1                   ;<-
              
              LDX #Hyp
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "-" 
			        
			        LDX #Doll
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "$" 
			        
			        PULD
			        ADDD #lenManBytes
			        PSHD                               ;the end address is pushed onto the stack
			        
			        MOVB #$02,counter1   
			        
dispMemRat_2: LDAA 0,SP                          ;display the end address ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispMemRat_2                   ;<-
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B7                          ;set to page 7
              JSR sendByte              
              
              JSR clearPage                      ;clear page 7
			        
			        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B1                          ;set to page 1
              JSR sendByte
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Num			        
              MOVB #$3C,colNumber
              JSR sendData                       ;display "Numerator=" at the beginning of page 1
			        
			        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			        
			        BCLR PTH,#BIT0                     ;A0 = 0, send command
              
              LDAA #$B2
              JSR sendByte                       ;set to page 2
              
              PULY                               ;Y = usPointer address
              STY memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              JSR dispNum                        ;display the numerator
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;              
              
              BCLR PTH,#BIT0                     ;A0 = 0, send command	

			        LDAA #$B4                          ;page 4  
              JSR sendByte                       ;set the page
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              					    
			        LDX #Addr
			        MOVB #$30,colNumber                ;colNumber = 48
			        JSR sendData                       ;display "Address:"
			        
			        MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
              
              LDX #Doll
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "$"
			        
			        PULD 
			        ADDD #$13B5                        ;D points to the mantissa of the denominator
			        PSHD 
			        
			        MOVB #$02,counter1                                                     
              
dispMemRat_5: LDAA 0,SP                          ;display the starting address ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispMemRat_5                   ;<-
              
              LDX #Hyp
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "-" 
			        
			        LDX #Doll
			        MOVB #wFontSL,colNumber            ;colNumber = wFontSL
			        JSR sendData                       ;display "$" 
			        
			        PULD
			        ADDD #$13B5                        ;D points to the mantissa of the denominator		         
			        ADDD #lenManBytes                  ;D points to the exponent of the denominator
			        PSHD		                                      
			        
			        MOVB #$02,counter1   
			        
dispMemRat_6: LDAA 0,SP                          ;display the end address ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispMemRat_6                   ;<-
			        
			        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			        
			        BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B5                          ;set to page 5
              JSR sendByte
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Den			        
              MOVB #$48,colNumber
              JSR sendData                       ;display "Denominator=" at the beginning of page 5
			        
			        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              BCLR PTH,#BIT0                     ;A0 = 0, send command
              
              LDAA #$B6
              JSR sendByte                       ;set to page 6
              
              PULD
              ADDD #$13B5                        ;D points to the denominator
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              JSR dispNum                        ;display the denominator
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;              
               
              RTS

;dispNeg: displays "-" at the current position of Y                    

dispNeg:      LDX #Minus                         ;PAGE_FB
              MOVB #wFont,colNumber
              JSR sendData
              
              RTS

;dispNum: displays the value of FPN_a on the current page

dispNum:      MOVB #$78,Ycoord                   ;PAGE_FB
						  MOVB Ycoord,savedY
						  JSR setY                           ;Y = 120     

              LDD memAddr1
              PSHD                               ;push memAddr1 onto the stack
            
              BCLR flag2,#BIT3                   ;clear manNeg and expNeg flags
              BCLR flag2,#BIT4
              
              MOVW #m_a,memAddr1
              
              JSR absFPN                         ;set FPN_a to its absolute value and set manNeg flag if required
              
              JSR lzMan                          ;determine the number of leading zeros in FPN_a
              LDAA noZero          
              CMPA #lenMan
              BNE dispNum_1                      ;branch if noZero <> lenMan, i.e. if FPN_a <> 0
              
              JSR dispZero                       ;otherwise display "0" and exit
              BRA dispNum_3             

dispNum_1:    JSR shFPN                          ;set FPN_a to a 10-digit mantissa for display

              JSR tzFPN                          ;eliminate trailing zeros in FPN_a 
              
              BRCLR flag1,#BIT3,dispNum_2        ;branch if sci flag not set
              
              JSR dispSci                        ;otherwise display the value of FPN_a in scientific format
              
              BRA dispNum_3
              
dispNum_2:    JSR dispDec                        ;display the value of FPN_a in decimal format                 
           
dispNum_3:    BCLR flag2,#BIT4                   ;clear manNeg flag in case it was set in absFPN subroutine above

              BCLR flag2,#BIT3                   ;clear expNeg flag in case it was set in dispDec subroutine above                 

              BCLR PTH,#BIT0                     ;A0 = 0,send command

              PULD                               ;D = memAddr1 (current position on the calculator stack)
                                      
              RTS

;dispPrgIstr: display the program line number, code and instruction
 
                                                 ;PAGE_FB
dispPrgIstr:  PSHD                               ;address of program instruction pushed onto the stack
              PSHD
              PSHD                

              CLR Ycoord
              JSR setY                           ;Y = 0
              
              PULD
              CPD prgCounter
              BEQ dispPrgIstr_1                  ;branch if address of program instruction = prgCounter               
              
              LDX #Digit                                                 
              BRA dispPrgIstr_2
              
dispPrgIstr_1:LDX #stackLevels

dispPrgIstr_2:SUBD prgCounterSt
              
              PSHX 
              
              JSR dispLbl2                       ;display the program line number (i.e. value in D) 
              
              INS
              INS                                ;SP points to second D value pushed onto the stack at beginning of 
                                                 ;subroutine
              MOVB #$26,Ycoord
              JSR setY                           ;Y = 38              
              
              PULX                               ;X = address of program instruction 
              LDAA 0,X                           ;A = program instruction code
              PSHA              
                                                 
              JSR dispLblH                       ;display the program instruction code (i.e. value in A) in hex
                                                 
              CLRA
              PULB                               ;B = program instruction code              
              ASLD                               ;multiply by 2 to obtain offset
                            
              PSHD
              INS
              INS
              
              PULD               
              SUBD #$0001                        ;point to the previous address
              CPD prgCounterSt                    
              BEQ dispPrgIstr_3                  ;branch if at the beginning of the program
              
              XGDX                               ;otherwise exchange registers D and X
              LDAA 0,X                           ;A = previous program instruction code
              CMPA #$EF                          
              BNE dispPrgIstr_3                  ;branch if not a 2-byte instruction
              
              LDX #keyTable2ByteEFTHREE          ;otherwise X = keyTable2ByteEFTHREE               
              
              BRA dispPrgIstr_4             
              
dispPrgIstr_3:LDX #keyTableTHREE
              
dispPrgIstr_4:DES
              DES
              DES
              DES                                ;S points to offset
              
              PULD                               ;D = offset              
              
              JSR keyHdlr                        ;display the instruction              
                            
              PULD                               ;D = address of program instruction

              RTC              

;dispSci: displays the value of FPN_a in scientific format. Note: mantissa must be maxLenMan digits long.

dispSci:      LDAA #maxLenMan                    ;PAGE_FB
              SUBA noZero
              DECA
              
              PSHA                               ;A = maxLenMan - noZero - 1               
                                                        
              ADDA e_a
              STAA e_a                           ;set e_a to scientific format value
              
              JSR dispExp                        ;display the exponent 
              
              PULA
              TSTA
              BEQ dispSci_1                      ;branch if the mantissa is only one digit long
              
              STAA counter3
              
              JSR dispManDgt                     ;display counter3 digits of the mantissa of FPN_a, 
                                                 ;from LS to MS digit                                                 
              JSR dispDp
              
              JSR backY                          ;move Y one digit to the left              
           
dispSci_1:    MOVB #$01,counter3
              JSR dispManDgt                     ;display the MS digit of FPN_a    

              BRCLR flag2,#BIT4,dispSci_2        ;do not display "-" if manNeg flag is clear                     
              
              JSR dispNeg                        ;otherwise display "-"     

dispSci_2:    RTS

;dispStack: clears the stack and displays the stack level labels
                                                 ;PAGE_FB
dispStack:    JSR clearStack                     ;clear pages 1 - 5    

              LDAB screenNumber                    
              LDAA #$05
              MUL
              
              PSHB                               ;push 5 * pageNumber onto the stack
              INCB
              PSHB                               ;push 5 * pageNumber + 1 = first stack level label onto the stack
              
              MOVB #$05,counter2                 ;stack 1,2,3,4,5 (dispLbl subroutine uses counter1)    

              MOVB #$B5,pageNumber               ;start at level 1 (page 5)

dispStack_1:  BCLR PTH,#BIT0                     ;A0 = 0,send command
              
              LDAA pageNumber
              JSR sendByte                       ;set the page
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              CLRA
              LDAB 0,SP                          ;B = 5 * q + n (1 =< n =< 5)
              
              LDX #stackLevels
              PSHX
              
              JSR dispLbl2                       ;display the stack label
              
              INS
              INS
              
              PULA
              INCA
              PSHA                               ;push the next stack label value onto the stack
                           
              DEC pageNumber                     ;go to the next page                   
              
              DEC counter2              
              BNE dispStack_1 

              PULA
              PULA                               ;A = 5 * q 

              RTC
              
;dispStackTWO: displays stack level labels 1 - 5

dispStackTWO: LDAB screenNumber                  ;PAGE_FB  
              LDAA #$05
              MUL
              
              INCB
              PSHB                               ;push 5 * pageNumber + 1 = first stack level label onto the stack
              
              MOVB #$05,counter2                 ;stack 1,2,3,4,5 (dispLbl subroutine uses counter1)    

              MOVB #$B5,pageNumber               ;start at level 1 (page 5)

dispStackTWO_1: 
              BCLR PTH,#BIT0                     ;A0 = 0,send command
              
              LDAA pageNumber
              JSR sendByte                       ;set the page
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              CLRA
              LDAB 0,SP                          ;B = 5 * q + n (1 =< n =< 5)
              
              LDX #stackLevels
              PSHX
              
              JSR dispLbl2                       ;display the stack label
              
              INS
              INS
              
              PULB
              INCB
              PSHB                               ;push the next stack label value onto the stack
                           
              DEC pageNumber                     ;go to the next page                   
              
              DEC counter2              
              BNE dispStackTWO_1
               
              INS
              
              RTC

;dispStatL: clears page 0 and displays the modes;;
                                                 ;PAGE_FB
dispStatL:    BCLR PTH,#BIT0                     ;A0 = 0, send command	

			        LDAA #$B0                          ;page 0  
              JSR sendByte                       ;set the page
              
              JSR clearPage                      ;clear page 0          
              
              CLR Ycoord
              JSR setY
              
              LDX #TwoAdic
              
              MOVB #$24,colNumber
              
              BRSET flag5,#BIT7,dispStatL_6
              
              LDX #Cpxi
              
              BRSET flag4,#BIT1,dispStatL_1
              
              LDX #Bini
              
              BRSET flag4,#BIT0,dispStatL_1
              
              LDX #Hexi
              
              BRSET flag3,#BIT2,dispStatL_1
              
              LDX #Deci
			        
			        BRCLR flag1,#BIT3,dispStatL_1
			        
			        LDX #Sci     
			        
dispStatL_1:  MOVB #$12,colNumber
                             
dispStatL_6:  LDAA #$80                          ;calculate remaining width of screen
              SUBA colNumber
              PSHA

              JSR sendData2                      ;display underlined mode annunciator 
              
              PULA                               ;display remaining portion of line ->
              STAA colNumber
              
              LDAA #$80
              
dispStatL_2:  JSR sendByte
              DEC colNumber
              BNE dispStatL_2                    ;<-
              
              MOVB #$50,Ycoord
              JSR setY                           ;set Y coordinate to 80
              
              LDX #Grad
              MOVB #$18,colNumber              
              
              BRSET flag1,#BIT6,dispStatL_3      ;branch if in "Grad" mode                       
              
              MOVB #$12,colNumber
              
              LDX #Deg
              
              BRCLR flag4,#BIT4,dispStatL_3      ;branch if in "Deg" mode
              
              LDX #Rad              
              
dispStatL_3:  JSR sendData2                      ;display underlined angle annunciator 
              
              MOVB #$7A,Ycoord
              JSR setY                           ;set Y coordinate to 122 
              
              MOVB #$06,colNumber             
              
              BRSET flag4,#BIT2,dispStatL_4      ;branch if exact mode set
              
              LDX #Approx                        ;otherwise display approximate annunciator
              
              BRA dispStatL_5
              
dispStatL_4:  LDX #Exact

dispStatL_5:  JSR sendData2                      ;display underlined mode annunciator
              
              MOVB #$25,Ycoord
              JSR setY                           ;set Y coordinate to 37
              
              LDD usPointer
              CPD #$2000
              BNE dispStatL_exit                 ;exit if the top of the stack has not been reached
              
              LDX #End
              MOVB #$12,colNumber
              
              JSR sendData2                      ;display "END" (underlined)
              
dispStatL_exit:
              RTC
              
;dispStatLI: displays "Shift"/"Alpha"/"ERROR"/"END"/"STO"   ***********remove "END"?
                                                 ;PAGE_FB
dispStatLI:   MOVB Ycoord,savedY     

              BCLR PTH,#BIT0                     ;A0 = 0,send command
                            
              LDAA #$B0                          ;page 0 
              JSR sendByte                       ;set the page        

              MOVB #$25,Ycoord
              JSR setY                           ;Y = 37
              
              JSR sendData2                      ;display annunciator (underlined)
              
              BCLR PTH,#BIT0                     ;A0 = 0,send command
                            
              LDAA #$B6
              JSR sendByte                       ;set to page 6	

              MOVB savedY,Ycoord                 ;return cursor to previous position                
              JSR setY
              							            
              RTC

;dispTime: display the elapsed time;;;;;;;;;;;;;;;

                                                 ;PAGE_FB
dispTime:     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              CALL clearStack2                   ;clear pages 0 - 6
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              BCLR PTH,#BIT0                     ;A0 = 0, send command	

			        LDAA #$B0                          ;page 0  
              JSR sendByte                       ;set the page
              
              ;JSR clearPage                      ;clear page 0
			        
			        JSR setY                           ;Y = 0
			        			        
			        LDX #TCNTstart
			        MOVB #$42,colNumber                ;colNumber = 66
			        JSR sendData                       ;display "TCNT start:"
			        
			        MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDD tcntRegStart             
              PSHD                               ;push the timer start count onto the stack 
              
              MOVB #$02,counter1                                                     
              
dispTime_1:   LDAA 0,SP                          ;display the timer start count ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispTime_1                     ;<-
              
              ;MOVB #$06,counter1
			        ;JSR clearStack                     ;clear pages 1 - 6
              
              BCLR PTH,#BIT0                     ;A0 = 0,send command              
              
              LDAA #$B7                          ;set to page 7
              JSR sendByte              
              
              JSR clearPage                      ;clear page 7
              
              BCLR PTH,#BIT0                     ;A0 = 0, send command
              
              LDAA #$B1
              JSR sendByte                       ;set to page 1
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #TCNTend
			        MOVB #$36,colNumber                ;colNumber = 54
			        JSR sendData                       ;display "TCNT end:"
			        
			        MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
			        LDD tcntRegEnd             
              PSHD                               ;push the timer end count onto the stack
			        
			        MOVB #$02,counter1   
			        
dispTime_2:   LDAA 0,SP                          ;display the timer end count ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispTime_2                      ;<-
              
              BCLR PTH,#BIT0                     ;A0 = 0, send command
              
              LDAA #$B2
              JSR sendByte                       ;set to page 2
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Ovrflw
			        MOVB #$36,colNumber                ;colNumber = 54
			        JSR sendData                       ;display "Overflow:"
			        
			        MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
			        LDD tcntOvrflw            
              PSHD                               ;push the timer overflow value onto the stack
              
			        MOVB #$02,counter1   
			        
dispTime_3:   LDAA 0,SP                          ;display the timer end count ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispTime_3                      ;<-
			        
			        BCLR PTH,#BIT0                     ;A0 = 0, send command
              
              LDAA #$B3
              JSR sendByte                       ;set to page 3
              
              CLR Ycoord
              JSR setY                           ;Y = 0
              
              LDX #Ovrflw2
			        MOVB #$42,colNumber                ;colNumber = 66
			        JSR sendData                       ;display "Overflow 2:"
			        
			        MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
			        LDD tcntOvrflw2            
              PSHD                               ;push the timer overflow 2 value onto the stack
              
			        MOVB #$02,counter1   
			        
dispTime_4:   LDAA 0,SP                          ;display the timer end count ->              
              ASRA
              ASRA
              ASRA
              ASRA              
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the MS nibble
              JSR sendData                    
              
              PULA
              ANDA #$0F
              
              LDAB #wFontSL
              MUL              
              LDX #DigitSL
              ABX                                ;add B to X               
              MOVB #wFontSL,colNumber            ;display the LS nibble
              JSR sendData        
              
              DEC counter1
              BNE dispTime_4                      ;<-
			        
              RTS

;dispZero: display "0" at the current position and then set the cursor one digit to the left

dispZero:     LDX #Digit                         ;PAGE_FB
              MOVB #wFont,colNumber
              JSR sendData                       ;display 0
              
              JSR backY                          ;move Y one digit to the left    
                      
              RTS

;dispZeroSL: display "0" in SL font at the current position and then set the cursor one digit to the left

dispZeroSL:   LDX #DigitSL                       ;PAGE_FB
              MOVB #wFontSL,colNumber
              JSR sendData                       ;display 0
              
              JSR backYSL                        ;move Y one digit to the left    
                      
              RTS
              
;dispZero2: display "0000 0000 0000 0000" in SL font 

dispZero2:    MOVB #$0E,Ycoord                   ;PAGE_FB
						  MOVB Ycoord,savedY
						  JSR setY                           ;Y = 14        
              
              MOVB #$03,counter1
              
dispZero2_0:  MOVB #$04,counter2
              
dispZero2_1:  LDX #DigitSL                       ;display 0 four times ->
              MOVB #wFontSL,colNumber
              JSR sendData                       
              
              DEC counter2
              BNE dispZero2_1                    ;<-
              
              LDX #Space                          
              MOVB #wFontSL,colNumber
              JSR sendData                       ;insert a space
              
              DEC counter1
              BNE dispZero2_0                    ;repeat three times                   
              
              MOVB #$04,counter2
              
dispZero2_2:  LDX #DigitSL                       ;display 0 four times ->
              MOVB #wFontSL,colNumber
              JSR sendData                       
              
              DEC counter2
              BNE dispZero2_2                    ;<-  
                      
              RTS              

;moveCursor: move cursor to correct position when displaying sign of exponent in command line

                                                 ;PAGE_FB
moveCursor:   MOVB Ycoord,savedY                 ;save current value of Ycoord
              
              LDAA noDigExp                      ;A = length of exponent entered + 1
              INCA
              LDAB #wFont                                                  
              MUL                                ;B = number of columns to move to the left
              
              PSHB
              LDAA Ycoord
              SUBA 0,SP
              INS
              STAA Ycoord                        ;Ycoord - (noDigExp+1) * wFont -> Ycoord 
              JSR setY
              
              RTC

;PORTinit: all ports are set to output mode, except Port P
                                                 
PORTinit:     LDAA #$FF                          ;PAGE_FB                
            
              STAA DDR0AD0                       ;set direction registers for all ports to ouput -> 
              STAA DDR1AD0              
            
              STAA DDR0AD1              
              STAA DDR1AD1              
            
              STAA DDRA                 
              STAA DDRB                 
              STAA DDRC                 
              STAA DDRD                 
              STAA DDRE
              STAA DDRF
              STAA DDRH            
              STAA DDRJ                 
              STAA DDRK
              STAA DDRL
              STAA DDRM                 
              STAA DDRR
              STAA DDRS                 
              STAA DDRT                          ;<-
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FCS2: set Port P to output for Full Chip Simulation
              
              ;STAA DDRP              
                                                 ;AD 1: set Port P to input for actual device              
              STAA PERP                          ;pull-up resistors enabled on Port P
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              RTC 
            
;scanKey2: scans the keypad to determine which key has been pressed

scanKey2:     MOVB #$02,counter1                 ;PAGE_FB

scanKey2_1:   JSR delay                          ;timer delay to debounce the key
              DEC counter1
              BNE scanKey2_1
              
              CLR keyNumber
              
              BSET PT1AD0,#BIT1                  ;PT1AD0.0 = 0 -> row A scanned
              BSET PT1AD0,#BIT2
              BSET PT1AD0,#BIT3
              BSET PT1AD0,#BIT4
              BSET PT1AD0,#BIT5
              BSET PT1AD0,#BIT6 
              BSET PT1AD0,#BIT7 
                    
              JSR scanCol                        ;scan all columns of row A
                                          
              BRSET flag1,#BIT1,scanKey2_2       ;branch if keyFound set, 
                                                 ;i.e. if pressed key has been found
                                                  
              BSET PT1AD0,#BIT0                  ;PT1AD0.1 = 0 -> row B scanned
              BCLR PT1AD0,#BIT1  

              JSR scanCol                        

              BRSET flag1,#BIT1,scanKey2_2

              BSET PT1AD0,#BIT1                  ;PT1AD0.2 = 0 -> row C scanned
              BCLR PT1AD0,#BIT2

              JSR scanCol                       

              BRSET flag1,#BIT1,scanKey2_2
              
              BSET PT1AD0,#BIT2                  ;PT1AD0.3 = 0 -> row D scanned
              BCLR PT1AD0,#BIT3               

              JSR scanCol                
              
              BRSET flag1,#BIT1,scanKey2_2
			  
			        BSET PT1AD0,#BIT3                  ;PT1AD0.4 = 0 -> row E scanned
              BCLR PT1AD0,#BIT4               

              JSR scanCol                
              
              BRSET flag1,#BIT1,scanKey2_2 
              
              BSET PT1AD0,#BIT4                  ;PT1AD0.5 = 0 -> row F scanned
              BCLR PT1AD0,#BIT5               

              JSR scanCol
              
              BRSET flag1,#BIT1,scanKey2_2
              
              BSET PT1AD0,#BIT5                  ;PT1AD0.6 = 0 -> row G scanned
              BCLR PT1AD0,#BIT6
              
              JSR scanCol
              
              BRSET flag1,#BIT1,scanKey2_2
              
              BSET PT1AD0,#BIT6                  ;PT1AD0.7 = 0 -> row H scanned
              BCLR PT1AD0,#BIT7    
              
              JSR scanCol             
             
scanKey2_2:   RTC
              
;setDenomStk: sets the numerators and denominators when selecting exact mode

setDenomStk:  LDD usPointer                      ;PAGE_FB
              CPD #ms_end
              LBEQ setDenomStk_exit              ;exit if the user stack is empty
              
setDenomStk_1:PSHD                               ;push usPointer onto the stack
              
              ADDD #$13B5                        
              
              TFR D,X                            ;X points to FPN_1_denominator

              CLRA
              MOVB #lenManBBytes,counter1
              
setDenomStk_2:STAA 1,X+                          ;set mantissa of FPN_1_denominator to 1 ->
              DEC counter1
              BNE setDenomStk_2
              
              MOVB #$01,0,X                      ;<-
              
              PULD
              PSHD              
              
              STD memAddr1
                            
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BNE setDenomStk_7                  ;continue if FPN_1_numerator <> 0
              
              PULD
              PSHD

              ADDD #$13BD                                                 
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              MOVB #$00,0,X                      ;set exponent of FPN_1_denominator to 0
              
              LBRA setDenomStk_6

setDenomStk_7:MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1_numerator
              
              MOVW #m_a,memAddr1 
              
              JSR tzFPN                          ;eliminate any trailing zeros in FPN_M1 = FPN_a = FPN_1_numerator
              
              PULD
              PSHD
              
              STD memAddr2
              JSR copyFPN                        ;copy FPN_a to FPN_1_numerator
              
              PULD
              PSHD              

              ADDD #lenManBytes                  
              TFR D,X                            ;X points to exponent of FPN_1_numerator
              
              LDAA 0,X                           ;A = exponent of FPN_1_numerator
              BPL setDenomStk_3                  ;if exponent of FPN_1_numerator >= 0 set exponent of 
                                                 ;FPN_1_denominator to 0
              
              CLR 0,X                            ;otherwise set exponent of FPN_1_numerator to 0 and exponent of 
                                                 ;FPN_1_denominator to NEGA
              NEGA              
              PSHA
              
              INS
              
              PULD
              PSHD
              
              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              DES
              
              PULA
              
              STAA 0,X                           ;set exponent of FPN_1_denominator to NEGA
              
              PULD
              PSHD
              
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1_numerator copied to m_b
              
              MOVW #m_b,memAddr1              
              JSR absFPN                         ;set m_b to absolute value if required 
              
              PULD
              PSHD
              
              ADDD #$13B5
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to m_a              
              
              BRA setDenomStk_4   
              
setDenomStk_3:MOVW #m_a,memAddr1              
              JSR absFPN                         ;set m_a to absolute value if required

              PULD
              PSHD

              ADDD #$13BD                        
              
              TFR D,X                            ;X points to the exponent of FPN_1_denominator
              
              MOVB #$00,0,X                      ;set exponent of FPN_1_denominator to 0
              
              SUBD #$0008                        ;D points to FPN_1_denominator
              
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to m_b                      
              
setDenomStk_4:

              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              ;exit if e_a too big ->
              
              MOVB e_b,power                     ;result will be multiplied by 10^power
              
              LDAA e_a                           ;divide FPN_a,b by 10^power
              SUBA e_b
              STAA e_a
              
              CLR e_b
              
              MOVW #m_a,memAddr1
              
              JSR lzMan   
              
              LDAA noZero
              SUBA e_a
              DECA
              
              BPL setDenomStk_5
              
              BRA setDenomStk_6                  ;otherwise don't reduce fraction to simplest form as FPN_a is too
                                                 ;big to find GCD
              ;<-

setDenomStk_5:JSR GCDFPN_ab                      ;determine GCD of numerator and denominator and store BCD result
                                                 ;in FPN_a
              
              MOVW #m_a,memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;GCD copied to FPN_b
              
              PULD
              PSHD
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_numerator copied to FPN_a
              
              JSR divFPN                         ;FPN_1_numerator/GCD -> FPN_a
              
              BRCLR flag2,#BIT4,setDenomStk_8    ;branch if result should be positive
              
              JSR negFPN                         ;otherwise negate m_a first
              
setDenomStk_8:PULD
              PSHD
              
              STD memAddr2
              MOVW #m_a,memAddr1
              JSR copyFPN                        ;FPN_a = simplified numerator copied to FPN_1_numerator
              
              PULD
              PSHD
              
              ADDD #$13B5
              
              STD memAddr1
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_1_denominator copied to FPN_a
              
              JSR divFPN                         ;FPN_1_denominator/GCD -> FPN_a
              
              PULD
              PSHD
              
              ADDD #$13B5
              
              STD memAddr2
              MOVW #m_a,memAddr1
              JSR copyFPN                        ;FPN_a = simplified denominator copied to FPN_1_denominator
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
setDenomStk_6:PULD
              ADDD #lenFPNBytes
              CPD #ms_end
              BEQ setDenomStk_exit               ;exit if the user stack is empty
              
              LBRA setDenomStk_1
              
setDenomStk_exit:
              RTC

;setToDec: sets flags to DEC mode when entering EQN,STAT,PROB,POLY,OPRE,NUMB,MATR,FUNC,FINA,CALC and GRPH folders

setToDec:                                        ;PAGE_FB
              BCLR flag3,#BIT2                   ;clear hex flag
              BCLR flag4,#BIT2                   ;clear exact flag
              BCLR flag4,#BIT0                   ;clear bin flag              
              BCLR flag4,#BIT1                   ;clear the cpx flag               
              BCLR flag3,#BIT3                   ;clear hex/bin flag
              BCLR flag5,#BIT7                   ;clear 2-adic flag
              BCLR flag1,#BIT3                   ;clear sci flag
              
              RTC

;setUserStk: sets the user stack to decimal when selecting approximate mode

setUserStk:   LDD usPointer                      ;PAGE_FB
              CPD #ms_end
              BEQ setUserStk_exit                ;exit if the user stack is empty
              
setUserStk_1: PSHD 

              STD memAddr1
              
              JSR lzMan
              LDAA noZero
              CMPA #lenMan
              BEQ setUserStk_3                   ;branch if the dividend is zero
              
              MOVW #m_a,memAddr2
              JSR copyFPN                        ;FPN_a = FPN_1_numerator
              
              PULD
              PSHD
              
              ADDD #$13B5
              
              STD memAddr1
              MOVW #m_b,memAddr2
              JSR copyFPN                        ;FPN_b = FPN_1_denominator
 
              JSR divFPN                         ;divide FPN_a by FPN_b and store the result in FPN_a
              
              BRCLR flag2,#BIT4,setUserStk_2     ;branch if quotient should be positive 
              JSR negFPN                         ;otherwise negate it first               

setUserStk_2: PULD
              PSHD
              
              MOVW #m_a,memAddr1
              STD memAddr2
              JSR copyFPN                        ;FPN_1 converted to decimal
              
setUserStk_3: PULD
              ADDD #lenFPNBytes
              CPD #ms_end
              BEQ setUserStk_exit                ;exit if the user stack is empty
              
              BRA setUserStk_1
              
setUserStk_exit:
              RTC

;SPIinit: initialise SPI1 to send commands/data to the ST7565 GLCD    
                                                 ;PAGE_FB
SPIinit:      MOVB #$20,MODRR                    ;re-route SPI1 to Port H[3:0]      

              MOVB #$02,SPI1BR                   ;divide by 8 to determine SPI1 clock rate            
              
              MOVB #$50,SPI1CR1                  ;SPI1 enabled, master mode, CPOL = 0, CPHA = 0
                                                 
              MOVB #$09,SPI1CR2	                 ;output buffer enabled, SPC1 set to enable bidirectional operation 
                                                 ;so that PH0 can be used for A0                                                 
              RTC

;SVA: enters the special values for the CORDIC tan user program in x0 -> x13

                                                 ;PAGE_FB
SVA:          LDX #x0                            ;x0 = arctan(1) ->
              
              MOVB #$00,1,X+
              MOVB #$07,1,X+
              MOVB #$85,1,X+
              MOVB #$39,1,X+
              MOVB #$81,1,X+
              MOVB #$63,1,X+
              MOVB #$39,1,X+
              MOVB #$74,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x1 = arctan(.1) ->
              MOVB #$00,1,X+
              MOVB #$99,1,X+
              MOVB #$66,1,X+
              MOVB #$86,1,X+
              MOVB #$52,1,X+
              MOVB #$49,1,X+
              MOVB #$12,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x2 = arctan(.01) ->
              MOVB #$00,1,X+
              MOVB #$09,1,X+
              MOVB #$99,1,X+
              MOVB #$96,1,X+
              MOVB #$66,1,X+
              MOVB #$68,1,X+
              MOVB #$67,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x3 = arctan(.001) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$99,1,X+
              MOVB #$99,1,X+
              MOVB #$99,1,X+
              MOVB #$66,1,X+
              MOVB #$67,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x4 = arctan(.0001) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$09,1,X+
              MOVB #$99,1,X+
              MOVB #$99,1,X+
              MOVB #$99,1,X+
              MOVB #$97,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x5 = arctan(.00001) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$01,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x6 = arctan(.000001) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$10,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x7 = arctan(.0000001 = 10^-7) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$01,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x8 = arctan(10^-8) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$10,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x9 = arctan(10^-9) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$01,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x10 = arctan(10^-10) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$10,1,X+
              MOVB #$00,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x11 = arctan(10^-11) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$01,1,X+
              MOVB #$00,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x12 = arctan(10^-12) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$10,1,X+
              
              MOVB #$F3,1,X+                     ;<-
              
              MOVB #$00,1,X+                     ;x13 = arctan(10^-13) ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$01,1,X+
              
              MOVB #$F3,0,X                      ;<-
              
              RTC

;updatePrgStack: displays the program stack;;;;;;;

updatePrgStack:                                  ;PAGE_FB
              CALL clearStack2                   ;clear pages 0 - 6
              
              MOVB #$07,counter2                 ;subroutine disLbl2 called in dispPrgIstr uses counter1
              
              MOVB #$B0,pageNumber               ;start at page 0
              
              LDD prgCounter
              SUBD #ps_start                     ;D = prgCounter - ps_start
              
              LDX #$0007
  
              IDIV                               ;D / 7 -> X, remainder -> D
                                                 ;i.e. if D = q * 7 + r, q -> X, r -> D  
              EXG X,Y                            ;q -> Y
              
              LDD #$0007
              EMUL                               ;q * 7 -> Y:D
              
              ADDD #ps_start                     ;D = address of first program instruction to be displayed              
              
updatePrgStack_1:
              PSHD
              
              BCLR PTH,#BIT0                     ;A0 = 0,send command
              LDAA pageNumber
						  JSR sendByte                       ;set the page
						  
						  PULD
						  
						  CALL dispPrgIstr                   ;display the program line number, code and instruction
						  
						  ADDD #$0001                        ;D now points to the next program instruction
						  
						  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						  
						  CPD #$319E
						  BEQ updatePrgStack_2               ;exit if at the end of the program stack
						  
						  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;						                              
              
              INC pageNumber                     
              
              DEC counter2
              BNE updatePrgStack_1               ;display 7 program instructions         

updatePrgStack_2:
              RTC

;updateStack: displays the user stack;;;;;;;;;;;;; 
                                                 ;PAGE_FB
updateStack:  CALL dispStack                     ;clear pages 1 - 5 and display the stack labels. 
                                                 ;A = 5 * stack screen number                                                   
              PSHA

              LDD usPointer
              CPD #ms_end
              BEQ updateStack_8                  ;exit if the user stack is empty

              PULA

              LDAB #lenFPNBytes
              MUL                                ;A = 0, B = 5 * stack screen number * lenFPNBytes
                                                                            
              ADDD usPointer                     ;D = usPointer + 5 * stack screen number * lenFPNBytes
              
              MOVB #$05,counter4
              
              MOVB #$B5,pageNumber               ;start at page 5
              
              BCLR PTH,#BIT0                     ;A0 = 0,send command 
              
              STD memAddr1                       ;memAddr1 = usPointer + 5 * stack screen number * lenFPNBytes, i.e.
                                                 ;the address of the first FPN to be displayed              
updateStack_1:LDAA pageNumber
						  JSR sendByte                       ;set the page
						  
						  BRSET flag4,#BIT2,updateStack_10   ;branch if in exact mode
						  
						  BRSET flag4,#BIT1,updateStack_9    ;branch if in cpx mode
						  
						  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;						  

              MOVW #m_a,memAddr2
              
              JSR copyFPN                        ;FPN_M1 copied to FPN_a
						  
						  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
						  
						  BRCLR flag3,#BIT3,updateStack_2    ;branch if not in Hex/Bin mode
						 
						  JSR dispHex                        ;otherwise display FPN_a in hexadecimal/binary
						  
						  BRA updateStack_3
						  
updateStack_9:JSR dispCpx                        ;display FPN_1 as a complex number             

              BRA updateStack_3
              
updateStack_10:
              JSR dispExact                      ;display FPN_1 as a rational number
              
              BRA updateStack_3
						  
updateStack_2:JSR dispNum                        ;display FPN_a in decimal 
              
updateStack_3:ADDD #lenFPNBytes                  ;D = memAddr1 + 9
              STD memAddr1                       ;point to the next value on the user stack 
              CPD #ms_end
              BEQ updateStack_4                  ;exit if the bottom of the user stack has been reached
              DEC pageNumber
              
              DEC counter4
              BNE updateStack_1                       
              
updateStack_4:
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              
              CALL dispStackTWO                  ;display stack labels 1 - 5 in case they were overwritten
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
         
              RTC

updateStack_8:PULA

              RTC

;VARinit: initialise variables;;;;;;;;;;;;;;;;;;;;

VARinit:      CLRA                               ;PAGE_FB
              CLRB

              STAA flag1
              STAA flag5
              STAA flag3              
              STAA menu                          ;user menu 0 is the default menu             
              STAA screenNumber
					    
					    STD tcntOvrflw    
              STD tcntOvrflw2   
              STD tcntRegStart  
              STD tcntRegEnd
              
              MOVB #$80,flag4                    ;set updtScreen flag so that the stack and command line are displayed
                                                 ;correctly when menu pressed immediately after calculator turned on              
              MOVB #$EA,counter1
              LDX #ms_end                        ;X points to the end of the memory stack
              
VARinit_1:    STAA 1,X+                          ;set all bytes of memory stack to 0
              DEC counter1
              BNE VARinit_1
              
              MOVB #$B4,counter1
              LDX #im_end                        ;X points to the end of the imaginary number stack
              
VARinit_7:    STAA 1,X+                          ;set all bytes of imaginary number stack to 0
              DEC counter1
              BNE VARinit_7  
              
              MOVB #$FC,counter1
              LDX #x0                            ;X points to the start of the general storage stack
              
VARinit_2:    STAA 1,X+                          ;set x0 - x27 to 0
              DEC counter1
              BNE VARinit_2
              
              MOVB #$12,counter1
              
VARinit_3:    STAA 1,X+                          ;set x28 - x29 to 0
              DEC counter1
              BNE VARinit_3
                            
              MOVB #$10,counter2
              
              LDAA #noOperation
              LDX #ps_start                      ;X points to the start of the program stack
              
VARinit_4:    MOVB #$FF,counter1
              
VARinit_5:    STAA 1,X+                          ;set ps_start - ps_start + $FE to NOP, 
                                                 ;ps_start + $FF - ps_start + $FF + $FE to NOP...
                                                 ;ps_start + 15 * $FF - ps_start + 15 * $FF + $FE to NOP 
              DEC counter1
              BNE VARinit_5
              
              DEC counter2
              BNE VARinit_4
              
              MOVB #$10,counter1
              
VARinit_6:    STAA 1,X+                          ;set ps_start + 16 * $FF - ps_start + 16 * $FF + F = ps_end to 
                                                 ;NOP                                                 
              DEC counter1
              BNE VARinit_6
              
              LDAA #endPrg
              STAA 0,X                           ;stopgap initialised with endPrg to terminate program execution
              
              LDX #rnSeed                        ;X points to the start of the random number seed
              
              MOVB #$01,1,X+
              MOVB #$39,1,X+
              MOVB #$40,1,X+
              MOVB #$8D,1,X+
              MOVB #$CB,1,X+
              MOVB #$BF,1,X+
              MOVB #$7A,1,X+
              MOVB #$44,1,X+
              
              LDX #ds_end                        ;X points to the end of the denominator stack              
              MOVB #$14,counter1
              
VARinit_8:    MOVB #$00,1,X+                     ;set denominator to 1 ->
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$00,1,X+
              MOVB #$01,1,X+
              MOVB #$00,1,X+
              
              DEC counter1
              BNE VARinit_8                      ;<-
					    
					    MOVW #ms_end,usPointer             ;user stack is empty
					   					    
					    MOVB #lenExpBytes,lenMemBytes      ;lenMemBytes = lenExpBytes when updating the value of the exponent
					    
					    RTC
					    
;******************Key functions******************

;Key 22: Shift;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                                                 ;PAGE_FB
key22SUB:     BCLR flag4,#BIT7                   ;clear updtScreen flag              
						  
						  MOVB #$1E,colNumber
						  						  
						  ;MOVB #$12,counter1                 ;determines how long the key must be held (future implementation
						                                      ;for shift 2 plane)
						  
						  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;set PTP.1 = 1 to simulate Key 22 has been released
						  ;MOVB #$02,PTP
						  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
              
;key1_1:       BRSET PTP,#BIT1,key1_2             ;branch if PTP.1 = 1, i.e. if Key 22 has been released (Port P at
                                                 ;address 0x0258)
              ;JSR delay
              ;DEC counter1
              ;BNE key1_1
              
              ;BSET flag4,#BIT3                   ;Key 22 was held so set shift 2 flag 
              ;LDX #Alpha
              ;BRA key1_3   

key1_2:       BSET flag1,#BIT0                   ;Key 22 was not held so set shift flag 
              LDX #Shift
      
key1_3:       CALL dispStatLI                    ;update the annunciator 

              RTC
             
;key129: Degree/Radian angle measure toggle key;;;

                                                 ;PAGE_FB
key129SUB:    BRSET flag4,#BIT4,key129SUB_1      ;branch if in radian mode

              BRSET flag1,#BIT6,key129SUB_2      ;branch if in gradian mode

              BSET flag4,#BIT4                   ;otherwise in degress mode so set rad flag and exit
              BRA key129SUB_exit

key129SUB_1:  BCLR flag4,#BIT4                   ;clear rad flag 
              BSET flag1,#BIT6                   ;set grad flag
              
key129SUB_2:  BCLR flag1,#BIT6                   ;clear grad flag   

key129SUB_exit:
              RTC
              
;key132: Toggle approximate/exact modes;;;;;;;;;;;

                                                 ;PAGE_FB
key132SUB:    BRCLR flag4,#BIT2,key132_1         ;branch if in approximate mode 

              BCLR flag4,#BIT2                   ;otherwise set approximate mode
              
              BCLR flag3,#BIT3                   ;clear hex/bin flag               
              BCLR flag3,#BIT2                   ;clear hex flag              
              BCLR flag4,#BIT0                   ;clear bin flag              
              BCLR flag4,#BIT1                   ;clear cpx flag
              BCLR flag5,#BIT7                   ;clear 2-adic flag
              
              CALL setUserStk                    ;set the user stack to decimal 
              
              BRA key132_2
              
key132_1:     BSET flag4,#BIT2                   ;set exact mode

              BCLR flag4,#BIT1                   ;clear cpx flag
              BCLR flag4,#BIT0                   ;clear bin flag
              BCLR flag3,#BIT2                   ;clear hex flag
              BCLR flag3,#BIT3                   ;clear hex/bin flag
              BCLR flag1,#BIT3                   ;clear sci flag 

              CALL setDenomStk                   ;set the numerators and denominators 

key132_2:     RTC

;key135: display the user stack level memory contents/return to user stack display

                                                 ;PAGE_FB
key135SUB:    BRSET flag1,#BIT4,key57_1          ;exit memory display if the MEM flag set

              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              
              JSR calcDpt                        ;calculate the user stack depth and store it in A
              TSTA
              BEQ key57_2                        ;exit if the user stack depth = 0               
            
              BSET flag1,#BIT7                   ;set the curOff flag to turn off the cursor
              
              BRSET flag4,#BIT2,key57_3          ;branch if in exact mode
              
              BRSET flag4,#BIT1,key57_5          ;branch if in complex number mode
              
              JSR dispMem                        ;display user stack level memory
              BRA key57_4
              
key57_3:      JSR dispMemRat
              BRA key57_4

key57_5:      JSR dispMemCpx                
              
key57_4:      BSET flag1,#BIT4                   ;set the MEM flag
              BRA key57_2                        ;exit                     
              
key57_1:      BCLR flag1,#BIT7                   ;clear the curOff flag to turn on the cursor
              
              JSR clrComLMem                     ;clear command line memory
              
              BCLR flag1,#BIT4                   ;clear the MEM flag  
              
key57_2:      RTC

;key136: display the elapsed time/return to user stack display

                                                 ;PAGE_FB
key136SUB:    BRSET flag4,#BIT5,key58_1          ;exit elapsed time display if the time flag is set 
              
              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              
              BSET flag1,#BIT7                   ;set the curOff flag to turn off the cursor
              JSR dispTime                       ;display the elapsed time 
              
              BSET flag4,#BIT5                   ;set the time flag
              BRA key58_3                        ;exit                     
              
key58_1:      BCLR flag1,#BIT7                   ;clear the curOff flag to turn on the cursor
              
              JSR clrComLMem                     ;clear command line memory
              
              BCLR flag4,#BIT5                   ;clear the time flag              
              
key58_3:      RTC

;key139: Enter program edit mode;;;;;;;;;;;;;;;;;;

                                                 ;PAGE_FB
key139SUB:    BSET flag3,#BIT6                   ;set the prg flag
              BSET flag4,#BIT6                   ;set the updtPrgScreen flag
              BSET flag5,#BIT3                   ;set incPrgCtr flag
              BSET flag1,#BIT7                   ;set the curOff flag to turn off the cursor
               
              CALL dcplProg                      ;convert offsets to keystroke numbers
              
              MOVW #ms_start_LS,prgCounterSt     ;used to determine program step number in subroutine dispPrgIstr
              
              JSR clrComLMem                     ;clear command line memory              
                            
              CLR menu                           ;select program menu 0
              
              MOVW #ms_start_LS,prgCounter       ;prgCounter initialised
              
              RTC
              
;key142: display the about page/return to user stack display

                                                 ;PAGE_FB
key142SUB:    BRSET flag5,#BIT6,key142SUB_1      ;exit about page if the ABT flag set

              BCLR flag4,#BIT7                   ;clear updtScreen flag 
              
              BSET flag1,#BIT7                   ;set the curOff flag to turn off the cursor
              JSR dispAbtPge                     ;display the about page 
              
              BSET flag5,#BIT6                   ;set the ABT flag
              BRA key142SUB_exit                 ;exit                     
              
key142SUB_1:  BCLR flag1,#BIT7                   ;clear the curOff flag to turn on the cursor
              
              JSR clrComLMem                     ;clear command line memory
              
              BCLR flag5,#BIT6                   ;clear the ABT flag  
              
key142SUB_exit:     
              RTC

;key185: HALT program instruction;;;;;;;;;;;;;;;;;

                                                 ;PAGE_FB
key185SUB:    BCLR flag1,#BIT1                   ;clear the keyFound flag       

              CALL dispStatL                     ;display the status line
              
              LDX #Halt                          
              MOVB #$18,colNumber
              CALL dispStatLI                    ;display "Halt" on the status line             

              CALL updateStack                   ;display the stack
              
              BCLR PT1AD0,#BIT0                  ;clear all keypad rows
              BCLR PT1AD0,#BIT1
              BCLR PT1AD0,#BIT2
              BCLR PT1AD0,#BIT3
              BCLR PT1AD0,#BIT4
              BCLR PT1AD0,#BIT5
              BCLR PT1AD0,#BIT6
              BCLR PT1AD0,#BIT7
                            
key185_1:     LDAA PTP
              COMA                            
              BEQ key185_1                       ;loop until key pressed
              
              CALL scanKey2                      ;set keyFound flag, scan the keypad and record number 
                                                              
              MOVB keyNumber,keyNumber2          ;copy keyNumber to keyNumber2 to assist debugging KEYNO-> instruction                                              
              
key185_2:     BCLR PT1AD0,#BIT0                  ;clear all keypad rows
              BCLR PT1AD0,#BIT1
              BCLR PT1AD0,#BIT2
              BCLR PT1AD0,#BIT3
              BCLR PT1AD0,#BIT4
              BCLR PT1AD0,#BIT5
              BCLR PT1AD0,#BIT6
              BCLR PT1AD0,#BIT7

              LDAA PTP
              COMA
              BNE key185_2                       ;loop until pressed key is released
              
              LDX #clrShift              
              MOVB #$18,colNumber              
              CALL dispStatLI                    ;clear "Halt" annunciator        

              RTC              

;**Table used in cplProg and dcplProg subroutines**

                                                              ;PAGE_FB
DigitVal      DC.B $00, $00, $00, $00, $00, $00, $00, $03
              DC.B $02, $01, $00, $00, $00, $06, $05, $04
              DC.B $00, $00, $00, $09, $08, $07
              
DigitValInv   DC.B $03, $09, $08, $07, $0F, $0E, $0D, $15
              DC.B $14, $13

;**User mode stack and status line display table**
                                                              ;PAGE_FB
                                                              
AriCal        DC.B $00, $00, $00, $00, $00, $00, $00, $00	    ;
              DC.B $00, $00, $00, $00, $00, $00, $00, $00	    ;  
              DC.B $00, $00, $00, $00, $00, $00, $00, $00	    ;
              DC.B $00, $00, $00, $00, $00, $00, $00, $00	    ;
              DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A
              DC.B $1C, $3E, $63, $41, $41, $63, $22, $00     ;C
              DC.B $00, $00, $08, $08, $08, $08, $00, $00	    ;-
              DC.B $00, $00, $41, $7F, $7F, $41, $00, $00	    ;I
              DC.B $00, $00, $41, $7F, $7F, $41, $00, $00	    ;I
              DC.B $00, $00, $00, $00, $00, $00, $00, $00	    ;
              DC.B $00, $00, $00, $00, $00, $00, $00, $00	    ;
              DC.B $00, $00, $00, $00, $00, $00, $00, $00	    ;
              DC.B $00, $00, $00, $00, $00, $00, $00, $00	    ;              
              
Line1         DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $00, $44, $7D, $40, $00               ;i 
              DC.B $00, $18, $A4, $A4, $A4, $7C               ;g
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $38, $44, $44, $44, $20               ;c
              DC.B $00, $38, $44, $44, $44, $38               ;o 
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $38, $44, $44, $44, $20               ;c
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $FC, $24, $24, $24, $18               ;p
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $38, $44, $44, $48, $7F               ;d

Line2         DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $18, $A4, $A4, $A4, $7C               ;g
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $18, $A4, $A4, $A4, $7C               ;g
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $7F, $48, $44, $44, $38               ;b
              DC.B $00, $1C, $A0, $A0, $A0, $7C               ;y
              DC.B $00, $00, $36, $36, $00, $00               ;:              

Line3         DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $7F, $10, $28, $44, $00               ;k
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $7F, $08, $08, $08, $7F               ;H
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $48, $54, $54, $54, $20               ;s
              DC.B $00, $48, $54, $54, $54, $20               ;s
              DC.B $00, $3C, $40, $30, $40, $3C               ;w
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $08, $7E, $09, $01, $02               ;f

Line4         DC.B $00, $7F, $09, $09, $09, $01               ;F
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $7C, $04, $18, $04, $78               ;m
              DC.B $00, $3C, $40, $30, $40, $3C               ;w
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $7F, $48, $44, $44, $38               ;b
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $42, $7F, $40, $00               ;1
              DC.B $00, $00, $60, $60, $00, $00               ;.
              DC.B $00, $3E, $51, $49, $45, $3E               ;0
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $7F, $48, $44, $44, $38               ;b
              DC.B $00, $1C, $A0, $A0, $A0, $7C               ;y
              DC.B $00, $00, $36, $36, $00, $00               ;:

Line5         DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $3C, $40, $40, $20, $7C               ;u
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $1C, $20, $40, $20, $1C               ;v
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $38, $44, $44, $44, $20               ;c

Line6         DC.B $00, $7F, $08, $04, $04, $78               ;h
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $FC, $24, $24, $24, $18               ;p
              DC.B $00, $00, $36, $36, $00, $00               ;:
              DC.B $00, $20, $10, $08, $04, $02               ;/
              DC.B $00, $20, $10, $08, $04, $02               ;/
              DC.B $00, $7F, $08, $04, $04, $78               ;h
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $3C, $40, $30, $40, $3C               ;w
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $08, $7E, $09, $01, $02               ;f
              DC.B $00, $00, $60, $60, $00, $00               ;.
              DC.B $00, $18, $A4, $A4, $A4, $7C               ;g
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $7F, $08, $04, $04, $78               ;h
              DC.B $00, $3C, $40, $40, $20, $7C               ;u
              DC.B $00, $7F, $48, $44, $44, $38               ;b

Line7         DC.B $00, $00, $60, $60, $00, $00               ;.
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $20, $10, $08, $04, $02               ;/
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $38, $44, $44, $44, $20               ;c
              DC.B $00, $3C, $40, $40, $20, $7C               ;u
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              
                                                              ;PAGE_FB
Addr          DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $38, $44, $44, $48, $7F               ;d
              DC.B $00, $38, $44, $44, $48, $7F               ;d
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $48, $54, $54, $54, $20               ;s
              DC.B $00, $48, $54, $54, $54, $20               ;s
              DC.B $00, $00, $36, $36, $00, $00               ;:
              
Arrow         DC.B $18, $18, $18, $5A, $3C, $18               ;->

Bini          DC.B $00, $7F, $49, $49, $49, $36               ;B
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $00, $36, $36, $00, $00               ;:

clrShift      DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;

Cpxi          DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $FC, $24, $24, $24, $18               ;p
              DC.B $00, $44, $28, $10, $28, $44               ;x
              DC.B $00, $00, $36, $36, $00, $00               ;:

DArrow        DC.B $20, $40, $FF, $02, $04, $00               ;<|>

Deci          DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $38, $44, $44, $44, $20               ;c
              DC.B $00, $00, $36, $36, $00, $00               ;:

Deg           DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $18, $64, $64, $64, $7C               ;g
                            
Den           DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $7C, $04, $18, $04, $78               ;m
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $24, $24, $24, $24, $24               ;=

Num           DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $3C, $40, $40, $20, $7C               ;u
              DC.B $00, $7C, $04, $18, $04, $78               ;m
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $24, $24, $24, $24, $24               ;=

Doll          DC.B $00, $24, $2a, $7f, $2a, $12               ;$

                                                              ;PAGE_FB
End           DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $7F, $41, $41, $22, $1C               ;D

Grad          DC.B $00, $3E, $41, $49, $49, $7A               ;G
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $38, $44, $44, $48, $7F               ;d

Halt          DC.B $00, $7F, $08, $08, $08, $7F               ;H
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $04, $3F, $44, $40, $20               ;t

Hexi          DC.B $00, $7F, $08, $08, $08, $7F               ;H
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $44, $28, $10, $28, $44               ;x
              DC.B $00, $00, $36, $36, $00, $00               ;:

Hyp           DC.B $00, $08, $08, $08, $08, $08               ;-

Imz           DC.B $00, $00, $41, $7F, $41, $00               ;I
              DC.B $00, $7C, $04, $18, $04, $78               ;m
              DC.B $00, $00, $1C, $22, $41, $00               ;(
              DC.B $00, $44, $64, $54, $4C, $44               ;z
              DC.B $00, $00, $41, $22, $1C, $00               ;)
              DC.B $00, $24, $24, $24, $24, $24               ;=

Rez           DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $38, $54, $54, $54, $18               ;e
              DC.B $00, $00, $1C, $22, $41, $00               ;(
              DC.B $00, $44, $64, $54, $4C, $44               ;z
              DC.B $00, $00, $41, $22, $1C, $00               ;)
              DC.B $00, $24, $24, $24, $24, $24               ;=

Ovrflw        DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $1C, $20, $40, $20, $1C               ;v
              DC.B $00, $38, $54, $54, $54, $18               ;e 
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $08, $7E, $09, $01, $02               ;f
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $3C, $40, $30, $40, $3C               ;w
              DC.B $00, $00, $36, $36, $00, $00               ;:
              
Ovrflw2       DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $1C, $20, $40, $20, $1C               ;v
              DC.B $00, $38, $54, $54, $54, $18               ;e 
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $08, $7E, $09, $01, $02               ;f
              DC.B $00, $00, $41, $7F, $40, $00               ;l
              DC.B $00, $38, $44, $44, $44, $38               ;o
              DC.B $00, $3C, $40, $30, $40, $3C               ;w
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $42, $61, $51, $49, $46               ;2
              DC.B $00, $00, $36, $36, $00, $00               ;:

Rad           DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $38, $44, $44, $48, $7F               ;d

Sci           DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $38, $44, $44, $44, $20               ;c
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              
TCNTend       DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $38, $54, $54, $54, $18               ;e 
              DC.B $00, $7C, $08, $04, $04, $78               ;n
              DC.B $00, $38, $44, $44, $48, $7F               ;d
              DC.B $00, $00, $36, $36, $00, $00               ;:

TCNTstart     DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $48, $54, $54, $54, $20               ;s
              DC.B $00, $04, $3F, $44, $40, $20               ;t 
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $7C, $08, $04, $04, $08               ;r
              DC.B $00, $04, $3F, $44, $40, $20               ;t
              DC.B $00, $00, $36, $36, $00, $00               ;:
              
TwoAdic       DC.B $00, $42, $61, $51, $49, $46               ;2
              DC.B $00, $08, $08, $08, $08, $08               ;-
              DC.B $00, $20, $54, $54, $54, $78               ;a
              DC.B $00, $38, $44, $44, $48, $7F               ;d
              DC.B $00, $00, $44, $7D, $40, $00               ;i
              DC.B $00, $38, $44, $44, $44, $20               ;c
					    
;*********************PAGE_FA*********************User and program menus and additional calculator functions

              ORG $FA8000
              
;dispMenu: display the selected user menu;;;;;;;;;

dispMenu:     BCLR PTH,#BIT0                     ;A0 = 0,send command 

              LDAA #$B7                          ;set to page 7
              JSR sendByte
              
              CLR Ycoord                   
              JSR setY                           ;Y = 0
              
              CLRA

              LDAB menu
              ASLB                               

              LDX #userMenuTable     

              JMP [D,X]

userMenuTable DC.W dispMenu_0                    ;user menu 0                          
              DC.W dispMenu_1                    ;user menu 1 
              DC.W dispMenu_2                    ;user menu 2 
              DC.W dispMenu_3                    ;user menu 3 
              DC.W dispMenu_4                    ;user menu 4 
              DC.W dispMenu_5                    ;user menu 5
              DC.W dispMenu_6                    ;user menu 6
              DC.W dispMenu_7                    ;user menu 7
              DC.W dispMenu_8                    ;user menu 8 
              DC.W dispMenu_9                    ;user menu 9
              DC.W dispMenu_10                   ;user menu 10
              DC.W dispMenu_11                   ;user menu 11
              DC.W dispMenu_12                   ;user menu 12
              DC.W dispMenu_13                   ;user menu 13
              DC.W dispMenu_14                   ;user menu 14
              DC.W dispMenu_15                   ;user menu 15
              DC.W dispMenu_16                   ;user menu 16
              DC.W dispMenu_17                   ;user menu 17
              DC.W dispMenu_18                   ;user menu 18
              DC.W dispMenu_19                   ;user menu 19
              DC.W dispMenu_20                   ;user menu 20
              DC.W dispMenu_21                   ;user menu 21
              DC.W dispMenu_22                   ;user menu 22
              DC.W dispMenu_23                   ;user menu 23
              DC.W dispMenu_24                   ;user menu 24
              DC.W dispMenu_25                   ;user menu 25
              DC.W dispMenu_26                   ;user menu 26
              DC.W dispMenu_27                   ;user menu 27
              DC.W dispMenu_28                   ;user menu 28
              DC.W dispMenu_29                   ;user menu 29
              DC.W dispMenu_30                   ;user menu 30
              DC.W dispMenu_31                   ;user menu 31
              DC.W dispMenu_32                   ;user menu 32
              DC.W dispMenu_33                   ;user menu 33
              DC.W dispMenu_34                   ;user menu 34
              DC.W dispMenu_35                   ;user menu 35
              DC.W dispMenu_36                   ;user menu 36
              
dispMenu_0:   LDX #Menu0
              LBRA dispMenu_exit
              
dispMenu_1:   LDX #MenuCPX1
              LBRA dispMenu_exit
              
dispMenu_2:   LDX #MenuCPX2
              LBRA dispMenu_exit
              
dispMenu_3:   LDX #MenuASM1
              LBRA dispMenu_exit
              
dispMenu_4:   LDX #MenuASM2
              LBRA dispMenu_exit
              
dispMenu_5:   LDX #MenuNUM1
              LBRA dispMenu_exit

dispMenu_6:   LDX #MenuNUM2
              LBRA dispMenu_exit

dispMenu_7:   LDX #MenuPOL1
              LBRA dispMenu_exit

dispMenu_8:   LDX #MenuPOL2
              LBRA dispMenu_exit
              
dispMenu_9:   LDX #MenuCAL1
              LBRA dispMenu_exit
              
dispMenu_10:  LDX #MenuCAL2
              LBRA dispMenu_exit
              
dispMenu_11:  LDX #MenuOPR1
              LBRA dispMenu_exit
              
dispMenu_12:  LDX #MenuOPR2
              LBRA dispMenu_exit
              
dispMenu_13:  LDX #MenuFUNC1
              BRA dispMenu_exit
              
dispMenu_14:  LDX #MenuFUNC2
              BRA dispMenu_exit
              
dispMenu_15:  LDX #MenuFIN1
              BRA dispMenu_exit
              
dispMenu_16:  LDX #MenuFIN2
              BRA dispMenu_exit
              
dispMenu_17:  LDX #MenuPRO1
              BRA dispMenu_exit
              
dispMenu_18:  LDX #MenuPRO2
              BRA dispMenu_exit
              
dispMenu_19:  LDX #MenuSTA1
              BRA dispMenu_exit
              
dispMenu_20:  LDX #MenuSTA2
              BRA dispMenu_exit
              
dispMenu_21:  LDX #MenuMAT1
              BRA dispMenu_exit
              
dispMenu_22:  LDX #MenuMAT2
              BRA dispMenu_exit
              
dispMenu_23:  LDX #MenuST1
              BRA dispMenu_exit
              
dispMenu_24:  LDX #MenuST2
              BRA dispMenu_exit
              
dispMenu_25:  LDX #MenuGPH1
              BRA dispMenu_exit
              
dispMenu_26:  LDX #MenuGPH2
              BRA dispMenu_exit
              
dispMenu_27:  LDX #MenuAPP1
              BRA dispMenu_exit
              
dispMenu_28:  LDX #MenuAPP2
              BRA dispMenu_exit
              
dispMenu_29:  LDX #MenuS121User
              BRA dispMenu_exit
              
dispMenu_30:  LDX #MenuS122User
              BRA dispMenu_exit
              
dispMenu_31:  LDX #MenuMDE1User
              BRA dispMenu_exit
              
dispMenu_32:  LDX #MenuMDE2User
              BRA dispMenu_exit
              
dispMenu_33:  LDX #MenuEQN1
              BRA dispMenu_exit
              
dispMenu_34:  LDX #MenuEQN2
              BRA dispMenu_exit
              
dispMenu_35:  LDX #MenuBIN1
              BRA dispMenu_exit
              
dispMenu_36:  LDX #MenuBIN2
                                          
dispMenu_exit:MOVB #$80,colNumber
              JSR sendData3                      ;display the selected user menu 

              RTC
              
;dispPrgMenu: display the selected program menu when in program editing mode

dispPrgMenu:  BCLR PTH,#BIT0                     ;A0 = 0,send command 

              LDAA #$B7                          ;set to page 7
              JSR sendByte          
              
              CLR Ycoord                   
              JSR setY                           ;Y = 0
              
              CLRA

              LDAB menu
              ASLB                               

              LDX #prgMenuTable     

              JMP [D,X]

prgMenuTable  DC.W dispPrgMenu_0                 ;program menu 0                          
              DC.W dispPrgMenu_1                 ;program menu 1 
              DC.W dispPrgMenu_2                 ;program menu 2 
              DC.W dispPrgMenu_3                 ;program menu 3 
              DC.W dispPrgMenu_4                 ;program menu 4 
              DC.W dispPrgMenu_5                 ;program menu 5
              DC.W dispPrgMenu_6                 ;program menu 6
              DC.W dispPrgMenu_7                 ;program menu 7 
              DC.W dispPrgMenu_8                 ;program menu 8
              DC.W dispPrgMenu_9                 ;program menu 9
              DC.W dispPrgMenu_10                ;program menu 10
              DC.W dispPrgMenu_11                ;program menu 11
              DC.W dispPrgMenu_12                ;program menu 12
              DC.W dispPrgMenu_13                ;program menu 13
              DC.W dispPrgMenu_14                ;program menu 14
              DC.W dispPrgMenu_15                ;program menu 15
              DC.W dispPrgMenu_16                ;program menu 16
              DC.W dispPrgMenu_17                ;program menu 17
              DC.W dispPrgMenu_18                ;program menu 18
              DC.W dispPrgMenu_19                ;program menu 19
              DC.W dispPrgMenu_20                ;program menu 20
              DC.W dispPrgMenu_21                ;program menu 21
              DC.W dispPrgMenu_22                ;program menu 22
              DC.W dispPrgMenu_23                ;program menu 23
              DC.W dispPrgMenu_24                ;program menu 24
              DC.W dispPrgMenu_25                ;program menu 25
              DC.W dispPrgMenu_26                ;program menu 26
              DC.W dispPrgMenu_27                ;program menu 27
              DC.W dispPrgMenu_28                ;program menu 28
              DC.W dispPrgMenu_29                ;program menu 29
              DC.W dispPrgMenu_30                ;program menu 30
              DC.W dispPrgMenu_31                ;program menu 31
              DC.W dispPrgMenu_32                ;program menu 32
              DC.W dispPrgMenu_33                ;program menu 33
              DC.W dispPrgMenu_34                ;program menu 34 
              DC.W dispPrgMenu_35                ;program menu 35
              DC.W dispPrgMenu_36                ;program menu 36 
              DC.W dispPrgMenu_37                ;program menu 37
              DC.W dispPrgMenu_38                ;program menu 38 
              DC.W dispPrgMenu_39                ;program menu 39 
              DC.W dispPrgMenu_40                ;program menu 40 
              DC.W dispPrgMenu_41                ;program menu 41
              DC.W dispPrgMenu_42                ;program menu 42 
              DC.W dispPrgMenu_43                ;program menu 43   
              
dispPrgMenu_0:LDX #PrgMenu0
              LBRA dispPrgMenu_exit
              
dispPrgMenu_1:LDX #PrgMenu1
              LBRA dispPrgMenu_exit
              
dispPrgMenu_2:LDX #PrgMenu2
              LBRA dispPrgMenu_exit
              
dispPrgMenu_3:LDX #PrgMenu3
              LBRA dispPrgMenu_exit
              
dispPrgMenu_4:LDX #PrgMenu4
              LBRA dispPrgMenu_exit
              
dispPrgMenu_5:LDX #PrgMenu5
              LBRA dispPrgMenu_exit
              
dispPrgMenu_6:LDX #PrgMenu6
              LBRA dispPrgMenu_exit
              
dispPrgMenu_7:LDX #MenuCPX1
              LBRA dispPrgMenu_exit
              
dispPrgMenu_8:LDX #MenuCPX2Prog
              LBRA dispPrgMenu_exit
              
dispPrgMenu_9:LDX #MenuASM1
              LBRA dispPrgMenu_exit
              
dispPrgMenu_10:
              LDX #MenuASM2
              LBRA dispPrgMenu_exit
              
dispPrgMenu_11:
              LDX #MenuNUM1
              LBRA dispPrgMenu_exit
              
dispPrgMenu_12:
              LDX #MenuNUM2
              LBRA dispPrgMenu_exit
              
dispPrgMenu_13:
              LDX #MenuPOL1
              LBRA dispPrgMenu_exit
              
dispPrgMenu_14:
              LDX #MenuPOL2
              LBRA dispPrgMenu_exit
              
dispPrgMenu_15:
              LDX #MenuCAL1
              LBRA dispPrgMenu_exit
              
dispPrgMenu_16:
              LDX #MenuCAL2
              LBRA dispPrgMenu_exit
              
dispPrgMenu_17:
              LDX #MenuOPR1
              LBRA dispPrgMenu_exit
              
dispPrgMenu_18:
              LDX #MenuOPR2
              BRA dispPrgMenu_exit
              
dispPrgMenu_19:
              LDX #MenuFUNC1
              BRA dispPrgMenu_exit
              
dispPrgMenu_20:
              LDX #MenuFUNC2
              BRA dispPrgMenu_exit
              
dispPrgMenu_21:
              LDX #MenuFIN1
              BRA dispPrgMenu_exit
              
dispPrgMenu_22:
              LDX #MenuFIN2
              BRA dispPrgMenu_exit
              
dispPrgMenu_23:
              LDX #MenuPRO1
              BRA dispPrgMenu_exit
              
dispPrgMenu_24:
              LDX #MenuPRO2
              BRA dispPrgMenu_exit
              
dispPrgMenu_25:
              LDX #MenuSTA1
              BRA dispPrgMenu_exit
              
dispPrgMenu_26:
              LDX #MenuSTA2
              BRA dispPrgMenu_exit
              
dispPrgMenu_27:
              LDX #MenuMAT1
              BRA dispPrgMenu_exit
              
dispPrgMenu_28:
              LDX #MenuMAT2
              BRA dispPrgMenu_exit
              
dispPrgMenu_29:
              LDX #MenuGPH1
              BRA dispPrgMenu_exit
              
dispPrgMenu_30:
              LDX #MenuGPH2
              BRA dispPrgMenu_exit
              
dispPrgMenu_31:
              LDX #MenuAPP1
              BRA dispPrgMenu_exit
              
dispPrgMenu_32:
              LDX #MenuAPP2
              BRA dispPrgMenu_exit
              
dispPrgMenu_33:
              LDX #MenuS121
              BRA dispPrgMenu_exit
              
dispPrgMenu_34:
              LDX #MenuS122
              BRA dispPrgMenu_exit
              
dispPrgMenu_35:
              LDX #MenuMDE1
              BRA dispPrgMenu_exit
              
dispPrgMenu_36:
              LDX #MenuMDE2
              BRA dispPrgMenu_exit
              
dispPrgMenu_37:
              LDX #MenuMDE3
              BRA dispPrgMenu_exit
              
dispPrgMenu_38:
              LDX #MenuEQN1
              BRA dispPrgMenu_exit
              
dispPrgMenu_39:
              LDX #MenuEQN2
              BRA dispPrgMenu_exit 
              
dispPrgMenu_40:
              LDX #MenuBIN1
              BRA dispPrgMenu_exit 
              
dispPrgMenu_41:
              LDX #MenuBIN2
              BRA dispPrgMenu_exit
              
dispPrgMenu_42:
              LDX #MenuST1
              BRA dispPrgMenu_exit
              
dispPrgMenu_43:
              LDX #MenuST2                                                            

dispPrgMenu_exit:
              MOVB #$80,colNumber
              JSR sendData3                      ;display the selected program menu 

              RTC
              
;***********User mode menu lables table***********

Menu0         DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $00, $84, $FE, $80, $00               ;1
              DC.B $00, $FF                                   ;line
                           
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $84, $C2, $A2, $92, $8C               ;2
              DC.B $00, $FF                                   ;line 
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $42, $82, $8A, $96, $62               ;3
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $30, $28, $24, $FE, $20               ;4
              DC.B $00, $FF                                   ;line
                            
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $4E, $8A, $8A, $8A, $72               ;5
              DC.B $00, $FF                                   ;line              
                       
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $78, $94, $92, $92, $60               ;6
              DC.B $00, $00, $00                              ;
              
MenuCPX1      DC.B $00                                        ;21 columns 
              DC.B $FE, $12, $32, $52, $8C, $00               ;R
              DC.B $18, $18, $18, $5A, $3C, $18               ;->
              DC.B $00, $7C, $82, $82, $82, $44               ;C 
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $7C, $82, $82, $82, $44, $00               ;C
              DC.B $18, $18, $18, $5A, $3C, $18               ;-> 
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $FF                                   ;line

              DC.B $00                                        ;21 columns
              DC.B $00, $7C, $82, $82, $82, $44               ;C
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $C2, $A2, $92, $8A, $86               ;Z
              DC.B $00, $FF                                   ;line        

              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $FE, $00, $00               ;|
              DC.B $00, $C2, $A2, $92, $8A, $86               ;Z
              DC.B $00, $00, $00, $FE, $00, $00               ;| 
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $18, $18, $18, $5A, $3C, $18               ;->
              DC.B $00, $F8, $10, $08, $08, $10               ;r
              DC.B $00, $7C, $92, $92, $92, $7C               ;theta 
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns
              DC.B $18, $18, $18, $5A, $3C, $18               ;->
              DC.B $00, $88, $50, $20, $50, $88               ;x
              DC.B $00, $1C, $A0, $A0, $A0, $7C               ;y
              DC.B $00, $00, $00                              ;
              
MenuCPX2      DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $00, $84, $FE, $80, $00               ;1
              DC.B $00, $FF                                   ;line
                           
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $84, $C2, $A2, $92, $8C               ;2
              DC.B $00, $FF                                   ;line 
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $42, $82, $8A, $96, $62               ;3
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $30, $28, $24, $FE, $20               ;4
              DC.B $00, $FF                                   ;line
                            
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $4E, $8A, $8A, $8A, $72               ;5
              DC.B $00, $FF                                   ;line              
                       
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $78, $94, $92, $92, $60               ;6
              DC.B $00, $00, $00                              ;

MenuASM1      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line             
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuASM2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;
              
MenuNUM1      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $FE, $00, $00               ;|
              DC.B $00, $C6, $28, $10, $28, $C6               ;X
              DC.B $00, $00, $00, $FE, $00, $00               ;| 
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns (floor function)
              DC.B $00, $00, $00, $FE, $80, $80               ;
              DC.B $00, $C6, $28, $10, $28, $C6               ;X
              DC.B $00, $80, $80, $FE, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns (ceiling function) 
              DC.B $00, $00, $00, $FE, $02, $02               ;     
              DC.B $00, $C6, $28, $10, $28, $C6               ;X
              DC.B $00, $02, $02, $FE, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G
              DC.B $00, $7C, $82, $82, $82, $44               ;C 
              DC.B $00, $FE, $82, $82, $44, $38               ;D
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $80, $80, $80, $80               ;L     
              DC.B $00, $7C, $82, $82, $82, $44               ;C 
              DC.B $00, $FE, $04, $18, $04, $FE               ;M
              DC.B $00, $FF                                   ;line
              
                                                              ;23 columns
              DC.B $00, $00, $00, $00, $00                    ; 
              DC.B $00, $84, $C2, $A2, $92, $8C               ;2     
              DC.B $00, $22, $14, $08, $14, $22               ;index x              
              DC.B $00, $00, $00, $00, $00, $00               ;
              
MenuNUM2                                                      ;21 columns
              DC.B $00, $00, $00                         ; 
              DC.B $00, $00, $82, $FE, $80, $00               ;l   
              DC.B $00, $70, $88, $88, $90, $FE               ;d
              DC.B $00, $00, $00, $00, $00, $FF               ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ; 
              
MenuPOL1      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuPOL2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ; 
              
MenuCAL1      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuCAL2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00   
              DC.B $00, $00, $00            
            
MenuOPR1      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line             
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuOPR2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;
              
MenuFUNC1     DC.B $00                                        ;21 columns 
              DC.B $00, $90, $A8, $A8, $A8, $40               ;s     
              DC.B $00, $F8, $10, $08, $08, $F0               ;n              
              DC.B $00, $FE, $10, $08, $08, $F0               ;h
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $70, $88, $88, $88, $40               ;c     
              DC.B $00, $90, $A8, $A8, $A8, $40               ;s   
              DC.B $00, $FE, $10, $08, $08, $F0               ;h
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $08, $7E, $88, $80, $40               ;t   
              DC.B $00, $F8, $10, $08, $08, $F0               ;n             
              DC.B $00, $FE, $10, $08, $08, $F0               ;h
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $90, $A8, $A8, $A8, $40               ;s     
              DC.B $00, $F8, $10, $08, $08, $F0               ;n              
              DC.B $00, $FE, $10, $0A, $0A, $F0, $0E          ;h inverse              
              DC.B $FF                                        ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $70, $88, $88, $88, $40               ;c     
              DC.B $00, $90, $A8, $A8, $A8, $40               ;s   
              DC.B $00, $FE, $10, $0A, $0A, $F0, $0E          ;h inverse
              DC.B $FF                                        ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $08, $7E, $88, $80, $40               ;t   
              DC.B $00, $F8, $10, $08, $08, $F0               ;n             
              DC.B $00, $FE, $10, $0A, $0A, $F0, $0E          ;h inverse
              DC.B $00, $00, $00                              ;
              
MenuFUNC2     DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;
              
MenuFIN1      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuFIN2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;
              
MenuPRO1      DC.B $00                                        ;21 columns 
              DC.B $00, $F8, $10, $08, $08, $F0               ;n     
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $F8, $10, $08, $08, $10               ;r
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $F8, $10, $08, $08, $F0               ;n     
              DC.B $00, $7C, $82, $82, $82, $44               ;C
              DC.B $00, $F8, $10, $08, $08, $10               ;r
              DC.B $00, $FF                                   ;line

              DC.B $00                                        ;21 columns
              DC.B $18, $18, $18, $5A, $3C, $18               ;->
              DC.B $00, $8C, $92, $92, $92, $62               ;S
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuPRO2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;
              
MenuSTA1      DC.B $00                                        ;21 columns
              DC.B $00, $30, $30, $B4, $78, $30               ;->
              DC.B $00, $88, $50, $20, $50, $88               ;x
              DC.B $00, $FE, $10, $28, $44, $82               ;K
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns
              DC.B $00, $30, $30, $B4, $78, $30               ;->
              DC.B $00, $1C, $A0, $A0, $A0, $7C               ;y
              DC.B $00, $FE, $10, $28, $44, $82               ;K
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns              
              DC.B $00, $88, $50, $20, $50, $88               ;x
              DC.B $00, $FE, $10, $28, $44, $82               ;K
              DC.B $00, $30, $30, $B4, $78, $30               ;->
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns              
              DC.B $00, $1C, $A0, $A0, $A0, $7C               ;y
              DC.B $00, $FE, $10, $28, $44, $82               ;K
              DC.B $00, $30, $30, $B4, $78, $30               ;->
              DC.B $00, $FF                                   ;line         
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $8C, $54, $24, $54, $8C               ;x bar
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuSTA2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ; 
              
MenuMAT1      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line             
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuMAT2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ; 

MenuST1       DC.B $00                                        ;21 columns
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $02, $02, $FE, $02, $02               ;T 
              DC.B $00, $FF                                   ;line          

              DC.B $00                                        ;21 columns
              DC.B $00, $7E, $80, $80, $80, $7E               ;U
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $02, $02, $FE, $02, $02               ;T
              DC.B $00, $FF                                   ;line        

              DC.B $00                                        ;21 columns
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $3E, $40, $80, $40, $3E               ;V
              DC.B $00, $FE, $12, $32, $52, $8C               ;R 
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $FE, $08, $10, $20, $FE               ;N
              DC.B $00, $84, $C2, $A2, $92, $8C               ;2              
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $FE, $08, $10, $20, $FE               ;N
              DC.B $00, $42, $82, $8A, $96, $62               ;3
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $FE, $08, $10, $20, $FE               ;N
              DC.B $00, $30, $28, $24, $FE, $20               ;4
              DC.B $00, $00, $00                              ;
              
MenuST2       DC.B $00                                        ;21 columns
              DC.B $00, $FE, $82, $82, $44, $38               ;D
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $10, $10, $10, $FE               ;H 
              DC.B $00, $FF                                   ;line

              DC.B $00                                        ;21 columns
              DC.B $00, $FE, $82, $82, $44, $38               ;D
              DC.B $00, $FE, $80, $80, $80, $80               ;L
              DC.B $00, $84, $C2, $A2, $92, $8C               ;2
              DC.B $00, $FF                                   ;line          

              DC.B $00                                        ;21 columns
              DC.B $00, $FE, $82, $82, $44, $38               ;D
              DC.B $00, $FE, $80, $80, $80, $80               ;L
              DC.B $00, $42, $82, $8A, $96, $62               ;3
              DC.B $00, $FF                                   ;line           
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;
              
MenuGPH1      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
                            
MenuGPH2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;    

MenuAPP1      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line             
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuAPP2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;
              
MenuS121User  DC.B $00                                        ;21 columns      
              DC.B $00, $FE, $04, $18, $04, $FE               ;M
              DC.B $00, $FE, $92, $92, $92, $82               ;E 
              DC.B $00, $FE, $04, $18, $04, $FE               ;M
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $02, $02, $FE, $02, $02               ;T
              DC.B $00, $FE, $04, $18, $04, $FE               ;M
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuS122User  DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $F8, $24, $22, $24, $F8               ;A
              DC.B $00, $FE, $92, $92, $92, $6C               ;B
              DC.B $00, $02, $02, $FE, $02, $02               ;T
              DC.B $00, $00, $00                              ;   

MenuMDE1User  DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line             
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;
              
MenuMDE2User  DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ; 

MenuEQN1      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $88, $50, $20, $50, $88               ;x
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line             
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;

MenuEQN2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;

MenuBIN1      DC.B $00                                        ;21 columns
              DC.B $00, $7C, $82, $82, $82, $44               ;C
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $04, $18, $04, $FE               ;M
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $80, $80, $80, $80               ;L 
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns              
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $12, $32, $52, $8C               ;R 
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns
              DC.B $00, $F8, $24, $22, $24, $F8               ;A
              DC.B $00, $8C, $92, $92, $92, $62               ;S
              DC.B $00, $FE, $80, $80, $80, $80               ;L 
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns
              DC.B $00, $F8, $24, $22, $24, $F8               ;A
              DC.B $00, $8C, $92, $92, $92, $62               ;S
              DC.B $00, $FE, $12, $32, $52, $8C               ;R              
              DC.B $00, $FF                                   ;line            
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $F8, $24, $22, $24, $F8               ;A     
              DC.B $00, $FE, $08, $10, $20, $FE               ;N
              DC.B $00, $FE, $82, $82, $44, $38               ;D 
              DC.B $00, $00, $00                              ;
              
MenuBIN2      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00                              ;
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $00, $00                              ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $C6, $28, $10, $28, $C6               ;X     
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;
              
;*******Program edit mode menu lables table*******

PrgMenu0      DC.B $FF                                        ;21 columns
              DC.B $FF, $01, $6D, $6D, $6D, $93               ;B (INV)
              DC.B $FF, $01, $ED, $CD, $AD, $73               ;R (INV)
              DC.B $FF, $07, $DB, $DD, $DB, $07               ;A (INV)  
              DC.B $FF, $FF                                   ;line              
             
              DC.B $00                                        ;21 columns 
              DC.B $00, $40, $80, $82, $7E, $02               ;J
              DC.B $00, $02, $02, $FE, $02, $02               ;T
              DC.B $00, $8C, $92, $92, $92, $62               ;S              
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $FE, $12, $12, $12, $02               ;F
              DC.B $00, $8C, $92, $92, $92, $62               ;S
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns
              DC.B $00, $7C, $82, $82, $82, $44               ;C 
              DC.B $00, $FE, $82, $82, $44, $38               ;D
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $FF                                   ;line  
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $82, $82, $44, $38               ;D                
              DC.B $00, $FE, $92, $92, $92, $82               ;E              
              DC.B $00, $FE, $80, $80, $80, $80               ;L
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $FE, $08, $10, $20, $FE               ;N               
              DC.B $00, $FE, $82, $82, $44, $38               ;D
              DC.B $00, $00, $00                              ;                               
              
PrgMenu1      DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $82, $82, $44, $38               ;D 
              DC.B $00, $FE, $80, $80, $80, $80               ;L                
              DC.B $00, $0E, $10, $E0, $10, $0E               ;Y               
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns
              DC.B $00, $FE, $10, $10, $10, $FE               ;H
              DC.B $00, $FE, $80, $80, $80, $80               ;L 
              DC.B $00, $02, $02, $FE, $02, $02               ;T         
              DC.B $00, $FF                                   ;line        
              
              DC.B $00                                        ;21 columns
              DC.B $00, $8C, $92, $92, $92, $62               ;S
              DC.B $00, $7C, $82, $82, $82, $44               ;C 
              DC.B $00, $FE, $08, $10, $20, $FE               ;N         
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $FE, $10, $28, $44, $82                    ;K
              DC.B $00, $FE, $08, $10, $20, $FE               ;N
              DC.B $00, $30, $30, $30, $B4, $78, $30          ;->
              DC.B $00, $FF                                   ;line 
              
              DC.B $00                                        ;21 columns                                                 ;20 columns 
              DC.B $00, $02, $02, $FE, $02, $02               ;T
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $08, $10, $20, $FE               ;N 
              DC.B $00, $FF                                   ;line 
                            
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $02, $02, $FE, $02, $02               ;T
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $12, $12, $12, $02               ;F
              DC.B $00, $00, $00                              ;
                            
PrgMenu2      DC.B $00                                        ;21 columns
              DC.B $00, $00, $82, $FE, $82, $00               ;I
              DC.B $00, $FE, $08, $10, $20, $FE               ;N   
              DC.B $00, $FE, $10, $28, $44, $82               ;K
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns
              DC.B $00, $FE, $82, $82, $44, $38               ;D 
              DC.B $00, $FE, $92, $92, $92, $82               ;E   
              DC.B $00, $FE, $10, $28, $44, $82               ;K
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00                         ;            
              
PrgMenu3      DC.B $00                                        ;21 columns
              DC.B $00, $7C, $82, $82, $82, $44               ;C
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $80, $80, $80, $80               ;L
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns
              DC.B $00, $FE, $82, $82, $44, $38               ;D
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $FE, $80, $80, $80, $80               ;L
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;

PrgMenu4      DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G 
              DC.B $00, $02, $02, $FE, $02, $02               ;T
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FF                                   ;line         

              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G    
              DC.B $00, $28, $28, $28, $28, $28               ;=
              DC.B $00, $7C, $A2, $92, $8A, $7C               ;0
              DC.B $00, $FF                                   ;line        

              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G     
              DC.B $00, $28, $28, $FF, $28, $28               ;<>
              DC.B $00, $7C, $A2, $92, $8A, $7C               ;0
              DC.B $00, $FF                                   ;line 
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G 
              DC.B $00, $02, $02, $FE, $02, $02               ;T
              DC.B $00, $28, $28, $28, $28, $28               ;=
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G 
              DC.B $00, $02, $02, $FE, $02, $02               ;T
              DC.B $00, $28, $28, $FF, $28, $28               ;<>
              DC.B $00, $FF                                   ;line              
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G
              DC.B $00, $02, $02, $FE, $02, $02               ;T     
              DC.B $00, $00, $82, $44, $28, $10               ;>               
              DC.B $00, $00, $00                              ; 
              
PrgMenu5      DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G
              DC.B $00, $02, $02, $FE, $02, $02               ;T  
              DC.B $00, $10, $28, $44, $82, $00               ;<              
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G
              DC.B $00, $00, $82, $44, $28, $10               ;> 
              DC.B $00, $28, $28, $28, $28, $28               ;=           
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G
              DC.B $00, $10, $28, $44, $82, $00               ;< 
              DC.B $00, $28, $28, $28, $28, $28               ;=           
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G
              DC.B $00, $FE, $10, $28, $44, $82               ;K
              DC.B $00, $FE, $12, $12, $12, $0C               ;P           
              DC.B $00, $FF                                   ;line            
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G     
              DC.B $00, $28, $28, $28, $28, $28               ;=
              DC.B $00, $88, $50, $20, $50, $88               ;x
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G     
              DC.B $00, $28, $28, $FF, $28, $28               ;<>
              DC.B $00, $88, $50, $20, $50, $88               ;x
              DC.B $00, $00, $00                              ; 
              
PrgMenu6      DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G     
              DC.B $00, $00, $82, $C4, $68, $30               ;>=              
              DC.B $00, $88, $50, $20, $50, $88               ;x
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G     
              DC.B $00, $00, $30, $68, $C4, $82               ;<=               
              DC.B $00, $88, $50, $20, $50, $88               ;x
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G     
              DC.B $00, $7C, $82, $82, $82, $44               ;C
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;
              
MenuCPX2Prog  DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;          

MenuS121      DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $92, $92, $92, $6C               ;B
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $08, $10, $20, $FE               ;N
              DC.B $00, $FF                                   ;line 
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $92, $92, $92, $6C               ;B
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $12, $12, $12, $02               ;F
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $08, $10, $20, $FE               ;N
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $7C, $82, $82, $82, $7C               ;O
              DC.B $00, $FE, $12, $12, $12, $02               ;F
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;  
              
MenuS122      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line 
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line 
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line 
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ; 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line 
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ; 

MenuMDE1      DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $82, $82, $44, $38               ;D
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $7C, $82, $92, $92, $F4               ;G 
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $F8, $24, $22, $24, $F8               ;A
              DC.B $00, $FE, $82, $82, $44, $38               ;D
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $92, $92, $F4               ;G 
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $F8, $24, $22, $24, $F8               ;A
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $48, $90, $48, $24, $48               ;~
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $48, $48, $48, $48, $48               ;=
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $7C, $82, $82, $82, $44               ;C
              DC.B $00, $FE, $12, $12, $12, $0C               ;P
              DC.B $00, $C6, $28, $10, $28, $C6               ;X
              DC.B $00, $00, $00                              ;
              
MenuMDE2      DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $FE, $08, $10, $20, $FE               ;N
              DC.B $00, $7C, $82, $92, $92, $F4               ;G 
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $12, $12, $12, $02               ;F
              DC.B $00, $82, $FE, $82, $00, $00               ;I
              DC.B $00, $C6, $28, $10, $28, $C6               ;X
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $FE, $92, $92, $92, $82               ;E
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $FE, $12, $32, $52, $8C               ;R
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ; 

MenuMDE3      DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line    
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00                                        ;21 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $FF                                   ;line
              
              DC.B $00, $00                                   ;23 columns 
              DC.B $00, $00, $00, $00, $00, $00               ;     
              DC.B $00, $00, $00, $00, $00, $00               ;
              DC.B $00, $00, $00, $00, $00, $00               ;   
              DC.B $00, $00, $00                              ;
              
;*********************PAGE_F9*********************Code to input programming instruction codes into RAM when in program 
                                                  ;edit mode                                                
              ORG $F98000 

;dispStatLI2: displays "Shift"/"Alpha"/"STO" on page 7

dispStatLI2:  PSHX
              LDAA colNumber
              PSHA

              BCLR PTH,#BIT0                     ;A0 = 0,send command
                            
              LDAA #$B7                          ;page 7
              JSR sendByte                       ;set the page        

              JSR clearPage                      ;clear the menu (page 7)
              
              MOVB #$25,Ycoord
              JSR setY                           ;Y = 37
              
              PULA 
              STAA colNumber
              
              PULX
              
              JSR sendData                       ;display annunciator
              
              RTS

;***************key functions TWO*****************

;Key0_TWO: "+", "->Z" or "Z->";;;;;;;;;;;;;;;;;;;;

key0_TWOSUB:  BRCLR flag3,#BIT4,key0_TWO_1       ;branch if the previous keypress was not STO
              
              MOVB #$88,0,Y                      ;otherwise (prgCounter) = $88 = 136 (->Z)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key0_TWO_exit  
              
key0_TWO_1:   BRCLR flag3,#BIT1,key0_TWO_2       ;branch if the previous keypress was not RCL 

              MOVB #$60,0,Y                      ;otherwise (prgCounter) = $60 = 96 (Z->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key0_TWO_exit              
                            
key0_TWO_2:   MOVB keyNumber,0,Y                 ;(prgCounter) = $00 = 0 (+)
 
key0_TWO_exit:
              RTC
              
;Key1_TWO: Delete the last program instruction, "DELETE", "->Y" or "Y->"

key1_TWOSUB:  MOVB #$12,counter1                 ;determines how long the key must be held
              
key1_TWO_0:   BRSET PTP,#BIT4,key1_TWO_3         ;branch if PTP.4 = 1, i.e. if Key 1 has been released 
              JSR delay
              DEC counter1
              BNE key1_TWO_0
              
              LDD prgCounter                     ;Key 1 was held, so delete the last program instruction
              CPD #ps_start
              BEQ key1_TWO_2                     ;exit if prgCounter = ps_start

              SUBD #$0001                        ;otherwise decrement the prgCounter
              STD prgCounter
              
              LDX prgCounter
              LDAA #noOperation
              STAA 0,X                           ;(prgCounter) = NOP
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BCLR flag5,#BIT3                   ;do not increment prgCounter            

              BRA key1_TWO_2

key1_TWO_3:   BRCLR flag3,#BIT4,key1_TWO_4       ;branch if the previous keypress was not STO
              
              MOVB #$89,0,Y                      ;otherwise (prgCounter) = $89 = 137 (->Y)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key1_TWO_2  
              
key1_TWO_4:   BRCLR flag3,#BIT1,key1_TWO_1       ;branch if the previous keypress was not RCL

              MOVB #$61,0,Y                      ;otherwise (prgCounter) = $61 = 97 (Y->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key1_TWO_2 

key1_TWO_1:   MOVB keyNumber,0,Y                 ;(prgCounter) = $01 = 1 (DELETE)

key1_TWO_2:   RTC         

;Key2_TWO: ".", "->X" or "X->";;;;;;;;;;;;;;;;;;;; 

key2_TWOSUB:  BRCLR flag3,#BIT4,key2_TWO_3       ;branch if the previous keypress was not STO
              
              MOVB #$8A,0,Y                      ;otherwise (prgCounter) = $8A = 138 (->X)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key2_TWO_2  
              
key2_TWO_3:   BRCLR flag3,#BIT1,key2_TWO_1       ;branch if the previous keypress was not RCL
              
              MOVB #$62,0,Y                      ;otherwise (prgCounter) = $62 = 98 (X->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key2_TWO_2

key2_TWO_1:   MOVB keyNumber,0,Y                 ;(prgCounter) = $02 = 2 (.)
                            
key2_TWO_2:   RTC              
              
;Key3_TWO: "0", "->W" or "W->";;;;;;;;;;;;;;;;;;;; 

key3_TWOSUB:  BRCLR flag3,#BIT5,key3_TWO_1       ;branch if not in code input mode
              JMP Zero                           ;otherwise "0" entered as part of instruction code     

key3_TWO_1:   BRCLR flag3,#BIT4,key3_TWO_4       ;branch if the previous keypress was not STO
              
              MOVB #$8B,0,Y                      ;otherwise (prgCounter) = $8B = 139 (->W)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key3_TWO_3              
              
key3_TWO_4:   BRCLR flag3,#BIT1,key3_TWO_2       ;branch if the previous keypress was not RCL
              
              MOVB #$63,0,Y                      ;otherwise (prgCounter) = $63 = 99 (W->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key3_TWO_3             
              
key3_TWO_2:   MOVB keyNumber,0,Y                 ;(prgCounter) = $03 = 3 (0)
                            
key3_TWO_3:   RTC             
              
;Key4_TWO: "NEG", "->V" or "V->" ;;;;;;;;;;;;;;;;;

key4_TWOSUB:  BRCLR flag3,#BIT4,key4_TWO_3       ;branch if the previous keypress was not STO
              
              MOVB #$8C,0,Y                      ;otherwise (prgCounter) = $8C = 140 (->V)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key4_TWO_2 
              
key4_TWO_3:   BRCLR flag3,#BIT1,key4_TWO_1       ;branch if the previous keypress was not RCL
              
              MOVB #$64,0,Y                      ;otherwise (prgCounter) = $64 = 100 (V->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key4_TWO_2               
              
key4_TWO_1:   MOVB keyNumber,0,Y                 ;(prgCounter) = $04 = 4 (NEG)
                            
key4_TWO_2:   RTC
              
;Key6_TWO: "-", "->U" or "U->";;;;;;;;;;;;;;;;;;;;

key6_TWOSUB:  BRCLR flag3,#BIT4,key6_TWO_3       ;branch if the previous keypress was not STO
              
              MOVB #$8D,0,Y                      ;otherwise (prgCounter) = $8D = 141 (->U)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key6_TWO_2
              
key6_TWO_3:   BRCLR flag3,#BIT1,key6_TWO_1       ;branch if the previous keypress was not RCL
              
              MOVB #$65,0,Y                      ;otherwise (prgCounter) = $65 = 101 (U->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key6_TWO_2             
              
key6_TWO_1:   MOVB keyNumber,0,Y                 ;(prgCounter) = $06 = 6 (-)
                            
key6_TWO_2:   RTC
              
;Key7_TWO: "3" or "->T";;;;;;;;;;;;;;;;;;;;;;;;;;; 

key7_TWOSUB:  BRCLR flag3,#BIT5,key7_TWO_1       ;branch if not in code input mode
              JMP Thre                           ;otherwise "3" entered as part of instruction code     

key7_TWO_1:   BRCLR flag3,#BIT4,key7_TWO_4       ;branch if the previous keypress was not STO
              
              MOVB #$8E,0,Y                      ;otherwise (prgCounter) = $8E = 142 (->T)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key7_TWO_3
              
key7_TWO_4:   BRCLR flag3,#BIT1,key7_TWO_2       ;branch if the previous keypress was not RCL
              
              MOVB #$66,0,Y                      ;otherwise (prgCounter) = $66 = 102 (T->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key7_TWO_3             
              
key7_TWO_2:   MOVB keyNumber,0,Y                 ;(prgCounter) = $07 = 7 (3)
                            
key7_TWO_3:   RTC      

;Key8_TWO: "2", "->S" or "S->";;;;;;;;;;;;;;;;;;;; 

key8_TWOSUB:  BRCLR flag3,#BIT5,key8_TWO_1       ;branch if not in code input mode
              BCLR flag4,#BIT6                   ;do not update the program screen
              JMP Two                            ;"2" entered as part of instruction code

key8_TWO_1:   BRCLR flag3,#BIT4,key8_TWO_4       ;branch if the previous keypress was not STO
              
              MOVB #$8F,0,Y                      ;otherwise (prgCounter) = $8F = 143 (->S)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key8_TWO_3  
              
key8_TWO_4:   BRCLR flag3,#BIT1,key8_TWO_2       ;branch if the previous keypress was not RCL
              
              MOVB #$67,0,Y                      ;otherwise (prgCounter) = $67 = 103 (S->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key8_TWO_3 

key8_TWO_2:   MOVB keyNumber,0,Y                 ;(prgCounter) = $08 = 8 (2)
                            
key8_TWO_3:   RTC
              
;Key9_TWO: "1", "->R" or "R->";;;;;;;;;;;;;;;;;;;; 

key9_TWOSUB:  BRCLR flag3,#BIT5,key9_TWO_1       ;branch if not in code input mode
              BCLR flag4,#BIT6                   ;do not update the program screen
              JMP One                            ;"1" entered as part of instruction code        

key9_TWO_1:   BRCLR flag3,#BIT4,key9_TWO_4       ;branch if the previous keypress was not STO
              
              MOVB #$90,0,Y                      ;otherwise (prgCounter) = $90 = 144 (->R)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key9_TWO_3  
              
key9_TWO_4:   BRCLR flag3,#BIT1,key9_TWO_2       ;branch if the previous keypress was not RCL
              
              MOVB #$68,0,Y                      ;otherwise (prgCounter) = $68 = 104 (R->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key9_TWO_3

key9_TWO_2:   MOVB keyNumber,0,Y                 ;(prgCounter) = $09 = 9 (1)
                            
key9_TWO_3:   RTC
               
;Key10_TWO: "EXP", "->Q" or "Q->";;;;;;;;;;;;;;;;; 

key10_TWOSUB: BRCLR flag3,#BIT4,key10_TWO_2      ;branch if the previous keypress was not STO
              
              MOVB #$91,0,Y                      ;otherwise (prgCounter) = $91 = 145 (->Q)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key10_TWO_4  
              
key10_TWO_2:  BRCLR flag3,#BIT1,key10_TWO_1      ;branch if the previous keypress was not RCL
              
              MOVB #$69,0,Y                      ;otherwise (prgCounter) = $69 = 105 (Q->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key10_TWO_4

key10_TWO_1:  MOVB keyNumber,0,Y                 ;(prgCounter) = $0A = 10 (EXP)              
      
key10_TWO_4:  RTC

;Key12_TWO: "*", "->P" or "P->";;;;;;;;;;;;;;;;;;; 

key12_TWOSUB: BRCLR flag3,#BIT4,key12_TWO_3      ;branch if the previous keypress was not STO
              
              MOVB #$92,0,Y                      ;otherwise (prgCounter) = $92 = 146 (->P)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key12_TWO_2              

key12_TWO_3:  BRCLR flag3,#BIT1,key12_TWO_1      ;branch if the previous keypress was not RCL
              
              MOVB #$6A,0,Y                      ;otherwise (prgCounter) = $6A = 106 (P->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key12_TWO_2

key12_TWO_1:  MOVB keyNumber,0,Y                 ;(prgCounter) = $0C = 12 (*)
                            
key12_TWO_2:  RTC
              
;Key13_TWO: "6", "->O" or "O->";;;;;;;;;;;;;;;;;;; 

key13_TWOSUB: BRCLR flag3,#BIT5,key13_TWO_1      ;branch if not in code input mode
              JMP Six                            ;otherwise "6" entered as part of instruction code     

key13_TWO_1:  BRCLR flag3,#BIT4,key13_TWO_4      ;branch if the previous keypress was not STO
              
              MOVB #$93,0,Y                      ;otherwise (prgCounter) = $93 = 147 (->O)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key13_TWO_3  
              
key13_TWO_4:  BRCLR flag3,#BIT1,key13_TWO_2      ;branch if the previous keypress was not RCL
              
              MOVB #$6B,0,Y                      ;otherwise (prgCounter) = $6B = 107 (O->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key13_TWO_3 

key13_TWO_2:  MOVB keyNumber,0,Y                 ;(prgCounter) = $0D = 13 (6)
                            
key13_TWO_3:  RTC
              
;Key14_TWO: "5", "->N" or "N->";;;;;;;;;;;;;;;;;;; 

key14_TWOSUB: BRCLR flag3,#BIT5,key14_TWO_1      ;branch if not in code input mode
              JMP Five                           ;otherwise "5" entered as part of instruction code     

key14_TWO_1:  BRCLR flag3,#BIT4,key14_TWO_4      ;branch if the previous keypress was not STO
              
              MOVB #$94,0,Y                      ;otherwise (prgCounter) = $94 = 148 (->N)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key14_TWO_3  
              
key14_TWO_4:  BRCLR flag3,#BIT1,key14_TWO_2      ;branch if the previous keypress was not RCL
              
              MOVB #$6C,0,Y                      ;otherwise (prgCounter) = $6C = 108 (N->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key14_TWO_3

key14_TWO_2:  MOVB keyNumber,0,Y                 ;(prgCounter) = $0E = 14 (5)
                            
key14_TWO_3:  RTC
              
;Key15_TWO: "4", "->M" or "M->";;;;;;;;;;;;;;;;;;; 

key15_TWOSUB: BRCLR flag3,#BIT5,key15_TWO_1      ;branch if not in code input mode
              JMP Four                           ;otherwise "4" entered as part of instruction code     

key15_TWO_1:  BRCLR flag3,#BIT4,key15_TWO_4      ;branch if the previous keypress was not STO
              
              MOVB #$95,0,Y                      ;otherwise (prgCounter) = $95 = 149 (->M)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key15_TWO_3  
              
key15_TWO_4:  BRCLR flag3,#BIT1,key15_TWO_2      ;branch if the previous keypress was not RCL
              
              MOVB #$6D,0,Y                      ;otherwise (prgCounter) = $6D = 109 (M->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key15_TWO_3   

key15_TWO_2:  MOVB keyNumber,0,Y                 ;(prgCounter) = $0F = 15 (4)
                            
key15_TWO_3:  RTC
              
;Key16_TWO: "ENTER", "->L" or "L->";;;;;;;;;;;;;;;

key16_TWOSUB: BRCLR flag3,#BIT5,key16_TWO_1      ;branch if not in code input mode
              JMP Ente                           ;otherwise simulate "Enter" key press

key16_TWO_1:  BRCLR flag3,#BIT4,key16_TWO_4      ;branch if the previous keypress was not STO
              
              MOVB #$96,0,Y                      ;otherwise (prgCounter) = $96 = 150 (->L)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key16_TWO_3  
              
key16_TWO_4:  BRCLR flag3,#BIT1,key16_TWO_2      ;branch if the previous keypress was not RCL
              
              MOVB #$6E,0,Y                      ;otherwise (prgCounter) = $6E = 110 (L->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key16_TWO_3

key16_TWO_2:  MOVB keyNumber,0,Y                 ;(prgCounter) = $10 = 16 (ENTER)
                            
key16_TWO_3:  RTC           
              
;Key18_TWO: "/", "->K" or "K->";;;;;;;;;;;;;;;;;;; 

key18_TWOSUB: BRCLR flag3,#BIT4,key18_TWO_3      ;branch if the previous keypress was not STO
              
              MOVB #$97,0,Y                      ;otherwise (prgCounter) = $97 = 151 (->K)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key18_TWO_2  
              
key18_TWO_3:  BRCLR flag3,#BIT1,key18_TWO_1      ;branch if the previous keypress was not RCL
              
              MOVB #$6F,0,Y                      ;otherwise (prgCounter) = $6F = 111 (K->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key18_TWO_2 

key18_TWO_1:  MOVB keyNumber,0,Y                 ;(prgCounter) = $12 = 18 (/)
                            
key18_TWO_2:  RTC
              
;Key19_TWO: "9", "->J" or "J->";;;;;;;;;;;;;;;;;;; 

key19_TWOSUB: BRCLR flag3,#BIT5,key19_TWO_1      ;branch if not in code input mode
              JMP Nine                           ;otherwise "9" entered as part of instruction code     

key19_TWO_1:  BRCLR flag3,#BIT4,key19_TWO_4      ;branch if the previous keypress was not STO
              
              MOVB #$98,0,Y                      ;otherwise (prgCounter) = $98 = 152 (->J)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key19_TWO_3  
              
key19_TWO_4:  BRCLR flag3,#BIT1,key19_TWO_2      ;branch if the previous keypress was not RCL
              
              MOVB #$70,0,Y                      ;otherwise (prgCounter) = $70 = 112 (J->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key19_TWO_3

key19_TWO_2:  MOVB keyNumber,0,Y                 ;(prgCounter) = $13 = 19 (9)
                            
key19_TWO_3:  RTC
              
;Key20_TWO: "8", "->I" or "I->";;;;;;;;;;;;;;;;;;; 

key20_TWOSUB: BRCLR flag3,#BIT5,key20_TWO_1      ;branch if not in code input mode
              JMP Eigh                           ;otherwise "8" entered as part of instruction code     

key20_TWO_1:  BRCLR flag3,#BIT4,key20_TWO_4      ;branch if the previous keypress was not STO
              
              MOVB #$99,0,Y                      ;otherwise (prgCounter) = $99 = 153 (->I)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key20_TWO_3  
              
key20_TWO_4:  BRCLR flag3,#BIT1,key20_TWO_2      ;branch if the previous keypress was not RCL
              
              MOVB #$71,0,Y                      ;otherwise (prgCounter) = $71 = 113 (I->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key20_TWO_3 

key20_TWO_2:  MOVB keyNumber,0,Y                 ;(prgCounter) = $14 = 20 (8)
                            
key20_TWO_3:  RTC
              
;Key21_TWO: "7", "->H" or "H->";;;;;;;;;;;;;;;;;;; 

key21_TWOSUB: BRCLR flag3,#BIT5,key21_TWO_1      ;branch if not in code input mode
              JMP Seve                           ;otherwise "7" entered as part of instruction code     

key21_TWO_1:  BRCLR flag3,#BIT4,key21_TWO_4      ;branch if the previous keypress was not STO
              
              MOVB #$9A,0,Y                      ;otherwise (prgCounter) = $9A = 154 (->H)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key21_TWO_3  
              
key21_TWO_4:  BRCLR flag3,#BIT1,key21_TWO_2      ;branch if the previous keypress was not RCL
              
              MOVB #$72,0,Y                      ;otherwise (prgCounter) = $72 = 114 (H->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key21_TWO_3

key21_TWO_2:  MOVB keyNumber,0,Y                 ;(prgCounter) = $15 = 21 (7)
                            
key21_TWO_3:  RTC
              
;Key22_TWO: "SHIFT", "->G" or "G->";;;;;;;;;;;;;;;

key22_TWOSUB: BRCLR flag3,#BIT4,key22_TWO_2      ;branch if the previous keypress was not STO

              MOVB #$9B,0,Y                      ;otherwise (prgCounter) = $9B = 155 (->G)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key22_TWO_exit     

key22_TWO_2:  BRCLR flag3,#BIT1,key22_TWO_1      ;branch if the previous keypress was not RCL

              MOVB #$73,0,Y                      ;otherwise (prgCounter) = $73 = 115 (G->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key22_TWO_exit

key22_TWO_1:  BCLR flag4,#BIT6                   ;clear updtPrgScreen flag

						  MOVB #$1E,colNumber
						  BSET flag1,#BIT0                   ;set shift flag 
              LDX #Shift
      
              JSR dispStatLI2                    ;display "SHIFT" on page 7
              
key22_TWO_exit:
              RTC

;Key24_TWO: "10^x", "->F" or "F->";;;;;;;;;;;;;;;; 

key24_TWOSUB: BRCLR flag3,#BIT4,key24_TWO_3      ;branch if the previous keypress was not STO
              
              MOVB #$9C,0,Y                      ;otherwise (prgCounter) = $9C = 156 (->F)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key24_TWO_2  
              
key24_TWO_3:  BRCLR flag3,#BIT1,key24_TWO_1      ;branch if the previous keypress was not RCL
              
              MOVB #$74,0,Y                      ;otherwise (prgCounter) = $74 = 116 (F->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key24_TWO_2

key24_TWO_1:  MOVB keyNumber,0,Y                 ;(prgCounter) = $18 = 24 (10^x)
                            
key24_TWO_2:  RTC
              
;Key25_TWO: "e^x", "->E" or "E->";;;;;;;;;;;;;;;;; 

key25_TWOSUB: BRCLR flag3,#BIT4,key25_TWO_3      ;branch if the previous keypress was not STO
              
              MOVB #$9D,0,Y                      ;otherwise (prgCounter) = $9D = 157 (->E)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key25_TWO_2  
              
key25_TWO_3:  BRCLR flag3,#BIT1,key25_TWO_1      ;branch if the previous keypress was not RCL
              
              MOVB #$75,0,Y                      ;otherwise (prgCounter) = $75 = 117 (E->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key25_TWO_2

key25_TWO_1:  MOVB keyNumber,0,Y                 ;(prgCounter) = $19 = 25 (e^x)
                            
key25_TWO_2:  RTC
              
;Key26_TWO: Pi, "->D" or "D->";;;;;;;;;;;;;;;;;;;; 

key26_TWOSUB: BRCLR flag3,#BIT4,key26_TWO_3      ;branch if the previous keypress was not STO
              
              MOVB #$9E,0,Y                      ;otherwise (prgCounter) = $9E = 158 (->D)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key26_TWO_2  
              
key26_TWO_3:  BRCLR flag3,#BIT1,key26_TWO_1      ;branch if the previous keypress was not RCL
              
              MOVB #$76,0,Y                      ;otherwise (prgCounter) = $76 = 118 (D->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key26_TWO_2  

key26_TWO_1:  MOVB keyNumber,0,Y                 ;(prgCounter) = $1A = 26 (Pi)
                            
key26_TWO_2:  RTC
              
;Key27_TWO: "tan", "->C" or "C->";;;;;;;;;;;;;;;;; 

key27_TWOSUB: BRCLR flag3,#BIT4,key27_TWO_3      ;branch if the previous keypress was not STO
              
              MOVB #$9F,0,Y                      ;otherwise (prgCounter) = $9F = 159 (->C)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key27_TWO_2  
              
key27_TWO_3:  BRCLR flag3,#BIT1,key27_TWO_1      ;branch if the previous keypress was not RCL
              
              MOVB #$77,0,Y                      ;otherwise (prgCounter) = $77 = 119 (C->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key27_TWO_2

key27_TWO_1:  MOVB keyNumber,0,Y                 ;(prgCounter) = $1B = 27 (tan)
                            
key27_TWO_2:  RTC
              
;Key28_TWO: "cos", "->B" or "B->;;;;;;;;;;;;;;;;;; 

key28_TWOSUB: BRCLR flag3,#BIT4,key28_TWO_3      ;branch if the previous keypress was not STO
              
              MOVB #$A0,0,Y                      ;otherwise (prgCounter) = $A0 = 160 (->B)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key28_TWO_2  
              
key28_TWO_3:  BRCLR flag3,#BIT1,key28_TWO_1      ;branch if the previous keypress was not RCL
              
              MOVB #$78,0,Y                      ;otherwise (prgCounter) = $78 = 120 (B->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key28_TWO_2 

key28_TWO_1:  MOVB keyNumber,0,Y                 ;(prgCounter) = $1C = 28 (cos)
                            
key28_TWO_2:  RTC
              
;Key29_TWO: "sin", "->A" or "A->";;;;;;;;;;;;;;;;; 

key29_TWOSUB: BRCLR flag3,#BIT4,key29_TWO_3      ;branch if the previous keypress was not STO
              
              MOVB #$A1,0,Y                      ;otherwise (prgCounter) = $A1 = 161 (->A)
              
              BCLR flag3,#BIT4                   ;clear the sto flag
              
              BRA key29_TWO_2  
              
key29_TWO_3:  BRCLR flag3,#BIT1,key29_TWO_1      ;branch if the previous keypress was not RCL
              
              MOVB #$79,0,Y                      ;otherwise (prgCounter) = $79 = 121 (A->)
              
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              BRA key29_TWO_2

key29_TWO_1:  MOVB keyNumber,0,Y                 ;(prgCounter) = $1D = 29 (sin)
                            
key29_TWO_2:  RTC
              
;Key30_TWO: "1/x";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

key30_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag 

              BCLR flag3,#BIT1                   ;clear the rcl flag    

              MOVB keyNumber,0,Y                 ;(prgCounter) = $1E = 30 (1/x)
              
              RTC
              
;Key31_TWO: "x^y";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

key31_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag 

              BCLR flag3,#BIT1                   ;clear the rcl flag    

              MOVB keyNumber,0,Y                 ;(prgCounter) = $1F = 31 (x^y)
                            
              RTC
              
;Key32_TWO: "x^2";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

key32_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag 

              BCLR flag3,#BIT1                   ;clear the rcl flag  

              MOVB keyNumber,0,Y                 ;(prgCounter) = $20 = 32 (x^2)
                            
              RTC     
              
;Key33_TWO: Set "Hex" mode;;;;;;;;;;;;;;;;;;;;;;;; 

key33_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag 

              BCLR flag3,#BIT1                   ;clear the rcl flag 

              MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter                    
              
              MOVB #$09,0,Y                      ;(prgCounter + 1) = 9 (set Hex mode)
              
              RTC
              
;Key34_TWO: Set "Dec"/"Sci" mode;;;;;;;;;;;;;;;;;;;;;;;; 

key34_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              
              BCLR flag3,#BIT1                   ;clear the rcl flag 

              MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep

              MOVB #$12,counter1                 ;determines how long the key must be held
              
key34_TWOSUB_1:  
              BRSET PTP,#BIT1,key34_TWOSUB_2     ;branch if PTP.1 = 1, i.e. if Key 34 has been released 
              JSR delay
              DEC counter1
              BNE key34_TWOSUB_1
              
              LDY prgCounter                     ;Key 34 was held so set "Sci" mode instruction
              
              MOVB #$0C,0,Y                      ;(prgCounter + 1) = 12 (set Sci mode)
              
              BRA key34_TWOSUB_exit
              
key34_TWOSUB_2:
              LDY prgCounter                     ;Key 34 was not held so set "Dec" mode instruction
              
              MOVB #$0A,0,Y                      ;(prgCounter + 1) = 10 (set Dec mode)              
              
key34_TWOSUB_exit:
              RTC
              
;Key35_TWO: Set "Bin" mode;;;;;;;;;;;;;;;;;;;;;;;; 

key35_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag 

              MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter                    
              
              MOVB #$0B,0,Y                      ;(prgCounter + 1) = 11 (set Bin mode)
              
              RTC         

;Key36_TWO: exit the current program menu/exit program edit mode

key36_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag    

              BCLR flag5,#BIT3                   ;do not increment prgCounter
              
              CLRA

              LDAB menu
              ADDB menu                              

              LDX #PMEKTable     

              JMP [D,X]

PMEKTable     DC.W key36_TWO_exitPrgEd           ;program menu0                           
              DC.W key36_TWO_exitPrgEd           ;program menu1  
              DC.W key36_TWO_exitPrgEd           ;program menu2 
              DC.W key36_TWO_exitPrgEd           ;program menu3  
              DC.W key36_TWO_menu0               ;program menu4 = BRA1
              DC.W key36_TWO_menu0               ;program menu5 = BRA2
              DC.W key36_TWO_menu0               ;program menu6 = BRA3
              DC.W key36_TWO_menu0               ;program menu7 = CPLX1
              DC.W key36_TWO_menu0               ;program menu8 = CPLX2
              DC.W key36_TWO_menu0               ;program menu9 = ASM1
              DC.W key36_TWO_menu0               ;program menu10 = ASM2
              DC.W key36_TWO_menu0               ;program menu11 = NUM1
              DC.W key36_TWO_menu0               ;program menu12 = NUM2
              DC.W key36_TWO_menu0               ;program menu13 = POL1 
              DC.W key36_TWO_menu0               ;program menu14 = POL2
              DC.W key36_TWO_menu0               ;program menu15 = CAL1
              DC.W key36_TWO_menu0               ;program menu16 = CAL2
              DC.W key36_TWO_menu0               ;program menu17 = OPR1
              DC.W key36_TWO_menu0               ;program menu18 = OPR2
              DC.W key36_TWO_menu0               ;program menu19 = FUNC1
              DC.W key36_TWO_menu0               ;program menu20 = FUNC2
              DC.W key36_TWO_menu0               ;program menu21 = FIN1 
              DC.W key36_TWO_menu0               ;program menu22 = FIN2
              DC.W key36_TWO_menu0               ;program menu23 = PRO1
              DC.W key36_TWO_menu0               ;program menu24 = PRO2 
              DC.W key36_TWO_menu0               ;program menu25 = STA1
              DC.W key36_TWO_menu0               ;program menu26 = STA2
              DC.W key36_TWO_menu0               ;program menu27 = MAT1
              DC.W key36_TWO_menu0               ;program menu28 = MAT2
              DC.W key36_TWO_menu0               ;program menu29 = GRPH1
              DC.W key36_TWO_menu0               ;program menu30 = GRPH2
              DC.W key36_TWO_menu0               ;program menu31 = APP1
              DC.W key36_TWO_menu0               ;program menu32 = APP2
              DC.W key36_TWO_menu0               ;program menu33 = SYSPrg1
              DC.W key36_TWO_menu0               ;program menu34 = SYSPrg2
              DC.W key36_TWO_menu0               ;program menu35 = MODEPrg1
              DC.W key36_TWO_menu0               ;program menu36 = MODEPrg2 
              DC.W key36_TWO_menu0               ;program menu37 = MODEPrg3
              DC.W key36_TWO_menu0               ;program menu38 = EQN1
              DC.W key36_TWO_menu0               ;program menu39 = EQN2 
              DC.W key36_TWO_menu0               ;program menu40 = BIN1
              DC.W key36_TWO_menu0               ;program menu41 = BIN2
              DC.W key36_TWO_menu0               ;program menu42 = STAK1
              DC.W key36_TWO_menu0               ;program menu43 = STAK2

key36_TWO_exitPrgEd:
              CALL cplProg                       ;convert keystroke numbers to offsets 

              BCLR flag3,#BIT6                   ;clear the prg flag (exit program edit mode)
              
              BRCLR flag4,#BIT1,key36_TWO_exitPrgEd_1  
                                                 ;branch if not in complex number mode
              MOVB #$01,menu
              BRA key36_TWO_exitPrgEd_2
              
key36_TWO_exitPrgEd_1:              
              CLR menu                           ;clear the menu             
key36_TWO_exitPrgEd_2:
              JSR clrComLMem                     ;clear command line memory
              
              BCLR flag1,#BIT7                   ;clear the curOff flag to turn on the cursor
              
              BRA key36_TWO_exit              

key36_TWO_menu0:
              CLR menu

key36_TWO_exit:
              RTC

;Key37_TWO: program edit mode down arrow;;;;;;;;;;

key37_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              MOVB #$12,counter1                 ;determines how long the key must be held
              
key37_TWO_loop1:  
              BRSET PTP,#BIT4,key37_TWO_2        ;branch if PTP.4 = 1, i.e. if Key 37 has been released 
              JSR delay
              DEC counter1
              BNE key37_TWO_loop1
              
key37_TWO_loop2:  
              BRCLR PTP,#BIT4,key37_TWO_1        ;scroll if PTP.4 = 0, i.e. if Key 37 has not been released

              BRA key37_TWO_exit                 ;otherwise exit     
               
key37_TWO_1:  LDX prgCounter
              CPX #ps_end
              BEQ key37_TWO_loop2                ;loop if at the end of the program stack 
               
              INX                                ;otherwise increment the program counter            
              STX prgCounter         
              
              CALL updatePrgStack                ;update the program stack 
              
              BRA key37_TWO_loop2                ;repeat until Key 37 released
              
key37_TWO_2:  LDD prgCounter
              CPD #ps_end
              BNE key37_TWO_exit                 ;exit if prgCounter <> ps_end
              
              BCLR flag5,#BIT3                   ;otherwise do not increment prgCounter
              
              BRA key37_TWO_exit
              
key37_TWO_exit:
              RTC
              
;Key38_TWO: program edit mode up arrow;;;;;;;;;;;;

key38_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              MOVB #$12,counter1                 ;determines how long the key must be held
              
key38_TWO_loop1:  
              BRSET PTP,#BIT3,key38_TWO_2        ;branch if PTP.3 = 1, i.e. if Key 38 has been released 
              JSR delay
              DEC counter1
              BNE key38_TWO_loop1
              
key38_TWO_loop2:  
              BRCLR PTP,#BIT3,key38_TWO_1        ;scroll if PTP.3 = 0, i.e. if Key 38 has not been released

              BRA key38_TWO_exit                 ;otherwise exit     
               
key38_TWO_1:  LDX prgCounter
              CPX #ps_start
              BEQ key38_TWO_loop2                ;loop if at the start of the program stack 
               
              DEX                                ;otherwise decrement the program counter             
              STX prgCounter         
              
              CALL updatePrgStack                ;update the program stack 
              
              BRA key38_TWO_loop2                ;repeat until Key 38 released
              
key38_TWO_2:  BCLR flag5,#BIT3                   ;do not increment prgCounter 

              LDD prgCounter
              CPD #ps_start
              BEQ key38_TWO_exit                 ;exit if prgCounter = ps_start
              
              SUBD #$0001
              STD prgCounter                     ;otherwise decrement prgCounter
              
              BRA key38_TWO_exit
              
key38_TWO_exit:
              RTC

;Key41_TWO: toggle program menus;;;;;;;;;;;;;;;;;;

key41_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag                                 

              MOVB #$12,counter1                 ;determines how long the key must be held
              
key41_TWOSUB_loop:
              BRSET PTP,#BIT0,key41_TWOSUB_cont  ;branch if PTP.0 = 1, i.e. if Key 41 has been released 
              JSR delay
              DEC counter1
              BNE key41_TWOSUB_loop
              
              BRA key41_TWOSUB_exit              ;PREV menu (future implementation) 
              
key41_TWOSUB_cont:
              LDAB menu
              LDX #NxtPrgMenu
              ABX                                ;X + menu -> X
              
              MOVB 0,X,menu                      ;update menu              

              BCLR flag5,#BIT3                   ;do not increment prgCounter
 
key41_TWOSUB_exit:
              RTC
         
;Key42_TWO: MK6 program edit menu;;;;;;;;;;;;;;;;; 

key42_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag
              
              CLRA

              LDAB menu
              ADDB menu                              

              LDX #PMK6Table     

              JMP [D,X]

PMK6Table     DC.W key42_TWO_0                   ;program menu 0 = END
              DC.W key42_TWO_1                   ;program menu 1 = TOF
              DC.W key42_TWO_exit                ;program menu 2 
              DC.W key42_TWO_exit                ;program menu 3
              DC.W key42_TWO_4                   ;program menu 4 = GOTOIF>
              DC.W key42_TWO_5                   ;program menu 5 = GOTOIF<>x(K)
              DC.W key42_TWO_exit                ;program menu 6 
              DC.W key42_TWO_7                   ;program menu 7 = ->xy
              DC.W key42_TWO_exit                ;program menu 8
              DC.W key42_TWO_exit                ;program menu 9 = ASM1 function 6                                  
              DC.W key42_TWO_exit                ;program menu 10 = ASM2 function 6
              DC.W key42_TWO_11                  ;program menu 11 = NUM1 function 6 = 2^x                                   
              DC.W key42_TWO_exit                ;program menu 12 = NUM2 function 6                                  
              DC.W key42_TWO_exit                ;program menu 13 = POL1 function 6                                  
              DC.W key42_TWO_exit                ;program menu 14 = POL2 function 6                                  
              DC.W key42_TWO_exit                ;program menu 15 = CAL1 function 6                                  
              DC.W key42_TWO_exit                ;program menu 16 = CAL2 function 6                                   
              DC.W key42_TWO_exit                ;program menu 17 = OPRE1 function 6                                  
              DC.W key42_TWO_exit                ;program menu 18 = OPRE2 function 6                                   
              DC.W key42_TWO_19                  ;program menu 19 = FUNC1 function 6 = arctanh x                                    
              DC.W key42_TWO_exit                ;program menu 20 = FUNC2 function 6                                  
              DC.W key42_TWO_exit                ;program menu 21 = FINA1 function 6                                   
              DC.W key42_TWO_exit                ;program menu 22 = FINA2 function 6
              DC.W key42_TWO_exit                ;program menu 23 = PRO1 function 6                                   
              DC.W key42_TWO_exit                ;program menu 24 = PRO2 function 6
              DC.W key42_TWO_exit                ;program menu 25 = STAT1 function 6 
              DC.W key42_TWO_exit                ;program menu 26 = STAT2 function 6
              DC.W key42_TWO_exit                ;program menu 27 = MATR1 function 6
              DC.W key42_TWO_exit                ;program menu 28 = MATR2 function 6
              DC.W key42_TWO_exit                ;program menu 29 = GRPH1 function 6
              DC.W key42_TWO_exit                ;program menu 30 = GRPH2 function 6
              DC.W key42_TWO_exit                ;program menu 31 = APP1 function 6
              DC.W key42_TWO_exit                ;program menu 32 = APP2 function 6
              DC.W key42_TWO_exit                ;program menu 33 = SYSPrg1 function 6
              DC.W key42_TWO_exit                ;program menu 34 = SYSPrg2 function 6
              DC.W key42_TWO_35                  ;program menu 35 = MODEPrg1 function 6 = set CPX mode
              DC.W key42_TWO_exit                ;program menu 36 = MODEPrg2 function 6
              DC.W key42_TWO_exit                ;program menu 37 = MODEPrg3 function 6
              DC.W key42_TWO_exit                ;program menu 38 = EQN1 function 6
              DC.W key42_TWO_exit                ;program menu 39 = EQN2 function 6
              DC.W key42_TWO_exit                ;program menu 40 = BIN1 function 6
              DC.W key42_TWO_exit                ;program menu 41 = BIN2 function 6
              DC.W key42_TWO_42                  ;program menu 42 = STAK1 function 6 = ENTER4
              DC.W key42_TWO_exit                ;program menu 43 = STAK2 function 6 
              
key42_TWO_0:  MOVB #$7A,0,Y                      ;(prgCounter) = 122 (END)
              BRA key42_TWO_exit

key42_TWO_1:  MOVB #$7C,0,Y                      ;(prgCounter) = 124 (TOF)
              BRA key42_TWO_exit

key42_TWO_4:  MOVB #$F5,0,Y                      ;(prgCounter) = 245 (GOTO>)
              BRA key42_TWO_exit

key42_TWO_5:  MOVB #$FB,0,Y                      ;(prgCounter) = 251 (GOTONEx(K))
              BRA key42_TWO_exit

key42_TWO_7:  MOVB #$C7,0,Y                      ;(prgCounter) = 199 (->xy)
              BRA key42_TWO_exit

key42_TWO_11: MOVB #$D9,0,Y                      ;(prgCounter) = 217 (2^x)
              BRA key42_TWO_exit

key42_TWO_19: MOVB #$BE,0,Y                      ;(prgCounter) = 190 ( arctanh x)
              BRA key42_TWO_exit

key42_TWO_35: MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter
              
              MOVB #$05,0,Y                      ;(prgCounter + 1) = $05 (set CPX mode)              
              
              BRA key42_TWO_exit

key42_TWO_42: MOVB #$AB,0,Y                      ;(prgCounter) = 171 (ENTER4)                                                               
                                                 
key42_TWO_exit:
              RTC

;Key43_TWO: MK5 program edit menu;;;;;;;;;;;;;;;;; 

key43_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag 

              CLRA

              LDAB menu
              ADDB menu                              

              LDX #PMK5Table     

              JMP [D,X]

PMK5Table     DC.W key43_TWO_0                   ;program menu0 = DEL                          
              DC.W key43_TWO_1                   ;program menu1 = TON 
              DC.W key43_TWO_exit                ;program menu2  
              DC.W key43_TWO_exit                ;program menu3 
              DC.W key43_TWO_4                   ;program menu4 = GOTOIFNE
              DC.W key43_TWO_5                   ;program menu5 = GOTOIF=x(K)
              DC.W key43_TWO_exit                ;program menu6 
              DC.W key43_TWO_7                   ;program menu7 = ->r,theta
              DC.W key43_TWO_exit                ;program menu 8
              DC.W key43_TWO_exit                ;program menu 9 = ASM1 function 5                                  
              DC.W key43_TWO_exit                ;program menu 10 = ASM2 function 5
              DC.W key43_TWO_11                  ;program menu 11 = NUM1 function 5 = LCM                                   
              DC.W key43_TWO_exit                ;program menu 12 = NUM2 function 5                                  
              DC.W key43_TWO_exit                ;program menu 13 = POL1 function 5                                  
              DC.W key43_TWO_exit                ;program menu 14 = POL2 function 5                                  
              DC.W key43_TWO_exit                ;program menu 15 = CAL1 function 5                                  
              DC.W key43_TWO_exit                ;program menu 16 = CAL2 function 5                                   
              DC.W key43_TWO_exit                ;program menu 17 = OPRE1 function 5                                  
              DC.W key43_TWO_exit                ;program menu 18 = OPRE2 function 5                                   
              DC.W key43_TWO_19                  ;program menu 19 = FUNC1 function 5 = arccosh x                                    
              DC.W key43_TWO_exit                ;program menu 20 = FUNC2 function 5                                  
              DC.W key43_TWO_exit                ;program menu 21 = FINA1 function 5                                   
              DC.W key43_TWO_exit                ;program menu 22 = FINA2 function 5
              DC.W key43_TWO_exit                ;program menu 23 = PRO1 function 5                                   
              DC.W key43_TWO_exit                ;program menu 24 = PRO2 function 5
              DC.W key43_TWO_25                  ;program menu 25 = STAT1 function 5 = mean of x 
              DC.W key43_TWO_exit                ;program menu 26 = STAT2 function 5
              DC.W key43_TWO_exit                ;program menu 27 = MATR1 function 5
              DC.W key43_TWO_exit                ;program menu 28 = MATR2 function 5
              DC.W key43_TWO_exit                ;program menu 29 = GRPH1 function 5
              DC.W key43_TWO_exit                ;program menu 30 = GRPH2 function 5
              DC.W key43_TWO_exit                ;program menu 31 = APP1 function 5
              DC.W key43_TWO_exit                ;program menu 32 = APP2 function 5
              DC.W key43_TWO_exit                ;program menu 33 = SYSPrg1 function 5
              DC.W key43_TWO_exit                ;program menu 34 = SYSPrg2 function 5
              DC.W key43_TWO_35                  ;program menu 35 = MODEPrg1 function 5 = set exact (=) mode
              DC.W key43_TWO_exit                ;program menu 36 = MODEPrg2 function 5
              DC.W key43_TWO_exit                ;program menu 37 = MODEPrg3 function 5
              DC.W key43_TWO_exit                ;program menu 38 = EQN1 function 5
              DC.W key43_TWO_exit                ;program menu 39 = EQN2 function 5
              DC.W key43_TWO_exit                ;program menu 40 = BIN1 function 5
              DC.W key43_TWO_exit                ;program menu 41 = BIN2 function 5
              DC.W key43_TWO_40                  ;program menu 42 = STAK1 function 5 = ENTER3
              DC.W key43_TWO_exit                ;program menu 43 = STAK2 function 5              

key43_TWO_0:  LDD prgCounter                     ;delete the previous program instruction
              CPD #ps_start
              BEQ key43_TWO_exit                 ;exit if prgCounter = ps_start

              SUBD #$0001                        ;otherwise decrement the prgCounter
              STD prgCounter
              
              LDX prgCounter
              LDAA #noOperation
              STAA 0,X                           ;(prgCounter) = NOP
              
              BCLR flag5,#BIT3                   ;do not increment prgCounter

              BRA key43_TWO_exit
              
key43_TWO_1:  MOVB #$7B,0,Y                      ;(prgCounter) = 123 (TON)
              BRA key43_TWO_exit
              
key43_TWO_4:  MOVB #$F4,0,Y                      ;(prgCounter) = 244 (GOTOIFNE)
              BRA key43_TWO_exit
              
key43_TWO_5:  MOVB #$FA,0,Y                      ;(prgCounter) = 250 (GOTOIF=x(K))
              BRA key43_TWO_exit
              
key43_TWO_7:  MOVB #$A8,0,Y                      ;(prgCounter) = 168 (->r,theta)
              BRA key43_TWO_exit
              
key43_TWO_11: MOVB #$CA,0,Y                      ;(prgCounter) = 202 (LCM)
              BRA key43_TWO_exit
              
key43_TWO_19: MOVB #$BD,0,Y                      ;(prgCounter) = 189 (arccosh x)
              BRA key43_TWO_exit
              
key43_TWO_25: MOVB #$C8,0,Y                      ;(prgCounter) = 200 (mean of x)
              BRA key43_TWO_exit              
              
key43_TWO_35: MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter
              
              MOVB #$04,0,Y                      ;(prgCounter + 1) = $04 (set = mode)
              
              BRA key43_TWO_exit

key43_TWO_40: MOVB #$A9,0,Y                      ;(prgCounter) = 169 (ENTER3)
              
key43_TWO_exit:
              RTC

;Key44_TWO: MK4 program edit mode;;;;;;;;;;;;;;;;; 

key44_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag 

              CLRA

              LDAB menu
              ADDB menu                              

              LDX #PMK4Table     

              JMP [D,X]

PMK4Table     DC.W key44_TWO_0                   ;program menu0 = CDE                          
              DC.W key44_TWO_1                   ;program menu1 = KN-> 
              DC.W key44_TWO_exit                ;program menu2 
              DC.W key44_TWO_exit                ;program menu3 
              DC.W key44_TWO_4                   ;program menu4 = GOTOIFE
              DC.W key44_TWO_5                   ;program menu5 = GOTOIFKP
              DC.W key44_TWO_exit                ;program menu6 
              DC.W key44_TWO_7                   ;program menu7 = |Z|
              DC.W key44_TWO_exit                ;program menu 8
              DC.W key44_TWO_exit                ;program menu 9 = ASM1 function 4                                  
              DC.W key44_TWO_exit                ;program menu 10 = ASM2 function 4
              DC.W key44_TWO_11                  ;program menu 11 = NUM1 function 4 = GCD                                  
              DC.W key44_TWO_exit                ;program menu 12 = NUM2 function 4                                  
              DC.W key44_TWO_exit                ;program menu 13 = POL1 function 4                                  
              DC.W key44_TWO_exit                ;program menu 14 = POL2 function 4                                  
              DC.W key44_TWO_exit                ;program menu 15 = CAL1 function 4                                  
              DC.W key44_TWO_exit                ;program menu 16 = CAL2 function 4                                   
              DC.W key44_TWO_exit                ;program menu 17 = OPRE1 function 4                                  
              DC.W key44_TWO_exit                ;program menu 18 = OPRE2 function 4                                   
              DC.W key44_TWO_19                  ;program menu 19 = FUNC1 function 4 = arcsinh x                                    
              DC.W key44_TWO_exit                ;program menu 20 = FUNC2 function 4                                  
              DC.W key44_TWO_exit                ;program menu 21 = FINA1 function 4                                   
              DC.W key44_TWO_exit                ;program menu 22 = FINA2 function 4
              DC.W key44_TWO_exit                ;program menu 23 = PRO1 function 4                                   
              DC.W key44_TWO_exit                ;program menu 24 = PRO2 function 4
              DC.W key44_TWO_25                  ;program menu 25 = STAT1 function 4 = y(K)-> 
              DC.W key44_TWO_exit                ;program menu 26 = STAT2 function 4
              DC.W key44_TWO_exit                ;program menu 27 = MATR1 function 4
              DC.W key44_TWO_exit                ;program menu 28 = MATR2 function 4
              DC.W key44_TWO_exit                ;program menu 29 = GRPH1 function 4
              DC.W key44_TWO_exit                ;program menu 30 = GRPH2 function 4
              DC.W key44_TWO_exit                ;program menu 31 = APP1 function 4
              DC.W key44_TWO_exit                ;program menu 32 = APP2 function 4
              DC.W key44_TWO_exit                ;program menu 33 = SYSPrg1 function 4
              DC.W key44_TWO_exit                ;program menu 34 = SYSPrg2 function 4
              DC.W key44_TWO_35                  ;program menu 35 = MODEPrg1 function 4 = set ~ mode
              DC.W key44_TWO_exit                ;program menu 36 = MODEPrg2 function 4
              DC.W key44_TWO_exit                ;program menu 37 = MODEPrg3 function 4
              DC.W key44_TWO_exit                ;program menu 38 = EQN1 function 4
              DC.W key44_TWO_exit                ;program menu 39 = EQN2 function 4
              DC.W key44_TWO_exit                ;program menu 40 = BIN1 function 4
              DC.W key44_TWO_exit                ;program menu 41 = BIN2 function 4
              DC.W key44_TWO_40                  ;program menu 42 = STAK1 function 4 = ENTER2
              DC.W key44_TWO_exit                ;program menu 43 = STAK2 function 4
              
key44_TWO_0:  BRA key44_TWO_exit                 ;(prgCounter) = future implementation (CDE)              
              
key44_TWO_1:  MOVB #$B7,0,Y                      ;(prgCounter) = 183 (KN->)
              BRA key44_TWO_exit
                        
key44_TWO_4:  MOVB #$F3,0,Y                      ;(prgCounter) = 243 (GOTOIFE)
              BRA key44_TWO_exit
              
key44_TWO_5:  MOVB #$F9,0,Y                      ;(prgCounter) = 249 (GOTOIFKP)
              BRA key44_TWO_exit
              
key44_TWO_7:  MOVB #$7D,0,Y                      ;(prgCounter) = 125 (|Z|)
              BRA key44_TWO_exit
              
key44_TWO_11: MOVB #$C9,0,Y                      ;(prgCounter) = 201 (GCD)
              BRA key44_TWO_exit
              
key44_TWO_19: MOVB #$BC,0,Y                      ;(prgCounter) = 188 (arcsinh x)
              BRA key44_TWO_exit
              
key44_TWO_25: MOVB #$DC,0,Y                      ;(prgCounter) = 220 (y(K)->)
              BRA key44_TWO_exit 
              
key44_TWO_35: MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter
              
              MOVB #$03,0,Y                      ;(prgCounter + 1) = $03 (set ~ mode)
              
              BRA key44_TWO_exit

key44_TWO_40: MOVB #$A6,0,Y                      ;(prgCounter) = 166 (ENTER2)

key44_TWO_exit:
              RTC

;Key45_TWO: MK3 program edit mode;;;;;;;;;;;;;;;;; 

key45_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag 

              CLRA

              LDAB menu
              ADDB menu                              

              LDX #PMK3Table     

              JMP [D,X]

PMK3Table     DC.W key45_TWO_0                   ;program menu0 = RFS                          
              DC.W key45_TWO_1                   ;program menu1 = SCN 
              DC.W key45_TWO_exit                ;program menu2  
              DC.W key45_TWO_exit                ;program menu3 
              DC.W key45_TWO_4                   ;program menu4 = GOTOIFNE0
              DC.W key45_TWO_5                   ;program menu5 = GOTOIF<=
              DC.W key45_TWO_6                   ;program menu6 = GOTOIFCOMLEMP 
              DC.W key45_TWO_7                   ;program menu7 = complement of Z
              DC.W key45_TWO_exit                ;program menu8
              DC.W key45_TWO_exit                ;program menu9 = ASM1 function 3                                  
              DC.W key45_TWO_exit                ;program menu10 = ASM2 function 3
              DC.W key45_TWO_11                  ;program menu11 = NUM1 function 3 = ceiling x                                 
              DC.W key45_TWO_exit                ;program menu12 = NUM2 function 3                                  
              DC.W key45_TWO_exit                ;program menu13 = POL1 function 3                                  
              DC.W key45_TWO_exit                ;program menu14 = POL2 function 3                                  
              DC.W key45_TWO_exit                ;program menu15 = CAL1 function 3                                  
              DC.W key45_TWO_exit                ;program menu16 = CAL2 function 3                                   
              DC.W key45_TWO_exit                ;program menu17 = OPRE1 function 3                                  
              DC.W key45_TWO_exit                ;program menu18 = OPRE2 function 3                                   
              DC.W key45_TWO_19                  ;program menu19 = FUNC1 function 3 = tanh x                                    
              DC.W key45_TWO_exit                ;program menu20 = FUNC2 function 3                                  
              DC.W key45_TWO_exit                ;program menu21 = FINA1 function 3                                   
              DC.W key45_TWO_exit                ;program menu22 = FINA2 function 3
              DC.W key45_TWO_exit                ;program menu23 = PRO1 function 3                                   
              DC.W key45_TWO_exit                ;program menu24 = PRO2 function 3
              DC.W key45_TWO_25                  ;program menu25 = STAT1 function 3 = x(K)-> 
              DC.W key45_TWO_exit                ;program menu26 = STAT2 function 3
              DC.W key45_TWO_exit                ;program menu27 = MATR1 function 3
              DC.W key45_TWO_exit                ;program menu28 = MATR2 function 3
              DC.W key45_TWO_exit                ;program menu29 = GRPH1 function 3
              DC.W key45_TWO_exit                ;program menu30 = GRPH2 function 3
              DC.W key45_TWO_exit                ;program menu31 = APP1 function 3
              DC.W key45_TWO_exit                ;program menu32 = APP2 function 3
              DC.W key45_TWO_exit                ;program menu33 = SYSPrg1 function 3
              DC.W key45_TWO_exit                ;program menu34 = SYSPrg2 function 3
              DC.W key45_TWO_35                  ;program menu35 = MODEPrg1 function 3 = set GRAD mode
              DC.W key45_TWO_36                  ;program menu36 = MODEPrg2 function 3 = display "ERROR"
              DC.W key45_TWO_exit                ;program menu37 = MODEPrg3 function 3
              DC.W key45_TWO_exit                ;program menu38 = EQN1 function 3
              DC.W key45_TWO_exit                ;program menu39 = EQN2 function 3
              DC.W key45_TWO_exit                ;program menu40 = BIN1 function 3
              DC.W key45_TWO_exit                ;program menu41 = BIN2 function 3
              DC.W key45_TWO_40                  ;program menu42 = STAK1 function 3 = OVER
              DC.W key45_TWO_41                  ;program menu43 = STAK2 function 3 = DELETE3

key45_TWO_0:  MOVB #$C0,0,Y                      ;(prgCounter) = 192 (RFS)
              BRA key45_TWO_exit                               
              
key45_TWO_1:  MOVB #$B6,0,Y                      ;(prgCounter) = 182 (SCN)
              BRA key45_TWO_exit
              
key45_TWO_4:  MOVB #$F2,0,Y                      ;(prgCounter) = 242 (GOTOIFNE0)
              BRA key45_TWO_exit
              
key45_TWO_5:  MOVB #$F8,0,Y                      ;(prgCounter) = 248 (GOTOIF<=)
              BRA key45_TWO_exit
              
key45_TWO_6:  MOVB #$FE,0,Y                      ;(prgCounter) = 254 (GOTOIFCOMLEMP)
              BRA key45_TWO_exit
              
key45_TWO_7:  MOVB #$82,0,Y                      ;(prgCounter) = 130 (complement of Z)
              BRA key45_TWO_exit
              
key45_TWO_11: MOVB #$C5,0,Y                      ;(prgCounter) = 197 (ceiling x)
              BRA key45_TWO_exit
              
key45_TWO_19: MOVB #$BB,0,Y                      ;(prgCounter) = 187 (tanh x)
              BRA key45_TWO_exit
              
key45_TWO_25: MOVB #$AD,0,Y                      ;(prgCounter) = 173 (x(K)->)
              BRA key45_TWO_exit
              
key45_TWO_35: MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter
              
              MOVB #$02,0,Y                      ;(prgCounter + 1) = $02 (set GRAD mode)
              
              BRA key45_TWO_exit

key45_TWO_36: MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter
              
              MOVB #$08,0,Y                      ;(prgCounter + 1) = $08 (display "ERROR")
              
              BRA key45_TWO_exit

key45_TWO_40: MOVB #$A7,0,Y                      ;(prgCounter) = 167 (OVER)
              BRA key45_TWO_exit
              
key45_TWO_41: MOVB #$A5,0,Y                      ;(prgCounter) = 165 (DELETE3)

key45_TWO_exit:
              RTC

;Key46_TWO: MK2 program edit mode;;;;;;;;;;;;;;;;; 

key46_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag 

              CLRA

              LDAB menu
              ADDB menu                              

              LDX #PMK2Table     

              JMP [D,X]

PMK2Table     DC.W key46_TWO_0                   ;program menu0 = JTS                          
              DC.W key46_TWO_1                   ;program menu1 = HALT 
              DC.W key46_TWO_2                   ;program menu2 = DECK 
              DC.W key46_TWO_3                   ;program menu3 = DPL
              DC.W key46_TWO_4                   ;program menu4 = GOTOIFE0
              DC.W key46_TWO_5                   ;program menu5 = GOTOIF>=
              DC.W key46_TWO_6                   ;program menu6 = GOTOIF<=x(K)
              DC.W key46_TWO_7                   ;program menu7 = C->R
              DC.W key46_TWO_exit                ;program menu8
              DC.W key46_TWO_exit                ;program menu9 = ASM1 function 2                                  
              DC.W key46_TWO_exit                ;program menu10 = ASM2 function 2
              DC.W key46_TWO_11                  ;program menu11 = NUM1 function 2 = floor x                                 
              DC.W key46_TWO_exit                ;program menu12 = NUM2 function 2                                  
              DC.W key46_TWO_exit                ;program menu13 = POL1 function 2                                  
              DC.W key46_TWO_exit                ;program menu14 = POL2 function 2                                  
              DC.W key46_TWO_exit                ;program menu15 = CAL1 function 2                                  
              DC.W key46_TWO_exit                ;program menu16 = CAL2 function 2                                   
              DC.W key46_TWO_exit                ;program menu17 = OPRE1 function 2                                  
              DC.W key46_TWO_exit                ;program menu18 = OPRE2 function 2                                   
              DC.W key46_TWO_19                  ;program menu19 = FUNC1 function 2 = cosh x                                    
              DC.W key46_TWO_exit                ;program menu20 = FUNC2 function 2                                  
              DC.W key46_TWO_exit                ;program menu21 = FINA1 function 2                                   
              DC.W key46_TWO_exit                ;program menu22 = FINA2 function 2
              DC.W key46_TWO_exit                ;program menu23 = PRO1 function 2                                   
              DC.W key46_TWO_exit                ;program menu24 = PRO2 function 2
              DC.W key46_TWO_25                  ;program menu25 = STAT1 function 2 = ->y(K) 
              DC.W key46_TWO_exit                ;program menu26 = STAT2 function 2
              DC.W key46_TWO_exit                ;program menu27 = MATR1 function 2
              DC.W key46_TWO_exit                ;program menu28 = MATR2 function 2
              DC.W key46_TWO_exit                ;program menu29 = GRPH1 function 2
              DC.W key46_TWO_exit                ;program menu30 = GRPH2 function 2
              DC.W key46_TWO_exit                ;program menu31 = APP1 function 2
              DC.W key46_TWO_exit                ;program menu32 = APP2 function 2
              DC.W key46_TWO_exit                ;program menu33 = SYSPrg1 function 2
              DC.W key46_TWO_exit                ;program menu34 = SYSPrg2 function 2
              DC.W key46_TWO_35                  ;program menu35 = MODEPrg1 function 2 = set RAD mode
              DC.W key46_TWO_36                  ;program menu36 = MODEPrg2 function 2 = FIX
              DC.W key46_TWO_exit                ;program menu37 = MODEPrg3 function 2
              DC.W key46_TWO_exit                ;program menu38 = EQN1 function 2
              DC.W key46_TWO_exit                ;program menu39 = EQN2 function 2
              DC.W key46_TWO_exit                ;program menu40 = BIN1 function 2
              DC.W key46_TWO_exit                ;program menu41 = BIN2 function 2
              DC.W key46_TWO_40                  ;program menu42 = STAK1 function 2 = UNROTATE
              DC.W key46_TWO_41                  ;program menu43 = STAK2 function 2 = DELETE2

key46_TWO_0:  MOVB #$FF,0,Y                      ;(prgCounter) = 255 (JTS)
              BRA key46_TWO_exit                               
              
key46_TWO_1:  MOVB #$B0,0,Y                      ;(prgCounter) = 176 (HALT)
              BRA key46_TWO_exit
              
key46_TWO_2:  MOVB #$AF,0,Y                      ;(prgCounter) = 175 (DECK)
              BRA key46_TWO_exit
              
key46_TWO_3:  CALL dcplProg                      ;convert offsets to keystroke numbers

              BCLR flag5,#BIT3                   ;do not increment prgCounter
              
              BRA key46_TWO_exit             

key46_TWO_4:  MOVB #$F1,0,Y                      ;(prgCounter) = 241(GOTOIFE0)
              BRA key46_TWO_exit
              
key46_TWO_5:  MOVB #$F7,0,Y                      ;(prgCounter) = 247 (GOTOIF>=)
              BRA key46_TWO_exit
              
key46_TWO_6:  MOVB #$FD,0,Y                      ;(prgCounter) = 253 (GOTOIF<=x(K))
              BRA key46_TWO_exit
              
key46_TWO_7:  MOVB #$C6,0,Y                      ;(prgCounter) = 198 (C->R)
              BRA key46_TWO_exit
              
key46_TWO_11: MOVB #$BF,0,Y                      ;(prgCounter) = 191 (floor x)
              BRA key46_TWO_exit
              
key46_TWO_19: MOVB #$BA,0,Y                      ;(prgCounter) = 186 (cosh x)
              BRA key46_TWO_exit
              
key46_TWO_25: MOVB #$DB,0,Y                      ;(prgCounter) = 219 (->y(K))
              BRA key46_TWO_exit
              
key46_TWO_35: MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter
              
              MOVB #$01,0,Y                      ;(prgCounter + 1) = $01 (set RAD mode)
              
              BRA key46_TWO_exit 

key46_TWO_36: MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter
              
              MOVB #$07,0,Y                      ;(prgCounter + 1) = $07 (FIX)
              
              BRA key46_TWO_exit

key46_TWO_40: MOVB #$A4,0,Y                      ;(prgCounter) = 164 (UNROTATE)
              BRA key46_TWO_exit
              
key46_TWO_41: MOVB #$A3,0,Y                      ;(prgCounter) = 163 (DELETE2)

key46_TWO_exit:
              RTC

;Key47_TWO: MK1 program edit mode;;;;;;;;;;;;;;;;;

key47_TWOSUB: BCLR flag3,#BIT4                   ;clear the sto flag
              BCLR flag3,#BIT1                   ;clear the rcl flag 

              CLRA

              LDAB menu
              ADDB menu                              

              LDX #PMK1Table     

              JMP [D,X]

PMK1Table     DC.W key47_TWO_0                   ;program menu0 = BRA folder                          
              DC.W key47_TWO_1                   ;program menu1 = DELAY K 
              DC.W key47_TWO_2                   ;program menu2 = INCK 
              DC.W key47_TWO_3                   ;program menu3 = CPL
              DC.W key47_TWO_4                   ;program menu4 = GOTO
              DC.W key47_TWO_5                   ;program menu5 = GOTOIF<
              DC.W key47_TWO_6                   ;program menu6 = GOTOIF>=x(K)
              DC.W key47_TWO_7                   ;program menu7 = R->C
              DC.W key47_TWO_exit                ;program menu8
              DC.W key47_TWO_exit                ;program menu9 = ASM1 function 1                                  
              DC.W key47_TWO_exit                ;program menu10 = ASM2 function 1
              DC.W key47_TWO_11                  ;program menu11 = NUM1 function 1 = |x|                                 
              DC.W key47_TWO_12                  ;program menu12 = NUM2 function 1 = ldx                                  
              DC.W key47_TWO_exit                ;program menu13 = POL1 function 1                                  
              DC.W key47_TWO_exit                ;program menu14 = POL2 function 1                                  
              DC.W key47_TWO_exit                ;program menu15 = CAL1 function 1                                  
              DC.W key47_TWO_exit                ;program menu16 = CAL2 function 1                                   
              DC.W key47_TWO_exit                ;program menu17 = OPRE1 function 1                                  
              DC.W key47_TWO_exit                ;program menu18 = OPRE2 function 1                                   
              DC.W key47_TWO_19                  ;program menu19 = FUNC1 function 1 = sinh x                                    
              DC.W key47_TWO_exit                ;program menu20 = FUNC2 function 1                                  
              DC.W key47_TWO_exit                ;program menu21 = FINA1 function 1                                   
              DC.W key47_TWO_exit                ;program menu22 = FINA2 function 1
              DC.W key47_TWO_exit                ;program menu23 = PRO1 function 1                                   
              DC.W key47_TWO_exit                ;program menu24 = PRO2 function 1
              DC.W key47_TWO_25                  ;program menu25 = STAT1 function 1 = ->x(K) 
              DC.W key47_TWO_exit                ;program menu26 = STAT2 function 1
              DC.W key47_TWO_exit                ;program menu27 = MATR1 function 1
              DC.W key47_TWO_exit                ;program menu28 = MATR2 function 1
              DC.W key47_TWO_exit                ;program menu29 = GRPH1 function 1
              DC.W key47_TWO_exit                ;program menu30 = GRPH2 function 1
              DC.W key47_TWO_exit                ;program menu31 = APP1 function 1
              DC.W key47_TWO_exit                ;program menu32 = APP2 function 1
              DC.W key47_TWO_exit                ;program menu33 = SYSPrg1 function 1
              DC.W key47_TWO_exit                ;program menu34 = SYSPrg2 function 1
              DC.W key47_TWO_35                  ;program menu35 = MODEPrg1 function 1 = set DEG mode
              DC.W key47_TWO_36                  ;program menu36 = MODEPrg2 function 1 = set ENG mode
              DC.W key47_TWO_exit                ;program menu37 = MODEPrg3 function 1
              DC.W key47_TWO_exit                ;program menu38 = EQN1 function 1
              DC.W key47_TWO_exit                ;program menu39 = EQN2 function 1
              DC.W key47_TWO_exit                ;program menu40 = BIN1 function 1
              DC.W key47_TWO_exit                ;program menu41 = BIN2 function 1
              DC.W key47_TWO_40                  ;program menu42 = STAK1 function 1 = ROTATE
              DC.W key47_TWO_41                  ;program menu43 = STAK2 function 1 = DEPTH
              
key47_TWO_0:  MOVB #$04,menu                     ;BRA folder

              BCLR flag5,#BIT3                   ;do not increment prgCounter
              
              BRA key47_TWO_exit                               
              
key47_TWO_1:  MOVB #$B1,0,Y                      ;(prgCounter) = 177 (DELAY K)
              BRA key47_TWO_exit
              
key47_TWO_2:  MOVB #$AE,0,Y                      ;(prgCounter) = 174 (INCK)
              BRA key47_TWO_exit
              
key47_TWO_3:  CALL cplProg                       ;convert keystroke numbers to offsets 

              BCLR flag5,#BIT3                   ;do not increment prgCounter
              
              BRA key47_TWO_exit

key47_TWO_4:  MOVB #$F0,0,Y                      ;(prgCounter) = 240 (GOTO)
              BRA key47_TWO_exit
              
key47_TWO_5:  MOVB #$F6,0,Y                      ;(prgCounter) = 246 (GOTOIF<)
              BRA key47_TWO_exit
              
key47_TWO_6:  MOVB #$FC,0,Y                      ;(prgCounter) = 252 (GOTOIF>=x(K))
              BRA key47_TWO_exit
              
key47_TWO_7:  MOVB #$81,0,Y                      ;(prgCounter) = 129 (R->C)
              BRA key47_TWO_exit
              
key47_TWO_11: MOVB #$C1,0,Y                      ;(prgCounter) = 193 (|x|)
              BRA key47_TWO_exit
              
key47_TWO_12: MOVB #$DA,0,Y                      ;(prgCounter) = 218 (ldx)
              BRA key47_TWO_exit              
              
key47_TWO_19: MOVB #$B9,0,Y                      ;(prgCounter) = 185 (sinh x)
              BRA key47_TWO_exit
              
key47_TWO_25: MOVB #$AC,0,Y                      ;(prgCounter) = 172 (->x(K))
              BRA key47_TWO_exit
              
key47_TWO_35: MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter
              
              MOVB #$00,0,Y                      ;(prgCounter + 1) = $00 (set DEG mode)              
              
              BRA key47_TWO_exit

key47_TWO_36: MOVB #$EF,0,Y                      ;(prgCounter) = $EF 

              JSR incPrgStep
              
              LDY prgCounter
              
              MOVB #$06,0,Y                      ;(prgCounter + 1) = $06 (set ENG mode)
              
              BRA key47_TWO_exit

key47_TWO_40: MOVB #$A2,0,Y                      ;(prgCounter) = 162 (ROTATE)
              BRA key47_TWO_exit
              
key47_TWO_41: MOVB #$AA,0,Y                      ;(prgCounter) = 170 (DEPTH)

key47_TWO_exit:
              RTC
             
;Key12S_TWO:STO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key12S_TWOSUB:
              BRSET flag3,#BIT4,key12S_TWOSUB_exit 
                                                 ;exit if sto flag is set

              BCLR flag4,#BIT6                   ;clear updtPrgScreen flag 
              
              LDX #Sto                          
              MOVB #$12,colNumber
              JSR dispStatLI2                    ;display "STO" on page 7
              
              BSET flag3,#BIT4                   ;set the sto flag

key12S_TWOSUB_exit:
              RTC              
 
;Key18S_TWO:RCL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

key18S_TWOSUB:
              BRSET flag3,#BIT1,key18S_TWOSUB_exit 
                                                 ;exit if rcl flag is set

              BCLR flag4,#BIT6                   ;clear updtPrgScreen flag 
              
              LDX #Rcl                          
              MOVB #$12,colNumber
              JSR dispStatLI2                    ;display "RCL" on page 7
              
              BSET flag3,#BIT1                   ;set the sto flag

key18S_TWOSUB_exit:
                                
              RTC              
             
;Key42S_TWO:shift MK6 program menu;;;;;;;;;;;;;;;;

key42S_TWOSUB:
              CLRA

              LDAB menu
              ASLB                              

              LDX #SPMK6Table     

              JMP [D,X]

SPMK6Table    DC.W key42S_TWO_exit               ;menu0 =                          
              DC.W key42S_TWO_exit               ;menu1 = 
              DC.W key42S_TWO_exit               ;menu2 = 
              DC.W key42S_TWO_exit               ;menu3 = 
              DC.W key42S_TWO_4                  ;menu4 = indirect GOTOIF>
              DC.W key42S_TWO_5                  ;menu5 = indirect GOTOIF<>x(K)
              DC.W key42S_TWO_exit               ;menu6 =                          
              DC.W key42S_TWO_exit               ;menu7 = 
              DC.W key42S_TWO_exit               ;menu8 = 
              DC.W key42S_TWO_exit               ;menu9 = 
              DC.W key42S_TWO_exit               ;menu10 = 
              DC.W key42S_TWO_exit               ;menu11 = 
              DC.W key42S_TWO_exit               ;menu12 =                          
              DC.W key42S_TWO_exit               ;menu13 = 
              DC.W key42S_TWO_exit               ;menu14 = 
              DC.W key42S_TWO_exit               ;menu15 = 
              DC.W key42S_TWO_exit               ;menu16 = 
              DC.W key42S_TWO_exit               ;menu17 = 
              DC.W key42S_TWO_exit               ;menu18 = 
              DC.W key42S_TWO_exit               ;menu19 = 
              DC.W key42S_TWO_exit               ;menu20 = 
              DC.W key42S_TWO_exit               ;menu21 =                          
              DC.W key42S_TWO_exit               ;menu22 = 
              DC.W key42S_TWO_exit               ;menu23 = 
              DC.W key42S_TWO_exit               ;menu24 = 
              DC.W key42S_TWO_exit               ;menu25 = 
              DC.W key42S_TWO_exit               ;menu26 = 
              DC.W key42S_TWO_exit               ;menu27 =                          
              DC.W key42S_TWO_exit               ;menu28 = 
              DC.W key42S_TWO_exit               ;menu29 = 
              DC.W key42S_TWO_exit               ;menu30 = 
              DC.W key42S_TWO_exit               ;menu31 = 
              DC.W key42S_TWO_exit               ;menu32 = 
              DC.W key42S_TWO_exit               ;menu33 = 
              DC.W key42S_TWO_exit               ;menu34 = 
              DC.W key42S_TWO_exit               ;menu35 =
              DC.W key42S_TWO_exit               ;menu36 =                          
              DC.W key42S_TWO_exit               ;menu37 = 
              DC.W key42S_TWO_exit               ;menu38 = 
              DC.W key42S_TWO_exit               ;menu39 = 
              DC.W key42S_TWO_exit               ;menu40 = 
              DC.W key42S_TWO_exit               ;menu41 = 
              DC.W key42S_TWO_exit               ;menu42 = 
              DC.W key42S_TWO_exit               ;menu43 =                 

key42S_TWO_4: MOVB #$D0,0,Y                      ;(prgCounter) = $D0 = 208 (indirect GOTOIF>)
              BRA key42S_TWO_exit
              
key42S_TWO_5: MOVB #$D6,0,Y                      ;(prgCounter) = $D6 = 214 (indirect GOTOIF<>x(K))
              
key42S_TWO_exit:
              RTC
              
;Key43S_TWO: shift MK5 program menu;;;;;;;;;;;;;;;

key43S_TWOSUB:

              CLRA

              LDAB menu
              ASLB                              

              LDX #SPMK5Table     

              JMP [D,X]

SPMK5Table    DC.W key43S_TWO_exit               ;menu0 =                          
              DC.W key43S_TWO_exit               ;menu1 = 
              DC.W key43S_TWO_exit               ;menu2 = 
              DC.W key43S_TWO_exit               ;menu3 = 
              DC.W key43S_TWO_4                  ;menu4 = indirect GOTOIF<>
              DC.W key43S_TWO_5                  ;menu5 = indirect GOTOIF=x(K)
              DC.W key43S_TWO_exit               ;menu6 =                          
              DC.W key43S_TWO_exit               ;menu7 = 
              DC.W key43S_TWO_exit               ;menu8 = 
              DC.W key43S_TWO_exit               ;menu9 = 
              DC.W key43S_TWO_exit               ;menu10 = 
              DC.W key43S_TWO_exit               ;menu11 = 
              DC.W key43S_TWO_exit               ;menu12 =                          
              DC.W key43S_TWO_exit               ;menu13 = 
              DC.W key43S_TWO_exit               ;menu14 = 
              DC.W key43S_TWO_exit               ;menu15 = 
              DC.W key43S_TWO_exit               ;menu16 = 
              DC.W key43S_TWO_exit               ;menu17 = 
              DC.W key43S_TWO_exit               ;menu18 = 
              DC.W key43S_TWO_exit               ;menu19 = 
              DC.W key43S_TWO_exit               ;menu20 = 
              DC.W key43S_TWO_exit               ;menu21 =                          
              DC.W key43S_TWO_exit               ;menu22 = 
              DC.W key43S_TWO_exit               ;menu23 = 
              DC.W key43S_TWO_exit               ;menu24 = 
              DC.W key43S_TWO_exit               ;menu25 = 
              DC.W key43S_TWO_exit               ;menu26 = 
              DC.W key43S_TWO_exit               ;menu27 =                          
              DC.W key43S_TWO_exit               ;menu28 = 
              DC.W key43S_TWO_exit               ;menu29 = 
              DC.W key43S_TWO_exit               ;menu30 = 
              DC.W key43S_TWO_exit               ;menu31 = 
              DC.W key43S_TWO_exit               ;menu32 = 
              DC.W key43S_TWO_exit               ;menu33 = 
              DC.W key43S_TWO_exit               ;menu34 = 
              DC.W key43S_TWO_exit               ;menu35 =
              DC.W key43S_TWO_exit               ;menu36 =                          
              DC.W key43S_TWO_exit               ;menu37 = 
              DC.W key43S_TWO_exit               ;menu38 = 
              DC.W key43S_TWO_exit               ;menu39 = 
              DC.W key43S_TWO_exit               ;menu40 = 
              DC.W key43S_TWO_exit               ;menu41 = 
              DC.W key43S_TWO_exit               ;menu42 = 
              DC.W key43S_TWO_exit               ;menu43 =                 

key43S_TWO_4: MOVB #$CF,0,Y                      ;(prgCounter) = $CF = 207 (indirect GOTOIF<>)
              BRA key43S_TWO_exit
              
key43S_TWO_5: MOVB #$D5,0,Y                      ;(prgCounter) = $D5 = 213 (indirect GOTOIF=x(K))
              
key43S_TWO_exit:
              RTC
              
;Key44S_TWO: shift MK4 program menu;;;;;;;;;;;;;;;

key44S_TWOSUB:      

              CLRA

              LDAB menu
              ASLB                              

              LDX #SPMK4Table     

              JMP [D,X]

SPMK4Table    DC.W key44S_TWO_exit               ;menu0 =                          
              DC.W key44S_TWO_exit               ;menu1 = 
              DC.W key44S_TWO_exit               ;menu2 = 
              DC.W key44S_TWO_exit               ;menu3 = 
              DC.W key44S_TWO_4                  ;menu4 = indirect GOTOIF=
              DC.W key44S_TWO_5                  ;menu5 = indirect GOTOIFKP
              DC.W key44S_TWO_exit               ;menu6 =                          
              DC.W key44S_TWO_exit               ;menu7 = 
              DC.W key44S_TWO_exit               ;menu8 = 
              DC.W key44S_TWO_exit               ;menu9 = 
              DC.W key44S_TWO_exit               ;menu10 = 
              DC.W key44S_TWO_exit               ;menu11 = 
              DC.W key44S_TWO_exit               ;menu12 =                          
              DC.W key44S_TWO_exit               ;menu13 = 
              DC.W key44S_TWO_exit               ;menu14 = 
              DC.W key44S_TWO_exit               ;menu15 = 
              DC.W key44S_TWO_exit               ;menu16 = 
              DC.W key44S_TWO_exit               ;menu17 = 
              DC.W key44S_TWO_exit               ;menu18 = 
              DC.W key44S_TWO_exit               ;menu19 = 
              DC.W key44S_TWO_exit               ;menu20 = 
              DC.W key44S_TWO_exit               ;menu21 =                          
              DC.W key44S_TWO_exit               ;menu22 = 
              DC.W key44S_TWO_exit               ;menu23 = 
              DC.W key44S_TWO_exit               ;menu24 = 
              DC.W key44S_TWO_exit               ;menu25 = 
              DC.W key44S_TWO_exit               ;menu26 = 
              DC.W key44S_TWO_exit               ;menu27 =                          
              DC.W key44S_TWO_exit               ;menu28 = 
              DC.W key44S_TWO_exit               ;menu29 = 
              DC.W key44S_TWO_exit               ;menu30 = 
              DC.W key44S_TWO_exit               ;menu31 = 
              DC.W key44S_TWO_exit               ;menu32 = 
              DC.W key44S_TWO_exit               ;menu33 = 
              DC.W key44S_TWO_exit               ;menu34 = 
              DC.W key44S_TWO_exit               ;menu35 =
              DC.W key44S_TWO_exit               ;menu36 =                          
              DC.W key44S_TWO_exit               ;menu37 = 
              DC.W key44S_TWO_exit               ;menu38 = 
              DC.W key44S_TWO_exit               ;menu39 = 
              DC.W key44S_TWO_exit               ;menu40 = 
              DC.W key44S_TWO_exit               ;menu41 = 
              DC.W key44S_TWO_exit               ;menu42 = 
              DC.W key44S_TWO_exit               ;menu43 =                 

key44S_TWO_4: MOVB #$CE,0,Y                      ;(prgCounter) = $CE = 206 (indirect GOTOIF=)
              BRA key44S_TWO_exit
              
key44S_TWO_5: MOVB #$D4,0,Y                      ;(prgCounter) = $D4 = 212 (indirect GOTOIFKP)
              
key44S_TWO_exit:
              RTC 
              
;Key45S_TWO: shift MK3 program menu;;;;;;;;;;;;;;;

key45S_TWOSUB:      

              CLRA

              LDAB menu
              ASLB                              

              LDX #SPMK3Table     

              JMP [D,X]

SPMK3Table    DC.W key45S_TWO_exit               ;menu0 =                          
              DC.W key45S_TWO_exit               ;menu1 = 
              DC.W key45S_TWO_exit               ;menu2 = 
              DC.W key45S_TWO_exit               ;menu3 = 
              DC.W key45S_TWO_4                  ;menu4 = indirect GOTOIF<>0
              DC.W key45S_TWO_5                  ;menu5 = indirect GOTOIF<=
              DC.W key45S_TWO_exit               ;menu6 =                          
              DC.W key45S_TWO_exit               ;menu7 = 
              DC.W key45S_TWO_exit               ;menu8 = 
              DC.W key45S_TWO_exit               ;menu9 = 
              DC.W key45S_TWO_exit               ;menu10 = 
              DC.W key45S_TWO_exit               ;menu11 = 
              DC.W key45S_TWO_exit               ;menu12 =                          
              DC.W key45S_TWO_exit               ;menu13 = 
              DC.W key45S_TWO_exit               ;menu14 = 
              DC.W key45S_TWO_exit               ;menu15 = 
              DC.W key45S_TWO_exit               ;menu16 = 
              DC.W key45S_TWO_exit               ;menu17 = 
              DC.W key45S_TWO_exit               ;menu18 = 
              DC.W key45S_TWO_exit               ;menu19 = 
              DC.W key45S_TWO_exit               ;menu20 = 
              DC.W key45S_TWO_exit               ;menu21 =                          
              DC.W key45S_TWO_exit               ;menu22 = 
              DC.W key45S_TWO_exit               ;menu23 = 
              DC.W key45S_TWO_exit               ;menu24 = 
              DC.W key45S_TWO_exit               ;menu25 = 
              DC.W key45S_TWO_exit               ;menu26 = 
              DC.W key45S_TWO_exit               ;menu27 =                          
              DC.W key45S_TWO_exit               ;menu28 = 
              DC.W key45S_TWO_exit               ;menu29 = 
              DC.W key45S_TWO_exit               ;menu30 = 
              DC.W key45S_TWO_exit               ;menu31 = 
              DC.W key45S_TWO_exit               ;menu32 = 
              DC.W key45S_TWO_exit               ;menu33 = 
              DC.W key45S_TWO_exit               ;menu34 = 
              DC.W key45S_TWO_exit               ;menu35 =
              DC.W key45S_TWO_exit               ;menu36 =                          
              DC.W key45S_TWO_exit               ;menu37 = 
              DC.W key45S_TWO_exit               ;menu38 = 
              DC.W key45S_TWO_exit               ;menu39 = 
              DC.W key45S_TWO_exit               ;menu40 = 
              DC.W key45S_TWO_exit               ;menu41 = 
              DC.W key45S_TWO_exit               ;menu42 = 
              DC.W key45S_TWO_exit               ;menu43 =                 

key45S_TWO_4: MOVB #$CD,0,Y                      ;(prgCounter) = $CD = 205 (indirect GOTOIF<>0)
              BRA key45S_TWO_exit
              
key45S_TWO_5: MOVB #$D3,0,Y                      ;(prgCounter) = $D3 = 211 (indirect GOTOIF<=)
              
key45S_TWO_exit:
              RTC
              
;Key46S_TWOSUB: shift MK2 program menu;;;;;;;;;;;;;;;

key46S_TWOSUB:     

              CLRA

              LDAB menu
              ASLB                              

              LDX #SPMK2Table     

              JMP [D,X]

SPMK2Table    DC.W key46S_TWO_exit               ;menu0 =                          
              DC.W key46S_TWO_exit               ;menu1 = 
              DC.W key46S_TWO_exit               ;menu2 = 
              DC.W key46S_TWO_exit               ;menu3 = 
              DC.W key46S_TWO_4                  ;menu4 = indirect GOTOIF=0
              DC.W key46S_TWO_5                  ;menu5 = indirect GOTOIF>=
              DC.W key46S_TWO_6                  ;menu6 = indirect GOTOIF<=x(K)                         
              DC.W key46S_TWO_exit               ;menu7 = 
              DC.W key46S_TWO_exit               ;menu8 = 
              DC.W key46S_TWO_exit               ;menu9 = 
              DC.W key46S_TWO_exit               ;menu10 = 
              DC.W key46S_TWO_exit               ;menu11 = 
              DC.W key46S_TWO_exit               ;menu12 =                          
              DC.W key46S_TWO_exit               ;menu13 = 
              DC.W key46S_TWO_exit               ;menu14 = 
              DC.W key46S_TWO_exit               ;menu15 = 
              DC.W key46S_TWO_exit               ;menu16 = 
              DC.W key46S_TWO_exit               ;menu17 = 
              DC.W key46S_TWO_exit               ;menu18 = 
              DC.W key46S_TWO_exit               ;menu19 = 
              DC.W key46S_TWO_exit               ;menu20 = 
              DC.W key46S_TWO_exit               ;menu21 =                          
              DC.W key46S_TWO_exit               ;menu22 = 
              DC.W key46S_TWO_exit               ;menu23 = 
              DC.W key46S_TWO_exit               ;menu24 = 
              DC.W key46S_TWO_exit               ;menu25 = 
              DC.W key46S_TWO_exit               ;menu26 = 
              DC.W key46S_TWO_exit               ;menu27 =                          
              DC.W key46S_TWO_exit               ;menu28 = 
              DC.W key46S_TWO_exit               ;menu29 = 
              DC.W key46S_TWO_exit               ;menu30 = 
              DC.W key46S_TWO_exit               ;menu31 = 
              DC.W key46S_TWO_exit               ;menu32 = 
              DC.W key46S_TWO_exit               ;menu33 = 
              DC.W key46S_TWO_exit               ;menu34 = 
              DC.W key46S_TWO_exit               ;menu35 =
              DC.W key46S_TWO_exit               ;menu36 =                          
              DC.W key46S_TWO_exit               ;menu37 = 
              DC.W key46S_TWO_exit               ;menu38 = 
              DC.W key46S_TWO_exit               ;menu39 = 
              DC.W key46S_TWO_exit               ;menu40 = 
              DC.W key46S_TWO_exit               ;menu41 = 
              DC.W key46S_TWO_exit               ;menu42 = 
              DC.W key46S_TWO_exit               ;menu43 =                 

key46S_TWO_4: MOVB #$CC,0,Y                      ;(prgCounter) = $CC = 204 (indirect GOTOIF=0)
              BRA key46S_TWO_exit
              
key46S_TWO_5: MOVB #$D2,0,Y                      ;(prgCounter) = $D2 = 210 (indirect GOTOIF>=)
              BRA key46S_TWO_exit
              
key46S_TWO_6: MOVB #$D8,0,Y                      ;(prgCounter) = $D8 = 216 (indirect GOTOIF<=x(K))              
              
key46S_TWO_exit:
              RTC
              
;Key47S_TWOSUB: shift MK1 program menu;;;;;;;;;;;;;;;

key47S_TWOSUB:     

              CLRA

              LDAB menu
              ASLB                              

              LDX #SPMK1Table     

              JMP [D,X]

SPMK1Table    DC.W key47S_TWO_exit               ;menu0 =                          
              DC.W key47S_TWO_exit               ;menu1 = 
              DC.W key47S_TWO_exit               ;menu2 = 
              DC.W key47S_TWO_exit               ;menu3 = 
              DC.W key47S_TWO_4                  ;menu4 = indirect GOTO
              DC.W key47S_TWO_5                  ;menu5 = indirect GOTOIF<
              DC.W key47S_TWO_6                  ;menu6 = indirect GOTOIF>=x(K)                         
              DC.W key47S_TWO_exit               ;menu7 = 
              DC.W key47S_TWO_exit               ;menu8 = 
              DC.W key47S_TWO_exit               ;menu9 = 
              DC.W key47S_TWO_exit               ;menu10 = 
              DC.W key47S_TWO_exit               ;menu11 = 
              DC.W key47S_TWO_exit               ;menu12 =                          
              DC.W key47S_TWO_exit               ;menu13 = 
              DC.W key47S_TWO_exit               ;menu14 = 
              DC.W key47S_TWO_exit               ;menu15 = 
              DC.W key47S_TWO_exit               ;menu16 = 
              DC.W key47S_TWO_exit               ;menu17 = 
              DC.W key47S_TWO_exit               ;menu18 = 
              DC.W key47S_TWO_exit               ;menu19 = 
              DC.W key47S_TWO_exit               ;menu20 = 
              DC.W key47S_TWO_exit               ;menu21 =                          
              DC.W key47S_TWO_exit               ;menu22 = 
              DC.W key47S_TWO_exit               ;menu23 = 
              DC.W key47S_TWO_exit               ;menu24 = 
              DC.W key47S_TWO_exit               ;menu25 = 
              DC.W key47S_TWO_exit               ;menu26 = 
              DC.W key47S_TWO_exit               ;menu27 =                          
              DC.W key47S_TWO_exit               ;menu28 = 
              DC.W key47S_TWO_exit               ;menu29 = 
              DC.W key47S_TWO_exit               ;menu30 = 
              DC.W key47S_TWO_exit               ;menu31 = 
              DC.W key47S_TWO_exit               ;menu32 = 
              DC.W key47S_TWO_exit               ;menu33 = 
              DC.W key47S_TWO_exit               ;menu34 = 
              DC.W key47S_TWO_exit               ;menu35 =
              DC.W key47S_TWO_exit               ;menu36 =                          
              DC.W key47S_TWO_exit               ;menu37 = 
              DC.W key47S_TWO_exit               ;menu38 = 
              DC.W key47S_TWO_exit               ;menu39 = 
              DC.W key47S_TWO_exit               ;menu40 = 
              DC.W key47S_TWO_exit               ;menu41 = 
              DC.W key47S_TWO_exit               ;menu42 = 
              DC.W key47S_TWO_exit               ;menu43 =                 

key47S_TWO_4: MOVB #$CB,0,Y                      ;(prgCounter) = $CB = 203 (indirect GOTO)
              BRA key47S_TWO_exit
              
key47S_TWO_5: MOVB #$D1,0,Y                      ;(prgCounter) = $D1 = 209 (indirect GOTOIF<)
              BRA key47S_TWO_exit
              
key47S_TWO_6: MOVB #$D7,0,Y                      ;(prgCounter) = $D7 = 215 (indirect GOTOIF>=x(K))              
              
key47S_TWO_exit:
              RTC

;*****Table used in MK6 toggle program menus******

NxtPrgMenu    DC.B $01, $02, $03, $00, $05, $06, $04, $08
              DC.B $07, $0A, $09, $0C, $0B, $0E, $0D, $10
              DC.B $0F, $12, $11, $14, $13, $16, $15, $18
              DC.B $17, $1A, $19, $1C, $1B, $1E, $1D, $20
              DC.B $1F, $22, $21, $24, $25, $23, $27, $26
              DC.B $29, $28, $2B, $2A 

;*********************PAGE_F8*********************Code to display programming instructions when in program edit mode
                                                  ;and instruction table                                                  
              ORG $F88000
              
;****************key functions 3******************
              
;Key0_THREE: display "+";;;;;;;;;;;;;;;;;;;;;;;;;;

key0_THREESUB:MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDX #Plus
              MOVB #wFont,colNumber              ;display "+"
              JSR sendData                     
              
              RTC 
              
;Key1_THREE: display "DELETE";;;;;;;;;;;;;;;;;;;;;

key1_THREESUB:   MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #Delete
              MOVB #$30,colNumber                ;display "DELETE"
              JSR sendData                     
              
              RTC
              
;Key2_THREE: display ".";;;;;;;;;;;;;;;;;;;;;;;;;;

key2_THREESUB:   MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDX #decPoint
              MOVB #wFont,colNumber              ;display "."
              JSR sendData                     
              
              RTC
              
;Key3_THREE: display "0";;;;;;;;;;;;;;;;;;;;;;;;;; 

key3_THREESUB:   MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDX #Digit
              
              MOVB #wFont,colNumber              ;display "0"
              JSR sendData                     
              
              RTC
              
;Key4_THREE: display "NEGATE";;;;;;;;;;;;;;;;;;;;;

key4_THREESUB:   
              MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #Neg
              MOVB #$30,colNumber                ;display "NEGATE"
              JSR sendData                     
              
              RTC 
              
;Key6_THREE: display "-";;;;;;;;;;;;;;;;;;;;;;;;;;

key6_THREESUB:   MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDX #Minus
              MOVB #wFont,colNumber              ;display "-"
              JSR sendData   

              RTC
              
;Key7_THREE: display "3";;;;;;;;;;;;;;;;;;;;;;;;;;

key7_THREESUB:   MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDAA #$03                          ;display "3"
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display digit
              JSR sendData                     
              
              RTC 
              
;Key8_THREE: display "2";;;;;;;;;;;;;;;;;;;;;;;;;; 

key8_THREESUB:   MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDAA #$02                          ;display "2"
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display digit
              JSR sendData                     
              
              RTC
              
;Key9_THREE: display "1";;;;;;;;;;;;;;;;;;;;;;;;;; 

key9_THREESUB:   MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDAA #$01                          ;display "1"
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display digit
              JSR sendData                     
              
              RTC
              
;Key10_THREE: display "EXP";;;;;;;;;;;;;;;;;;;;;;;

key10_THREESUB:  MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDX #Exp
              MOVB #$18,colNumber                ;display "EXP"
              JSR sendData                     
              
              RTC 

;Key12_THREE: display "*";;;;;;;;;;;;;;;;;;;;;;;;;

key12_THREESUB:  MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDX #MultS
              MOVB #wFont,colNumber              ;display "*"
              JSR sendData                     
              
              RTC

;Key13_THREE: display "6";;;;;;;;;;;;;;;;;;;;;;;;; 

key13_THREESUB:  MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDAA #$06                          ;display "6"
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display digit
              JSR sendData                     
              
              RTC 
              
;Key14_THREE: display "5";;;;;;;;;;;;;;;;;;;;;;;;;; 

key14_THREESUB:  MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDAA #$05                          ;display "5"
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display digit
              JSR sendData                     
              
              RTC 
              
;Key15_THREE: display "4";;;;;;;;;;;;;;;;;;;;;;;;;; 

key15_THREESUB:  MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDAA #$04                          ;display "4"
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display digit
              JSR sendData                     
              
              RTC
 
;Key16_THREE: display "ENTER";;;;;;;;;;;;;;;;;;;;;

key16_THREESUB:  MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #Enter
              MOVB #$28,colNumber                ;display "ENTER"
              JSR sendData                     
              
              RTC
              
;Key18_THREE: display "/";;;;;;;;;;;;;;;;;;;;;;;;;

key18_THREESUB:  MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDX #Div
              MOVB #wFont,colNumber              ;display "/"
              JSR sendData                     
              
              RTC
              
;Key19_THREE: display "9";;;;;;;;;;;;;;;;;;;;;;;;; 

key19_THREESUB:  MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDAA #$09                          ;display "9"
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display digit
              JSR sendData                     
              
              RTC      

;Key20_THREE: display "8";;;;;;;;;;;;;;;;;;;;;;;;; 

key20_THREESUB:  MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDAA #$08                          ;display "8"
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display digit
              JSR sendData                     
              
              RTC 
              
;Key21_THREE: display "7";;;;;;;;;;;;;;;;;;;;;;;;; 

key21_THREESUB:  MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDAA #$07                          ;display "7"
              LDAB #wFont
              MUL
              
              LDX #Digit
              ABX                                ;add B to X
              
              MOVB #wFont,colNumber              ;display digit
              JSR sendData                     
              
              RTC

;Key24_THREE: display "log x";;;;;;;;;;;;;;;;;;;;;

key24_THREESUB: MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #Lg
              MOVB #$28,colNumber                ;display "log x"
              JSR sendData                     
              
              RTC
               
;Key25_THREE: display "ln x";;;;;;;;;;;;;;;;;;;;;;

key25_THREESUB: MOVB #$60,Ycoord
              JSR setY                           ;Y = 96             
              
              LDX #Ln
              MOVB #$20,colNumber                ;display "ln x"
              JSR sendData                     
              
              RTC
                            
;Key26_THREE: display "Pi";;;;;;;;;;;;;;;;;;;;;;

key26_THREESUB:  MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDX #Pi
              MOVB #wFont,colNumber              ;display "Pi"
              JSR sendData                     
              
              RTC
              
;Key27_THREE: display "tan x";;;;;;;;;;;;;;;;;;;;;

key27_THREESUB:  MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #Tanx
              MOVB #$28,colNumber                ;display "tan x"
              JSR sendData                     
              
              RTC 
              
;Key28_THREE: display "cos x";;;;;;;;;;;;;;;;;;;;;

key28_THREESUB:  MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #Cosx
              MOVB #$28,colNumber                ;display "cos x"
              JSR sendData                     
              
              RTC
              
;Key29_THREE: display "sin x";;;;;;;;;;;;;;;;;;;;;

key29_THREESUB:  MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #Sinx
              MOVB #$28,colNumber                ;display "sin x"
              JSR sendData                     
              
              RTC
              
;Key30_THREE: display "1/x";;;;;;;;;;;;;;;;;;;;;;;

key30_THREESUB:  MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDX #OneX
              MOVB #$18,colNumber                ;display "1/x"
              JSR sendData                     
              
              RTC
              
;Key31_THREE: display x^y symbol;;;;;;;;;;;;;;;;;;

key31_THREESUB:  MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #Xy
              MOVB #$10,colNumber                              
              JSR sendData                       ;display x^y symbol                     
              
              RTC
              
;Key32_THREE: display square root symbol;;;;;;;;;;

key32_THREESUB:               
              MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #Sqrt
              MOVB #$10,colNumber                ;display square root symbol
              JSR sendData                     
              
              RTC 
              
;Key34_THREE: display "DECIMAL->DMS";;;;;;;;;;;;;;;

key34_THREESUB: MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
                   
              LDX #ToDMS
              MOVB #$42,colNumber
              JSR sendData                       ;display "DECIMAL->degree symbol ' " "

              RTC
              
;Key35_THREE: display "DMS->DECIMAL";;;;;;;;;;;;;;

key35_THREESUB: MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
                   
              LDX #DMSTo
              MOVB #$42,colNumber
              JSR sendData                       ;display "degree symbol ' "->DECIMAL"

              RTC          
              
;Key1S_THREE: display "CLEAR";;;;;;;;;;;;;;;;;;;;;

key1S_THREESUB:  MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #Clear
              MOVB #$28,colNumber                ;display "CLEAR"
              JSR sendData                     
              
              RTC
                   
;Key16S_THREE: display "SWAP";;;;;;;;;;;;;;;;;;;;;

key16S_THREESUB: MOVB #$60,Ycoord
              JSR setY                           ;Y = 96
              
              LDX #Swap
              MOVB #$20,colNumber                ;display "SWAP"
              JSR sendData                     
              
              RTC                   
         
;Key24S_THREE: display 10^x symbol;;;;;;;;;;;;;;;;

key24S_THREESUB:              
              MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDX #Tenx
              MOVB #$18,colNumber                ;display 10^x symbol 
              JSR sendData                     
              
              RTC
              
;Key25S_THREE: display e^x symbol;;;;;;;;;;;;;;;;;

key25S_THREESUB:               
              MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #Ex
              MOVB #$10,colNumber                ;display e^x symbol
              JSR sendData                     
              
              RTC

;Key26S_THREE: display "RANDOMNUMBER";;;;;;;;;;;;;

key26S_THREESUB: 
               MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #RND
              MOVB #$48,colNumber                ;display "RANDOMNUMBER"
              JSR sendData                     
              
              RTC
              
;Key27S_THREE: display symbol for arctan x;;;;;;;;

key27S_THREESUB: MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #Arctanx
              MOVB #$28,colNumber                ;display symbol for arctan x
              JSR sendData                     
              
              RTC 
              
;Key28S_THREE: display symbol for arccos x;;;;;;;;

key28S_THREESUB: MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #Arccosx
              MOVB #$28,colNumber                ;display symbol for arccos x
              JSR sendData                     
              
              RTC 
              
;Key29S_THREE: display symbol for arcsin x;;;;;;;;

key29S_THREESUB: MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #Arcsinx
              MOVB #$28,colNumber                ;display symbol for arcsin x
              JSR sendData                     
              
              RTC
              
;Key30S_THREE: display "!";;;;;;;;;;;;;;;;;;;;;;;;

key30S_THREESUB: MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDX #Fac
              MOVB #wFont,colNumber              ;display !
              JSR sendData                     
              
              RTC
              
;Key31S_THREE: display y^(1/x) symbol;;;;;;;;;;;;;;

key31S_THREESUB: MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
                                                                                           
              LDX #Y1x
              MOVB #$18,colNumber                                        
              JSR sendData                       ;display y^(1/x) symbol                     
              
              RTC
              
;Key32S_THREE: display x^2 symbol;;;;;;;;;;;;;;;;;

key32S_THREESUB:              
              MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #Sqr
              MOVB #$10,colNumber                ;display "x^2" symbol
              JSR sendData                     
              
              RTC   
                                         
;Key0T_THREE: display "Z->";;;;;;;;;;;;;;;;;;;;;;;

key0T_THREESUB:  MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclZ
              MOVB #$10,colNumber                ;display "Z->" 
              JSR sendData                     
              
              RTC
              
;Key1T_THREE: display "Y->";;;;;;;;;;;;;;;;;;;;;;;

key1T_THREESUB:  MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclY
              MOVB #$10,colNumber                ;display "Y->" 
              JSR sendData                     
              
              RTC
              
;Key2T_THREE: display "X->";;;;;;;;;;;;;;;;;;;;;;;

key2T_THREESUB:  MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclX
              MOVB #$10,colNumber                ;display "X->" 
              JSR sendData                     
              
              RTC
              
;Key3T_THREE: display "W->";;;;;;;;;;;;;;;;;;;;;;;

key3T_THREESUB:  MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclW
              MOVB #$10,colNumber                ;display "W->" 
              JSR sendData                     
              
              RTC
              
;Key4T_THREE: display "V->";;;;;;;;;;;;;;;;;;;;;;;

key4T_THREESUB:  MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclV
              MOVB #$10,colNumber                ;display "V->" 
              JSR sendData                     
              
              RTC
              
;Key6T_THREE: display "U->";;;;;;;;;;;;;;;;;;;;;;;

key6T_THREESUB:  MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclU
              MOVB #$10,colNumber                ;display "U->" 
              JSR sendData                     
              
              RTC
              
;Key7T_THREE: display "T->";;;;;;;;;;;;;;;;;;;;;;;

key7T_THREESUB:  MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclT
              MOVB #$10,colNumber                ;display "T->" 
              JSR sendData                     
              
              RTC
              
;Key8T_THREE: display "S->";;;;;;;;;;;;;;;;;;;;;;;

key8T_THREESUB:  MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclS
              MOVB #$10,colNumber                ;display "S->" 
              JSR sendData                     
              
              RTC
              
;Key9T_THREE: display "R->";;;;;;;;;;;;;;;;;;;;;;;

key9T_THREESUB:  MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclR
              MOVB #$10,colNumber                ;display "R->" 
              JSR sendData                     
              
              RTC
              
;Key10T_THREE: display "Q->";;;;;;;;;;;;;;;;;;;;;;

key10T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclQ
              MOVB #$10,colNumber                ;display "Q->" 
              JSR sendData                     
              
              RTC
              
;Key12T_THREE: display "P->";;;;;;;;;;;;;;;;;;;;;;

key12T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclP
              MOVB #$10,colNumber                ;display "P->" 
              JSR sendData                     
              
              RTC
              
;Key13T_THREE: display "O->";;;;;;;;;;;;;;;;;;;;;;

key13T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclO
              MOVB #$10,colNumber                ;display "O->" 
              JSR sendData                     
              
              RTC
              
;Key14T_THREE: display "N->";;;;;;;;;;;;;;;;;;;;;;

key14T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclN
              MOVB #$10,colNumber                ;display "N->" 
              JSR sendData                     
              
              RTC
              
;Key15T_THREE: display "M->";;;;;;;;;;;;;;;;;;;;;;

key15T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclM
              MOVB #$10,colNumber                ;display "M->" 
              JSR sendData                     
              
              RTC
              
;Key16T_THREE: display "L->";;;;;;;;;;;;;;;;;;;;;;

key16T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclL
              MOVB #$10,colNumber                ;display "L->" 
              JSR sendData                     
              
              RTC
              
;Key18T_THREE: display "K->";;;;;;;;;;;;;;;;;;;;;;

key18T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclK
              MOVB #$10,colNumber                ;display "K->" 
              JSR sendData                     
              
              RTC
              
;Key19T_THREE: display "J->";;;;;;;;;;;;;;;;;;;;;;

key19T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclJ
              MOVB #$10,colNumber                ;display "J->" 
              JSR sendData                     
              
              RTC
              
;Key20T_THREE: display "I->";;;;;;;;;;;;;;;;;;;;;;

key20T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclI
              MOVB #$10,colNumber                ;display "I->" 
              JSR sendData                     
              
              RTC
              
;Key21T_THREE: display "H->";;;;;;;;;;;;;;;;;;;;;;

key21T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclH
              MOVB #$10,colNumber                ;display "H->" 
              JSR sendData                     
              
              RTC
              
;Key22T_THREE: display "G->";;;;;;;;;;;;;;;;;;;;;;

key22T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclG
              MOVB #$10,colNumber                ;display "G->" 
              JSR sendData                     
              
              RTC
              
;Key24T_THREE: display "F->";;;;;;;;;;;;;;;;;;;;;;

key24T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclF
              MOVB #$10,colNumber                ;display "F->" 
              JSR sendData                     
              
              RTC
              
;Key25T_THREE: display "E->";;;;;;;;;;;;;;;;;;;;;;

key25T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclE
              MOVB #$10,colNumber                ;display "E->" 
              JSR sendData                     
              
              RTC
              
;Key26T_THREE: display "D->";;;;;;;;;;;;;;;;;;;;;;

key26T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclD
              MOVB #$10,colNumber                ;display "D->" 
              JSR sendData                     
              
              RTC
              
;Key27T_THREE: display "C->";;;;;;;;;;;;;;;;;;;;;;

key27T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclC
              MOVB #$10,colNumber                ;display "C->" 
              JSR sendData                     
              
              RTC
              
;Key28T_THREE: display "B->";;;;;;;;;;;;;;;;;;;;;;

key28T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclB
              MOVB #$10,colNumber                ;display "B->" 
              JSR sendData                     
              
              RTC
              
;Key29T_THREE: display "A->";;;;;;;;;;;;;;;;;;;;;;

key29T_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #RclA
              MOVB #$10,colNumber                ;display "A->" 
              JSR sendData                     
              
              RTC
              
;Key126_THREE: display "END";;;;;;;;;;;;;;;;;;;;;; 

key126_THREESUB: MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDX #End2
              MOVB #$18,colNumber                ;display "END"
              JSR sendData                     
              
              RTC

;Key127_THREE: display "TIMERON";;;;;;;;;;;;;;;;;;

key127_THREESUB: MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #Tmron
              MOVB #$38,colNumber                ;display "TIMERON"
              JSR sendData                     
              
              RTC
              
;Key128_THREE: display "TIMEROFF";;;;;;;;;;;;;;;;;

key128_THREESUB: MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #Tmroff
              MOVB #$40,colNumber                ;display "TIMEROFF"
              JSR sendData                     
              
              RTC

;Key130_THREE: display "pi";;;;;;;;;;;;;;;;;;;;;;;

key130_THREESUB: MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDX #Pi
              MOVB #wFont,colNumber              ;display "pi"
              JSR sendData                     
              
              RTC
              
;Key131_THREE: display "|Z|";;;;;;;;;;;;;;;;;;;;;;

key131_THREESUB: MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDX #ModZ
              MOVB #$18,colNumber                ;display "|Z|"
              JSR sendData                     
              
              RTC

;Key137_THREE: display "REAL->COMPLEX";;;;;;;;;;;;

key137_THREESUB: 

              MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #RToC
              MOVB #$48,colNumber                ;display "REAL->COMPLEX"
              JSR sendData                     
              
              RTC 

;Key138_THREE: display "CONJUGATEOFZ";;;;;;;;;;;;;

key138_THREESUB: 

              MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #CZ
              MOVB #$48,colNumber                ;display "CONJUGATEOFZ"
              JSR sendData                    
              
              RTC

;Key143_THREE: display "PICK";;;;;;;;;;;;;;;;;;;;;

key143_THREESUB: MOVB #$60,Ycoord
              JSR setY                           ;Y = 96
              
              LDX #Pick2
              MOVB #$20,colNumber                ;display "PICK"
              JSR sendData                     
              
              RTC
              
;Key144_THREE: display "->Z";;;;;;;;;;;;;;;;;;;;;;

key144_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoZ
              MOVB #$10,colNumber                ;display "->Z"
              JSR sendData                     
              
              RTC
              
;Key145_THREE: display "->Y";;;;;;;;;;;;;;;;;;;;;;

key145_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoY
              MOVB #$10,colNumber                ;display "->Y"
              JSR sendData                     
              
              RTC
              
;Key146_THREE: display "->X";;;;;;;;;;;;;;;;;;;;;;

key146_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoX
              MOVB #$10,colNumber                ;display "->X"
              JSR sendData                     
              
              RTC
              
;Key147_THREE: display "->W";;;;;;;;;;;;;;;;;;;;;;

key147_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoW
              MOVB #$10,colNumber                ;display "->W"
              JSR sendData                     
              
              RTC
              
;Key148_THREE: display "->V";;;;;;;;;;;;;;;;;;;;;;

key148_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoV
              MOVB #$10,colNumber                ;display "->V"
              JSR sendData                     
              
              RTC
              
;Key149_THREE: display "->U";;;;;;;;;;;;;;;;;;;;;;

key149_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoU
              MOVB #$10,colNumber                ;display "->U"
              JSR sendData                     
              
              RTC 
              
;Key150_THREE: display "->T";;;;;;;;;;;;;;;;;;;;;;

key150_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoT
              MOVB #$10,colNumber                ;display "->T"
              JSR sendData                     
              
              RTC
              
;Key151_THREE: display "->S";;;;;;;;;;;;;;;;;;;;;;

key151_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoS
              MOVB #$10,colNumber                ;display "->S"
              JSR sendData                     
              
              RTC 
              
;Key152_THREE: display "->R";;;;;;;;;;;;;;;;;;;;;;

key152_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoR
              MOVB #$10,colNumber                ;display "->R"
              JSR sendData                     
              
              RTC
              
;Key153_THREE: display "->Q";;;;;;;;;;;;;;;;;;;;;;

key153_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoQ
              MOVB #$10,colNumber                ;display "->Q"
              JSR sendData                     
              
              RTC 
              
;Key154_THREE: display "->P";;;;;;;;;;;;;;;;;;;;;;

key154_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoP
              MOVB #$10,colNumber                ;display "->P"
              JSR sendData                     
              
              RTC
              
;Key155_THREE: display "->O";;;;;;;;;;;;;;;;;;;;;;

key155_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoO
              MOVB #$10,colNumber                ;display "->O"
              JSR sendData                     
              
              RTC 
              
;Key156_THREE: display "->N";;;;;;;;;;;;;;;;;;;;;;

key156_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoN
              MOVB #$10,colNumber                ;display "->N"
              JSR sendData                     
              
              RTC
              
;Key157_THREE: display "->M";;;;;;;;;;;;;;;;;;;;;;

key157_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoM
              MOVB #$10,colNumber                ;display "->M"
              JSR sendData                     
              
              RTC 
              
;Key158_THREE: display "->L";;;;;;;;;;;;;;;;;;;;;;

key158_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoL
              MOVB #$10,colNumber                ;display "->L"
              JSR sendData                     
              
              RTC
              
;Key159_THREE: display "->K";;;;;;;;;;;;;;;;;;;;;;

key159_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoK
              MOVB #$10,colNumber                ;display "->K"
              JSR sendData                     
              
              RTC 
              
;Key160_THREE: display "->J";;;;;;;;;;;;;;;;;;;;;;

key160_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoJ
              MOVB #$10,colNumber                ;display "->J"
              JSR sendData                     
              
              RTC
              
;Key161_THREE: display "->I";;;;;;;;;;;;;;;;;;;;;;

key161_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoI
              MOVB #$10,colNumber                ;display "->I"
              JSR sendData                     
              
              RTC 
              
;Key162_THREE: display "->H";;;;;;;;;;;;;;;;;;;;;;

key162_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoH
              MOVB #$10,colNumber                ;display "->H"
              JSR sendData                     
              
              RTC
              
;Key163_THREE: display "->G";;;;;;;;;;;;;;;;;;;;;;

key163_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoG
              MOVB #$10,colNumber                ;display "->G"
              JSR sendData                     
              
              RTC 
              
;Key164_THREE: display "->F";;;;;;;;;;;;;;;;;;;;;;

key164_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoF
              MOVB #$10,colNumber                ;display "->F"
              JSR sendData                     
              
              RTC
              
;Key165_THREE: display "->E";;;;;;;;;;;;;;;;;;;;;;

key165_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoE
              MOVB #$10,colNumber                ;display "->E"
              JSR sendData                     
              
              RTC 
              
;Key166_THREE: display "->D";;;;;;;;;;;;;;;;;;;;;;

key166_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoD
              MOVB #$10,colNumber                ;display "->D"
              JSR sendData                     
              
              RTC
              
;Key167_THREE: display "->C";;;;;;;;;;;;;;;;;;;;;;

key167_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoC
              MOVB #$10,colNumber                ;display "->C"
              JSR sendData                     
              
              RTC 
              
;Key168_THREE: display "->B";;;;;;;;;;;;;;;;;;;;;;

key168_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoB
              MOVB #$10,colNumber                ;display "->B"
              JSR sendData                     
              
              RTC
              
;Key169_THREE: display "->A";;;;;;;;;;;;;;;;;;;;;;

key169_THREESUB: MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #StoA
              MOVB #$10,colNumber                ;display "->A"
              JSR sendData                     
              
              RTC
              
;key170_THREE: display "ROTATE";;;;;;;;;;;;;;;;;;;

key170_THREESUB: MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #Rot
              MOVB #$30,colNumber                ;display "ROTATE"
              JSR sendData                     
              
              RTC 

;key171_THREE: display "DELETE2";;;;;;;;;;;;;;;;;;

key171_THREESUB: MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #Del2
              MOVB #$38,colNumber                ;display "DELETE2"
              JSR sendData                     
              
              RTC
              
;key172_THREE: display "UNROTATE";;;;;;;;;;;;;;;;;

key172_THREESUB: MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #Urt
              MOVB #$40,colNumber                ;display "UNROTATE"
              JSR sendData                     
              
              RTC

;key173_THREE: display "DELETE3";;;;;;;;;;;;;;;;;;

key173_THREESUB: MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #Del3
              MOVB #$38,colNumber                ;display "DELETE3"
              JSR sendData                     
              
              RTC
              
;key174_THREE: display "ENTER2";;;;;;;;;;;;;;;;;;;

key174_THREESUB: MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #Enter2
              MOVB #$30,colNumber                ;display "ENTER2"
              JSR sendData                     
              
              RTC

;key175_THREE: display "OVER";;;;;;;;;;;;;;;;;;;;;

key175_THREESUB: MOVB #$60,Ycoord
              JSR setY                           ;Y = 96
              
              LDX #Over
              MOVB #$20,colNumber                ;display "OVER"
              JSR sendData                     
              
              RTC

;key176_THREE: display "POLARFORMOFZ";;;;;;;;;;;;;

key176_THREESUB: 
              MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #PZ
              MOVB #$48,colNumber                ;display "POLARFORMOFZ"
              JSR sendData                     
              
              RTC
              
;key177_THREE: display "ENTER3";;;;;;;;;;;;;;;;;;;

key177_THREESUB: MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #Enter3
              MOVB #$30,colNumber                ;display "ENTER3"
              JSR sendData                     
              
              RTC

;key178_THREE: display "DEPTH";;;;;;;;;;;;;;;;;;;;

key178_THREESUB: MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #Dph
              MOVB #$28,colNumber                ;display "DEPTH"
              JSR sendData                     
              
              RTC 
              
;key179_THREE: display "ENTER4";;;;;;;;;;;;;;;;;;;

key179_THREESUB: MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #Enter4
              MOVB #$30,colNumber                ;display "ENTER4"
              JSR sendData                     
              
              RTC

;key180_THREE: display "RANDOMNUMBER";;;;;;;;;;;;;

key180_THREESUB: MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #RND
              MOVB #$48,colNumber                ;display "RANDOMNUMBER"
              JSR sendData                     
              
              RTC

;key181_THREE: display "->x(K)";;;;;;;;;;;;;;;;;;;

key181_THREESUB: MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #StoxK
              MOVB #$28,colNumber                ;display "->x(K)"
              JSR sendData                     
              
              RTC
              
;key182_THREE: display "x(K)->";;;;;;;;;;;;;;;;;;;

key182_THREESUB: MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #RclxK
              MOVB #$28,colNumber                ;display "x(K)->"
              JSR sendData                     
              
              RTC
              
;key183_THREE: display "INCREMENTK";;;;;;;;;;;;;;;

key183_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #IncK2 
              MOVB #$3C,colNumber                ;display "INCREMENTK"
              JSR sendData                     
              
              RTC

;key184_THREE: display "DECREMENTK";;;;;;;;;;;;;;;

key184_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #DecK2 
              MOVB #$3C,colNumber                ;display "DECREMENTK"
              JSR sendData                     
              
              RTC

;key185_THREE: display "HALT";;;;;;;;;;;;;;;;;;;;;

key185_THREESUB: MOVB #$60,Ycoord
              JSR setY                           ;Y = 96
              
              LDX #Halt2
              MOVB #$20,colNumber                ;display "HALT"
              JSR sendData                     
              
              RTC

;key186_THREE: display "DELAYK";;;;;;;;;;;;;;;;;;;

key186_THREESUB: MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #Dly
              MOVB #$30,colNumber                ;display "DELAYK"
              JSR sendData                     
              
              RTC 

;key187_THREE: display "BUSYON";;;;;;;;;;;;;;;;;;;

key187_THREESUB: MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #BON
              MOVB #$30,colNumber                ;display "BUSYON"
              JSR sendData                     
              
              RTC 

;key188_THREE: display "BUSYOFF";;;;;;;;;;;;;;;;;;

key188_THREESUB: MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #BOF
              MOVB #$38,colNumber                ;display "BUSYOFF"
              JSR sendData                     
              
              RTC

;key189_THREE: display "ERRORON";;;;;;;;;;;;;;;;;;

key189_THREESUB: MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #EON
              MOVB #$38,colNumber                ;display "ERRORON"
              JSR sendData                     
              
              RTC

;key190_THREE: display "ERROROFF";;;;;;;;;;;;;;;;;

key190_THREESUB: MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #EOF
              MOVB #$40,colNumber                ;display "ERROROFF"
              JSR sendData                     
              
              RTC
              
;key191_THREE: display "SCANKEYPAD";;;;;;;;;;;;;;;

key191_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #ScanKP
              MOVB #$3C,colNumber                ;display "SCANKEYPAD"
              JSR sendData                     
              
              RTC

;key192_THREE: display "KEYNUMBER->";;;;;;;;;;;;;;

key192_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #RclKN
              MOVB #$3C,colNumber                ;display "KEYNUMBER->"
              JSR sendData                     
              
              RTC

;key193_THREE: display "NOP";;;;;;;;;;;;;;;;;;;;;

key193_THREESUB: MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDX #noOp
              MOVB #$18,colNumber                ;display "NOP"
              JSR sendData                     
              
              RTC

;key194_THREE: display "sinh x";;;;;;;;;;;;;;;;;;;

key194_THREESUB: MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #SH
              MOVB #$30,colNumber                ;display "sinh x"
              JSR sendData                     
              
              RTC

;key195_THREE: display "cosh x";;;;;;;;;;;;;;;;;;;

key195_THREESUB: MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #CH
              MOVB #$30,colNumber                ;display "cosh x"
              JSR sendData                     
              
              RTC
              
;key196_THREE: display "tanh x";;;;;;;;;;;;;;;;;;;

key196_THREESUB: MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #TH
              MOVB #$30,colNumber                ;display "tanh x"
              JSR sendData                     
              
              RTC

;key197_THREE: display symbol for arcsinh x;;;;;;;

key197_THREESUB: 
              MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #ASH
              MOVB #$30,colNumber                ;display symbol for arcsinh x
              JSR sendData                     
              
              RTC

;key198_THREE: display symbol for arccosh x;;;;;;;

key198_THREESUB: 
              MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #ACH
              MOVB #$30,colNumber                ;display symbol for arccosh x
              JSR sendData                     
              
              RTC

;key199_THREE: display symbol for arctanh x;;;;;;;

key199_THREESUB: 
              MOVB #$50,Ycoord
              JSR setY                           ;Y = 80
              
              LDX #ATH
              MOVB #$30,colNumber                ;display symbol for arctanh x
              JSR sendData                     
              
              RTC

;key200_THREE: display symbol for floor function;;

key200_THREESUB: MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDX #Flr
              MOVB #$18,colNumber                ;display symbol for floor function
              JSR sendData                     
              
              RTC

;key201_THREE: display "RETFRMSUBRTE";;;;;;;;;;;;;

key201_THREESUB: MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #RFS
              MOVB #$48,colNumber                ;display "RETFRMSUBRTE"
              JSR sendData                     
              
              RTC
              
;key202_THREE: display "|X|";;;;;;;;;;;;;;;;;;;;;;

key202_THREESUB: 
              MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDX #Abs
              MOVB #$18,colNumber                ;display "|X|"
              JSR sendData                     
              
              RTC

;key203_THREE: display "->RANDOM#SEED";;;;;;;;;;;;

key203_THREESUB:
              MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #RNDSD
              MOVB #$48,colNumber
              JSR sendData                       ;display "->RANDOM#SEED"
              
              RTC

;key204_THREE: display "PERMUTATION";;;;;;;;;;;;;;

key204_THREESUB: 
              MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62 
              
              LDX #PR
              MOVB #$42,colNumber
              JSR sendData                       ;display "PERMUTATION"

              RTC

;key205_THREE: display "COMBINATION";;;;;;;;;;;;;;

key205_THREESUB:

              MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
              
              LDX #CB
              MOVB #$42,colNumber
              JSR sendData                       ;display "COMBINATION"

              RTC

;key206_THREE: display symbol for ceiling function

key206_THREESUB: MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDX #Clg
              MOVB #$18,colNumber                ;display symbol for ceiling function
              JSR sendData                     
              
              RTC

;key207_THREE: display "DECIMAL->degree symbol ' " "

key207_THREESUB:

              MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
                   
              LDX #ToDMS
              MOVB #$42,colNumber
              JSR sendData                       ;display "DECIMAL->degree symbol ' " "

              RTC

;key208_THREE: display "degree symbol ' "->DECIMAL"

key208_THREESUB:

              MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
                   
              LDX #DMSTo
              MOVB #$42,colNumber
              JSR sendData                       ;display "degree symbol ' "->DECIMAL"

              RTC

;key209_THREE: display "COMPLEX->REAL";;;;;;;;;;;;

key209_THREESUB: 
              MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
                   
              LDX #CToR
              MOVB #$48,colNumber
              JSR sendData                       ;display "COMPLEX->REAL"

              RTC 

;key210_THREE: display "CARTFORMOFZ";;;;;;;;;;;;;;

key210_THREESUB: 
              MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
                   
              LDX #CartZ
              MOVB #$42,colNumber
              JSR sendData                       ;display "CARTFORMOFZ"

              RTC 
              
;key211_THREE: display mean of x symbol;;;;;;;;;;;

key211_THREESUB: 
              MOVB #$78,Ycoord
              JSR setY                           ;Y = 120
              
              LDX #meanx
              MOVB #$08,colNumber                ;display mean of x symbol
              JSR sendData                     
              
              RTC

;key212_THREE: display "GCD(a,b)";;;;;;;;;;;;;;;;

key212_THREESUB: 
              MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
                   
              LDX #GCD
              MOVB #$40,colNumber
              JSR sendData                       ;display "GCD(a,b)"

              RTC 

;key213_THREE: display "LCM(a,b)";;;;;;;;;;;;;;;;

key213_THREESUB: 
              MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
                   
              LDX #LCM
              MOVB #$40,colNumber
              JSR sendData                       ;display "LCM(a,b)"

              RTC
              
;key214_THREE: display "2^x";;;;;;;;;;;;;;;;

key214_THREESUB:
              
              MOVB #$70,Ycoord
              JSR setY                           ;Y = 112
              
              LDX #Twox
              MOVB #$10,colNumber                ;display 2^x 
              JSR sendData                     
              
              RTC
              
;key215_THREE: display "ld x";;;;;;;;;;;;;;;;;;;;;

key215_THREESUB:
              
              MOVB #$60,Ycoord
              JSR setY                           ;Y = 96             
              
              LDX #Ld
              MOVB #$20,colNumber                ;display "ld x"
              JSR sendData                     
              
              RTC
              
 ;key216_THREE: display "->y(K)";;;;;;;;;;;;;;;;;;;;;

key216_THREESUB:
              
              MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #StoyK
              MOVB #$28,colNumber                ;display "->y(K)"
              JSR sendData                     
              
              RTC 
 
 ;key217_THREE: display "y(K)->";;;;;;;;;;;;;;;;;;;;;

key217_THREESUB:
              
              MOVB #$58,Ycoord
              JSR setY                           ;Y = 88
              
              LDX #RclyK
              MOVB #$28,colNumber                ;display "y(K)->"
              JSR sendData                     
              
              RTC       

;key222_THREE: display underlined (indirect) "GOTO"

key222_THREESUB: 
              MOVB #$60,Ycoord
              JSR setY                           ;Y = 96
              
              LDX #GotoIf
              MOVB #$20,colNumber                ;display underlined "GOTO"
              JSR sendData2                     
              
              RTC 

;key223_THREE: display underlined (indirect) "GOTOIF=0"

key223_THREESUB: 
              MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display underlined "GOTOIF"
              JSR sendData2 
              
              LDX #Goto0
              MOVB #$10,colNumber                ;display underlined "=0"
              JSR sendData2                     
              
              RTC

;key224_THREE: display underlined (indirect) "GOTOIF<>0"

key224_THREESUB: 
              MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoN0
              MOVB #$10,colNumber                ;display underlined "<>0"
              JSR sendData2                     
              
              RTC

;key225_THREE: display underlined (indirect) "GOTOIF="

key225_THREESUB: 
              MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #Goto0
              MOVB #$08,colNumber                ;display underlined "="
              JSR sendData2                     
              
              RTC

;key226_THREE: display underlined (indirect) "GOTOIF<>"

key226_THREESUB: 
              MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoN0
              MOVB #$08,colNumber                ;display underlined "<>"
              JSR sendData2                     
              
              RTC 

;key227_THREE: display underlined (indirect) "GOTOIF>"

key227_THREESUB: 
              MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoGE
              MOVB #$08,colNumber                ;display underlined ">"
              JSR sendData2                     
              
              RTC 

;key228_THREE: display underlined (indirect) "GOTOIF<"

key228_THREESUB: 
              MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoLE
              MOVB #$08,colNumber                ;display underlined "<"
              JSR sendData2                     
              
              RTC 

;key229_THREE: display underlined (indirect) "GOTOIF>="

key229_THREESUB: 
              MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoGE
              MOVB #$10,colNumber                ;display underlined ">="
              JSR sendData2                     
              
              RTC 

;key230_THREE: display underlined (indirect) "GOTOIF<="

key230_THREESUB: 
              MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoLE
              MOVB #$10,colNumber                ;display underlined "<="
              JSR sendData2                     
              
              RTC 

;key231_THREE: display underlined (indirect) "GOTOIFKEYPRS"

key231_THREESUB: 
              MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoKP
              MOVB #$24,colNumber                ;display underlined "KEYPRS"
              JSR sendData2

              RTC

;key232_THREE: display underlined (indirect) "GOTOIF=x(K)"

key232_THREESUB: 
              MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoEx
              MOVB #$1E,colNumber                ;display underlined "=x(K)"
              JSR sendData2
              
              RTC 

;key233_THREE: display underlined (indirect) "GOTOIF<>x(K)"

key233_THREESUB: 
              MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoNEx
              MOVB #$1E,colNumber                ;display underlined "<>x(K)"
              JSR sendData2
              
              RTC

;key234_THREE: display underlined (indirect) "GOTOIF>=x(K)"

key234_THREESUB: 
              MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoGEx
              MOVB #$24,colNumber                ;display underlined ">=x(K)"
              JSR sendData2
              
              RTC        

;key235_THREE: display underlined (indirect) "GOTOIF<=x(K)"

key235_THREESUB: 
              MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display underlined "GOTOIF"
              JSR sendData2
              
              LDX #GotoLEx
              MOVB #$24,colNumber                ;display underlined "<=x(K)"
              JSR sendData2
              
              RTC

;key236_THREE: for future 2 byte instructions (EC)

key236_THREESUB: RTC

;key237_THREE: for future 2 byte instructions (ED)

key237_THREESUB: RTC

;key238_THREE: for future 2 byte instructions (EE)

key238_THREESUB: RTC 

;key239_THREE: display "2BYTEINSTRUC";;;;;;;;;;;;;

key239_THREESUB: MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #TBI
              MOVB #$48,colNumber                ;display "2BYTEINSTRUC"
              JSR sendData                     
              
              RTC
              
;key240_THREE: display "GOTO";;;;;;;;;;;;;;;;;;;;;

key240_THREESUB: MOVB #$60,Ycoord
              JSR setY                           ;Y = 96
              
              LDX #GotoIf
              MOVB #$20,colNumber                ;display "GOTO"
              JSR sendData                     
              
              RTC

;key241_THREE: display "GOTOIF=0";;;;;;;;;;;;;;;;;

key241_THREESUB: MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display "GOTOIF"
              JSR sendData 
              
              LDX #Goto0
              MOVB #$10,colNumber                ;display "=0"
              JSR sendData                     
              
              RTC

;key242_THREE: display "GOTOIF<>0";;;;;;;;;;;;;;;;

key242_THREESUB: MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoN0
              MOVB #$10,colNumber                ;display "<>0"
              JSR sendData                     
              
              RTC

;key243_THREE: display "GOTOIF=";;;;;;;;;;;;;;;;;;

key243_THREESUB: MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #Goto0
              MOVB #$08,colNumber                ;display "="
              JSR sendData                     
              
              RTC 

;key244_THREE: display "GOTOIF<>";;;;;;;;;;;;;;;;;

key244_THREESUB: MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoN0
              MOVB #$08,colNumber                ;display "<>"
              JSR sendData                     
              
              RTC

;key245_THREE: display "GOTOIF>";;;;;;;;;;;;;;;;;;

key245_THREESUB: MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoGE
              MOVB #$08,colNumber                ;display ">"
              JSR sendData                     
              
              RTC 

;key246_THREE: display "GOTOIF<";;;;;;;;;;;;;;;;;;

key246_THREESUB: MOVB #$48,Ycoord
              JSR setY                           ;Y = 72
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoLE
              MOVB #$08,colNumber                ;display "<"
              JSR sendData                     
              
              RTC

;key247_THREE: display "GOTOIF>=";;;;;;;;;;;;;;;;;

key247_THREESUB: 
              MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoGE
              MOVB #$10,colNumber                ;display ">="
              JSR sendData                     
              
              RTC 

;key248_THREE: display "GOTOIF<=";;;;;;;;;;;;;;;;;

key248_THREESUB: 
              MOVB #$40,Ycoord
              JSR setY                           ;Y = 64
              
              LDX #GotoIf
              MOVB #$30,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoLE
              MOVB #$10,colNumber                ;display "<="
              JSR sendData                     
              
              RTC 

;key249_THREE: display "GOTOIFKEYPRS";;;;;;;;;;;;;;;;;

key249_THREESUB: MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoKP
              MOVB #$24,colNumber                ;display "KEYPRS"
              JSR sendData

              RTC

;key250_THREE: display "GOTOIF=x(K)";;;;;;;;;;;;;

key250_THREESUB: MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoEx
              MOVB #$1E,colNumber                ;display "=x(K)"
              JSR sendData
              
              RTC
              
;key251_THREE: display "GOTOIF<>x(K)";;;;;;;;;;;;;

key251_THREESUB: MOVB #$3E,Ycoord
              JSR setY                           ;Y = 62
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoNEx
              MOVB #$1E,colNumber                ;display "<>x(K)"
              JSR sendData
              
              RTC

;key252_THREE: display "GOTOIF>=x(K)";;;;;;;;;;;;;

key252_THREESUB: MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoGEx
              MOVB #$24,colNumber                ;display ">=x(K)"
              JSR sendData
              
              RTC                     

;key253_THREE: display "GOTOIF<=x(K)";;;;;;;;;;;;;

key253_THREESUB: MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoLEx
              MOVB #$24,colNumber                ;display "<=x(K)"
              JSR sendData
              
              RTC
              
;key254_THREE: display "GOTOIFCMDEMP";;;;;;;;;;;;;

key254_THREESUB: MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #GotoIfSL
              MOVB #$24,colNumber                ;display "GOTOIF"
              JSR sendData
              
              LDX #GotoCE
              MOVB #$24,colNumber                ;display "<=x(K)"
              JSR sendData
              
              RTC

;key255_THREE: display "JUMPTOSUBRTE";;;;;;;;;;;;;

key255_THREESUB: MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #JTS
              MOVB #$48,colNumber                ;display "JUMPTOSUBRTE"
              JSR sendData                     
              
              RTC

;keyEF0_THREE: display "SETDEGMODE";;;;;;;;;;;;;;;

keyEF0_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SDegMode
              MOVB #$12,colNumber                ;display "DEG"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData  

              RTC

;keyEF1_THREE: display "SETRADMODE";;;;;;;;;;;;;;;

keyEF1_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SRadMode
              MOVB #$12,colNumber                ;display "RAD"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData 

              RTC

;keyEF2_THREE: display "SETGRAMODE";;;;;;;;;;;;;;;

keyEF2_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SGraMode
              MOVB #$12,colNumber                ;display "GRA"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData

              RTC

;keyEF3_THREE: display "SETDAPXMODE";;;;;;;;;;;;;;

keyEF3_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SApxMode
              MOVB #$12,colNumber                ;display "APX"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData 

              RTC

;keyEF4_THREE: display "SETEXTMODE";;;;;;;;;;;;;;;

keyEF4_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SExtMode
              MOVB #$12,colNumber                ;display "EXT"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData 

              RTC

;keyEF5_THREE: display "SETCPXMODE";;;;;;;;;;;;;;;

keyEF5_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SCpxMode
              MOVB #$12,colNumber                ;display "CPX"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData

              RTC

;keyEF6_THREE: display "SETENGMODE";;;;;;;;;;;;;;;

keyEF6_THREESUB: MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SEngMode
              MOVB #$12,colNumber                ;display "ENG"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData

              RTC

;keyEF7_THREE: display "FIX";;;;;;;;;;;;;;;;;;;;;;

keyEF7_THREESUB: MOVB #$68,Ycoord
              JSR setY                           ;Y = 104
              
              LDX #Fix
              MOVB #$18,colNumber                ;display "FIX"
              JSR sendData                     
              
              RTC 

;keyEF8_THREE: display "DISPLAYERROR";;;;;;;;;;;;;

keyEF8_THREESUB:

              MOVB #$38,Ycoord
              JSR setY                           ;Y = 56
              
              LDX #DispEr
              MOVB #$48,colNumber                ;display "DISPLAYERROR"
              JSR sendData                     
              
              RTC

;keyEF9_THREE: display "SETHEXMODE";;;;;;;;;;;;;;;

keyEF9_THREESUB: 
              MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SHexMode
              MOVB #$12,colNumber                ;display "HEX"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData

              RTC

;keyEF10_THREE: display "SETDECMODE";;;;;;;;;;;;;;

keyEF10_THREESUB: 
              MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SDecMode
              MOVB #$12,colNumber                ;display "DEC"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData

              RTC

;keyEF11_THREE: display "SETBINMODE";;;;;;;;;;;;;;

keyEF11_THREESUB: 
              MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SBinMode
              MOVB #$12,colNumber                ;display "BIN"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData

              RTC
              
;keyEF12_THREE: display "SETSCIMODE";;;;;;;;;;;;;;

keyEF12_THREESUB: 
              MOVB #$44,Ycoord
              JSR setY                           ;Y = 68
              
              LDX #Sett
              MOVB #$12,colNumber                ;display "SET"
              JSR sendData 
              
              LDX #SSciMode
              MOVB #$12,colNumber                ;display "SCI"
              JSR sendData
              
              LDX #Mode
              MOVB #$18,colNumber                ;display "MODE"
              JSR sendData

              RTC                   

;keyEF13_THREE:

keyEF13_THREESUB:NOP                   

;keyEF14_THREE:

keyEF14_THREESUB:NOP                   

;keyEF15_THREE:

keyEF15_THREESUB:NOP                   

;keyEF16_THREE:

keyEF16_THREESUB:NOP                    

;keyEF17_THREE:

keyEF17_THREESUB:NOP                   

;keyEF18_THREE:

keyEF18_THREESUB:NOP                    

;keyEF19_THREE:

keyEF19_THREESUB:NOP                      

;keyEF20_THREE: 

keyEF20_THREESUB:NOP                   

;keyEF21_THREE: 

keyEF21_THREESUB:NOP                   

;keyEF22_THREE:

keyEF22_THREESUB:NOP                   

;keyEF23_THREE:

keyEF23_THREESUB:NOP                   

;keyEF24_THREE:

keyEF24_THREESUB:NOP                    

;keyEF25_THREE:

keyEF25_THREESUB:NOP                   

;keyEF26_THREE:

keyEF26_THREESUB:NOP                   

;keyEF27_THREE:

keyEF27_THREESUB:NOP                   

;keyEF28_THREE:

keyEF28_THREESUB:NOP                   

;keyEF29_THREE:

keyEF29_THREESUB:NOP                   

;keyEF30_THREE: 

keyEF30_THREESUB:NOP                   

;keyEF31_THREE: 

keyEF31_THREESUB:NOP                   

;keyEF32_THREE:

keyEF32_THREESUB:NOP                    

;keyEF33_THREE:

keyEF33_THREESUB:NOP                   

;keyEF34_THREE:

keyEF34_THREESUB:NOP                   

;keyEF35_THREE:

keyEF35_THREESUB:NOP                   

;keyEF36_THREE:

keyEF36_THREESUB:NOP                    

;keyEF37_THREE:

keyEF37_THREESUB:NOP                   

;keyEF38_THREE:

keyEF38_THREESUB:NOP                    

;keyEF39_THREE:

keyEF39_THREESUB:NOP                    

;keyEF40_THREE: 

keyEF40_THREESUB:NOP                   

;keyEF41_THREE: 

keyEF41_THREESUB:NOP                   

;keyEF42_THREE:

keyEF42_THREESUB:NOP                    

;keyEF43_THREE:

keyEF43_THREESUB:NOP                   

;keyEF44_THREE:
       
keyEF44_THREESUB:NOP                   

;keyEF45_THREE:

keyEF45_THREESUB:NOP                   

;keyEF46_THREE:

keyEF46_THREESUB:NOP                    

;keyEF47_THREE:

keyEF47_THREESUB:NOP                   

;keyEF48_THREE:

keyEF48_THREESUB:NOP                   

;keyEF49_THREE:

keyEF49_THREESUB:NOP                   

;keyEF50_THREE:

keyEF50_THREESUB:NOP                   

;keyEF51_THREE: 

keyEF51_THREESUB:NOP                   

;keyEF52_THREE:

keyEF52_THREESUB:NOP                   

;keyEF53_THREE:

keyEF53_THREESUB:NOP                   

;keyEF54_THREE:
       
keyEF54_THREESUB:NOP                    

;keyEF55_THREE:

keyEF55_THREESUB:NOP                   

;keyEF56_THREE:

keyEF56_THREESUB:NOP                    

;keyEF57_THREE:

keyEF57_THREESUB:NOP                  

;keyEF58_THREE:

keyEF58_THREESUB:NOP                    

;keyEF59_THREE:
             
keyEF59_THREESUB:NOP                   

;keyEF60_THREE:

keyEF60_THREESUB:NOP                   

;keyEF61_THREE: 

keyEF61_THREESUB:NOP                   

;keyEF62_THREE:

keyEF62_THREESUB:NOP                    

;keyEF63_THREE:

keyEF63_THREESUB:NOP                   

;keyEF64_THREE:
       
keyEF64_THREESUB:NOP                    

;keyEF65_THREE:

keyEF65_THREESUB:NOP                   

;keyEF66_THREE:

keyEF66_THREESUB:NOP                    

;keyEF67_THREE:

keyEF67_THREESUB:NOP                   

;keyEF68_THREE:

keyEF68_THREESUB:NOP                   

;keyEF69_THREE:

keyEF69_THREESUB:NOP                   

;keyEF70_THREE:

keyEF70_THREESUB:NOP                   

;keyEF71_THREE: 

keyEF71_THREESUB:NOP                   

;keyEF72_THREE:

keyEF72_THREESUB:NOP                    

;keyEF73_THREE:

keyEF73_THREESUB:NOP                   

;keyEF74_THREE:
       
keyEF74_THREESUB:NOP                    

;keyEF75_THREE:

keyEF75_THREESUB:NOP                   

;keyEF76_THREE:

keyEF76_THREESUB:NOP                    

;keyEF77_THREE:

keyEF77_THREESUB:NOP                   

;keyEF78_THREE:

keyEF78_THREESUB:NOP                    

;keyEF79_THREE:

keyEF79_THREESUB:NOP                   

;keyEF80_THREE:

keyEF80_THREESUB:NOP                   

;keyEF81_THREE: 

keyEF81_THREESUB:NOP                   

;keyEF82_THREE:

keyEF82_THREESUB:NOP                    

;keyEF83_THREE:

keyEF83_THREESUB:NOP                   

;keyEF84_THREE:
       
keyEF84_THREESUB:NOP                    

;keyEF85_THREE:

keyEF85_THREESUB:NOP                   

;keyEF86_THREE:

keyEF86_THREESUB:NOP                   

;keyEF87_THREE:

keyEF87_THREESUB:NOP                   

;keyEF88_THREE:

keyEF88_THREESUB:NOP                    

;keyEF89_THREE:

keyEF89_THREESUB:NOP                   

;keyEF90_THREE:

keyEF90_THREESUB:NOP                   

;keyEF91_THREE: 

keyEF91_THREESUB:NOP                   

;keyEF92_THREE:

keyEF92_THREESUB:NOP                   

;keyEF93_THREE:

keyEF93_THREESUB:NOP                   

;keyEF94_THREE:
       
keyEF94_THREESUB:NOP                    

;keyEF95_THREE:

keyEF95_THREESUB:NOP                   

;keyEF96_THREE:

keyEF96_THREESUB:NOP                    

;keyEF97_THREE:

keyEF97_THREESUB:NOP                   

;keyEF98_THREE:

keyEF98_THREESUB:NOP                    

;keyEF99_THREE:

keyEF99_THREESUB:NOP                   

;keyEF100_THREE: 

keyEF100_THREESUB:NOP                   

;keyEF101_THREE: 

keyEF101_THREESUB:NOP                   

;keyEF102_THREE:

keyEF102_THREESUB:NOP                   

;keyEF103_THREE:

keyEF103_THREESUB:NOP                   

;keyEF104_THREE:

keyEF104_THREESUB:NOP                   

;keyEF105_THREE:

keyEF105_THREESUB:NOP                   

;keyEF106_THREE:

keyEF106_THREESUB:NOP                   

;keyEF107_THREE:

keyEF107_THREESUB:NOP                   

;keyEF108_THREE:

keyEF108_THREESUB:NOP                   

;keyEF109_THREE:

keyEF109_THREESUB:NOP                   

;keyEF110_THREE: 

keyEF110_THREESUB:NOP                   

;keyEF111_THREE: 

keyEF111_THREESUB:NOP                   
              
;keyEF112_THREE:

keyEF112_THREESUB:NOP                   

;keyEF113_THREE:

keyEF113_THREESUB:NOP                   

;keyEF114_THREE:

keyEF114_THREESUB:NOP                   

;keyEF115_THREE:

keyEF115_THREESUB:NOP                   

;keyEF116_THREE:

keyEF116_THREESUB:NOP                    

;keyEF117_THREE:

keyEF117_THREESUB:NOP                   

;keyEF118_THREE:

keyEF118_THREESUB:NOP                    

;keyEF119_THREE:

keyEF119_THREESUB:NOP                      

;keyEF120_THREE: 

keyEF120_THREESUB:NOP                   

;keyEF121_THREE: 

keyEF121_THREESUB:NOP                   

;keyEF122_THREE:

keyEF122_THREESUB:NOP                   

;keyEF123_THREE:

keyEF123_THREESUB:NOP                   

;keyEF124_THREE:

keyEF124_THREESUB:NOP                    

;keyEF125_THREE:

keyEF125_THREESUB:NOP                   

;keyEF126_THREE:

keyEF126_THREESUB:NOP                   

;keyEF127_THREE:

keyEF127_THREESUB:NOP                   

;keyEF128_THREE:

keyEF128_THREESUB:NOP                   

;keyEF129_THREE:

keyEF129_THREESUB:NOP                   

;keyEF130_THREE: 

keyEF130_THREESUB:NOP                   

;keyEF131_THREE: 

keyEF131_THREESUB:NOP                   

;keyEF132_THREE:

keyEF132_THREESUB:NOP                    

;keyEF133_THREE:

keyEF133_THREESUB:NOP                   

;keyEF134_THREE:

keyEF134_THREESUB:NOP                   

;keyEF135_THREE:

keyEF135_THREESUB:NOP                   

;keyEF136_THREE:

keyEF136_THREESUB:NOP                    

;keyEF137_THREE:

keyEF137_THREESUB:NOP                   

;keyEF138_THREE:

keyEF138_THREESUB:NOP                    

;keyEF139_THREE:

keyEF139_THREESUB:NOP                    

;keyEF140_THREE: 

keyEF140_THREESUB:NOP                   

;keyEF141_THREE: 

keyEF141_THREESUB:NOP                   

;keyEF142_THREE:

keyEF142_THREESUB:NOP                    

;keyEF143_THREE:

keyEF143_THREESUB:NOP                   

;keyEF144_THREE:
       
keyEF144_THREESUB:NOP                   

;keyEF145_THREE:

keyEF145_THREESUB:NOP                   

;keyEF146_THREE:

keyEF146_THREESUB:NOP                    

;keyEF147_THREE:

keyEF147_THREESUB:NOP                   

;keyEF148_THREE:

keyEF148_THREESUB:NOP                   

;keyEF149_THREE:

keyEF149_THREESUB:NOP                   

;keyEF150_THREE:

keyEF150_THREESUB:NOP                   

;keyEF151_THREE: 

keyEF151_THREESUB:NOP                   

;keyEF152_THREE:

keyEF152_THREESUB:NOP                   

;keyEF153_THREE:

keyEF153_THREESUB:NOP                   

;keyEF154_THREE:
       
keyEF154_THREESUB:NOP                    

;keyEF155_THREE:

keyEF155_THREESUB:NOP                   

;keyEF156_THREE:

keyEF156_THREESUB:NOP                    

;keyEF157_THREE:

keyEF157_THREESUB:NOP                  

;keyEF158_THREE:

keyEF158_THREESUB:NOP                    

;keyEF159_THREE:

keyEF159_THREESUB:NOP                   

;keyEF160_THREE:

keyEF160_THREESUB:NOP                   

;keyEF161_THREE: 

keyEF161_THREESUB:NOP                   

;keyEF162_THREE:

keyEF162_THREESUB:NOP                    

;keyEF163_THREE:

keyEF163_THREESUB:NOP                   

;keyEF164_THREE:
       
keyEF164_THREESUB:NOP                    

;keyEF165_THREE:
              
keyEF165_THREESUB:NOP                   

;keyEF166_THREE:

keyEF166_THREESUB:NOP                    

;keyEF167_THREE:

keyEF167_THREESUB:NOP                   

;keyEF168_THREE:

keyEF168_THREESUB:NOP                   

;keyEF169_THREE:

keyEF169_THREESUB:NOP                   

;keyEF170_THREE:

keyEF170_THREESUB:NOP                   

;keyEF171_THREE: 

keyEF171_THREESUB:NOP                   

;keyEF172_THREE:

keyEF172_THREESUB:NOP                    

;keyEF173_THREE:

keyEF173_THREESUB:NOP                   

;keyEF174_THREE:
       
keyEF174_THREESUB:NOP                    

;keyEF175_THREE:

keyEF175_THREESUB:NOP                   

;keyEF176_THREE:

keyEF176_THREESUB:NOP                    

;keyEF177_THREE:

keyEF177_THREESUB:NOP                   

;keyEF178_THREE:

keyEF178_THREESUB:NOP                    

;keyEF179_THREE:

keyEF179_THREESUB:NOP                   

;keyEF180_THREE:

keyEF180_THREESUB:NOP                   

;keyEF181_THREE: 

keyEF181_THREESUB:NOP                   

;keyEF182_THREE:

keyEF182_THREESUB:NOP                    

;keyEF183_THREE:

keyEF183_THREESUB:NOP                   

;keyEF184_THREE:
       
keyEF184_THREESUB:NOP                    

;keyEF185_THREE:

keyEF185_THREESUB:NOP                   

;keyEF186_THREE:

keyEF186_THREESUB:NOP                   

;keyEF187_THREE:

keyEF187_THREESUB:NOP                   

;keyEF188_THREE:

keyEF188_THREESUB:NOP                    

;keyEF189_THREE:

keyEF189_THREESUB:NOP                   

;keyEF190_THREE:

keyEF190_THREESUB:NOP                   

;keyEF191_THREE: 

keyEF191_THREESUB:NOP                   

;keyEF192_THREE:

keyEF192_THREESUB:NOP                   

;keyEF193_THREE:

keyEF193_THREESUB:NOP                   

;keyEF194_THREE:
       
keyEF194_THREESUB:NOP                    

;keyEF195_THREE:

keyEF195_THREESUB:NOP                   

;keyEF196_THREE:

keyEF196_THREESUB:NOP                    

;keyEF197_THREE:

keyEF197_THREESUB:NOP                   

;keyEF198_THREE:

keyEF198_THREESUB:NOP                    

;keyEF199_THREE:

keyEF199_THREESUB:NOP                   

;keyEF200_THREE: 

keyEF200_THREESUB:NOP                   

;keyEF201_THREE: 

keyEF201_THREESUB:NOP                   

;keyEF202_THREE:

keyEF202_THREESUB:NOP                   
     
;keyEF203_THREE:

keyEF203_THREESUB:NOP                   

;keyEF204_THREE:

keyEF204_THREESUB:NOP                   

;keyEF205_THREE:

keyEF205_THREESUB:NOP                   

;keyEF206_THREE:

keyEF206_THREESUB:NOP                   

;keyEF207_THREE:

keyEF207_THREESUB:NOP                   

;keyEF208_THREE:

keyEF208_THREESUB:NOP                   

;keyEF209_THREE:

keyEF209_THREESUB:NOP                   

;keyEF210_THREE: 

keyEF210_THREESUB:NOP                   

;keyEF211_THREE: 

keyEF211_THREESUB:NOP                   
              
;keyEF212_THREE:

keyEF212_THREESUB:NOP                   

;keyEF213_THREE:

keyEF213_THREESUB:NOP                   

;keyEF214_THREE:

keyEF214_THREESUB:NOP                   

;keyEF215_THREE:

keyEF215_THREESUB:NOP                   

;keyEF216_THREE:

keyEF216_THREESUB:NOP                    

;keyEF217_THREE:

keyEF217_THREESUB:NOP                   

;keyEF218_THREE:

keyEF218_THREESUB:NOP                    

;keyEF219_THREE:

keyEF219_THREESUB:NOP                      

;keyEF220_THREE: 

keyEF220_THREESUB:NOP                   

;keyEF221_THREE: 

keyEF221_THREESUB:NOP                   

;keyEF222_THREE:

keyEF222_THREESUB:NOP                   

;keyEF223_THREE:

keyEF223_THREESUB:NOP                   

;keyEF224_THREE:

keyEF224_THREESUB:NOP                    

;keyEF225_THREE:

keyEF225_THREESUB:NOP                   

;keyEF226_THREE:

keyEF226_THREESUB:NOP                   

;keyEF227_THREE:

keyEF227_THREESUB:NOP                   

;keyEF228_THREE:

keyEF228_THREESUB:NOP                   

;keyEF229_THREE:

keyEF229_THREESUB:NOP                   

;keyEF230_THREE: 

keyEF230_THREESUB:NOP                   

;keyEF231_THREE: 

keyEF231_THREESUB:NOP                   

;keyEF232_THREE:

keyEF232_THREESUB:NOP                    

;keyEF233_THREE:

keyEF233_THREESUB:NOP                   

;keyEF234_THREE:

keyEF234_THREESUB:NOP                   

;keyEF235_THREE:

keyEF235_THREESUB:NOP                   

;keyEF236_THREE:

keyEF236_THREESUB:NOP                    

;keyEF237_THREE:

keyEF237_THREESUB:NOP                   

;keyEF238_THREE:

keyEF238_THREESUB:NOP                    

;keyEF239_THREE:

keyEF239_THREESUB:NOP                    

;keyEF240_THREE: 

keyEF240_THREESUB:NOP                   

;keyEF241_THREE: 

keyEF241_THREESUB:NOP                   

;keyEF242_THREE:

keyEF242_THREESUB:NOP                    

;keyEF243_THREE:

keyEF243_THREESUB:NOP                   

;keyEF244_THREE:
       
keyEF244_THREESUB:NOP                   

;keyEF245_THREE:

keyEF245_THREESUB:NOP                   

;keyEF246_THREE:

keyEF246_THREESUB:NOP                    

;keyEF247_THREE:

keyEF247_THREESUB:NOP                   

;keyEF248_THREE:

keyEF248_THREESUB:NOP                   

;keyEF249_THREE:

keyEF249_THREESUB:NOP                   

;keyEF250_THREE:

keyEF250_THREESUB:NOP                   

;keyEF251_THREE: 

keyEF251_THREESUB:NOP                   

;keyEF252_THREE:

keyEF252_THREESUB:NOP                    

;keyEF253_THREE:

keyEF253_THREESUB:NOP                   

;keyEF254_THREE:
       
keyEF254_THREESUB:NOP                    

;keyEF255_THREE:

keyEF255_THREESUB:NOP                   

;*********Program edit mode Instruction Table********

Abs           DC.B $00, $00, $00, $7F, $7F, $00, $00, $00     ;|
              DC.B $00, $63, $77, $1C, $1C, $77, $63, $00	    ;X 
              DC.B $00, $00, $00, $7F, $7F, $00, $00, $00     ;|

ACH           DC.B $00, $38, $7C, $44, $44, $6C, $28, $00	    ;c
              DC.B $00, $38, $7C, $44, $44, $7C, $38, $00    	;o
              DC.B $00, $48, $5C, $54, $54, $74, $24, $00   	;s
              DC.B $00, $7F, $7F, $08, $04, $7C, $78, $00	    ;h
              DC.B $04, $04, $02, $1F, $1F, $00, $00, $00	    ;^-1
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x 
              
Arccosx       DC.B $00, $38, $7C, $44, $44, $6C, $28, $00	    ;c
              DC.B $00, $38, $7C, $44, $44, $7C, $38, $00    	;o
              DC.B $00, $48, $5C, $54, $54, $74, $24, $00   	;s
              DC.B $04, $04, $02, $1F, $1F, $00, $00, $00	    ;^-1
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x
              
Arcsinx       DC.B $00, $48, $5C, $54, $54, $74, $24, $00   	;s
              DC.B $00, $00, $00, $7D, $7D, $00, $00, $00	    ;i
              DC.B $00, $7C, $7C, $04, $04, $7C, $78, $00    	;n
              DC.B $04, $04, $02, $1F, $1F, $00, $00, $00	    ;^-1
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x    
                   
Arctanx       DC.B $00, $04, $3F, $7F, $44, $24, $00, $00	    ;t
              DC.B $00, $20, $74, $54, $54, $3C, $78, $00	    ;a
              DC.B $00, $7C, $7C, $04, $04, $7C, $78, $00    	;n
              DC.B $04, $04, $02, $1F, $1F, $00, $00, $00	    ;^-1
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x

Arrow2        DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

ASH           DC.B $00, $48, $5C, $54, $54, $74, $24, $00   	;s
              DC.B $00, $00, $00, $7D, $7D, $00, $00, $00	    ;i
              DC.B $00, $7C, $7C, $04, $04, $7C, $78, $00    	;n
              DC.B $00, $7F, $7F, $08, $04, $7C, $78, $00	    ;h
              DC.B $04, $04, $02, $1F, $1F, $00, $00, $00	    ;^-1
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x

ATH           DC.B $00, $04, $3F, $7F, $44, $24, $00, $00	    ;t
              DC.B $00, $20, $74, $54, $54, $3C, $78, $00	    ;a
              DC.B $00, $7C, $7C, $04, $04, $7C, $78, $00    	;n
              DC.B $00, $7F, $7F, $08, $04, $7C, $78, $00	    ;h
              DC.B $04, $04, $02, $1F, $1F, $00, $00, $00	    ;^-1
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x              

BON           DC.B $00, $7F, $7F, $49, $49, $7F, $36, $00     ;B
              DC.B $00, $3F, $7F, $40, $40, $7F, $7F, $00	    ;U  
              DC.B $00, $26, $6F, $4D, $59, $73, $32, $00	    ;S 
              DC.B $00, $07, $0F, $78, $78, $0F, $07, $00	    ;Y 
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O  
              DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N

BOF           DC.B $00, $7F, $7F, $49, $49, $7F, $36, $00     ;B
              DC.B $00, $3F, $7F, $40, $40, $7F, $7F, $00	    ;U  
              DC.B $00, $26, $6F, $4D, $59, $73, $32, $00	    ;S 
              DC.B $00, $07, $0F, $78, $78, $0F, $07, $00	    ;Y 
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O
              DC.B $00, $7F, $7F, $09, $09, $01, $01, $00   	;F
              DC.B $00, $7F, $7F, $09, $09, $01, $01, $00   	;F

EON           DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E 
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R 
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R 
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R 
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O  
              DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N       

EOF           DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E 
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R 
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R 
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R 
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O
              DC.B $00, $7F, $7F, $09, $09, $01, $01, $00   	;F
              DC.B $00, $7F, $7F, $09, $09, $01, $01, $00   	;F
              
CartZ         DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $7F, $09, $09, $09, $01               ;F
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $09, $09, $09, $01               ;F
              DC.B $00, $61, $51, $49, $45, $43               ;Z

CH            DC.B $00, $38, $7C, $44, $44, $6C, $28, $00	    ;c
              DC.B $00, $38, $7C, $44, $44, $7C, $38, $00    	;o
              DC.B $00, $48, $5C, $54, $54, $74, $24, $00   	;s
              DC.B $00, $7F, $7F, $08, $04, $7C, $78, $00	    ;h
              DC.B $00, $00, $00, $00, $00, $00, $00, $00     ;
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x
              
Clear         DC.B $1C, $3E, $63, $41, $41, $63, $22, $00     ;C
              DC.B $00, $7F, $7F, $40, $40, $40, $40, $00	    ;L
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R

CB            DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7F, $49, $49, $49, $36               ;B
              DC.B $00, $00, $41, $7F, $41, $00               ;I
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $00, $41, $7F, $41, $00               ;I
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $04, $08, $10, $7F               ;N

Clg           DC.B $00, $00, $00, $7F, $7F, $01, $01, $01     ;|..
              DC.B $00, $63, $77, $1C, $1C, $77, $63, $00	    ;X 
              DC.B $01, $01, $01, $7F, $7F, $00, $00, $00     ;..|

Cosx          DC.B $00, $38, $7C, $44, $44, $6C, $28, $00	    ;c
              DC.B $00, $38, $7C, $44, $44, $7C, $38, $00    	;o
              DC.B $00, $48, $5C, $54, $54, $74, $24, $00   	;s
              DC.B $00, $00, $00, $00, $00, $00, $00, $00     ;
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x

CZ            DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $20, $40, $41, $3F, $01               ;J
              DC.B $00, $3F, $40, $40, $40, $3F               ;U              
              DC.B $00, $3E, $41, $49, $49, $7A               ;G
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $09, $09, $09, $01               ;F
              DC.B $00, $61, $51, $49, $45, $43               ;Z
                            
DecK2         DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $7F, $08, $14, $22, $41               ;K

Del2          DC.B $00, $7F, $7F, $41, $63, $3E, $1C, $00	    ;D
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7F, $7F, $40, $40, $40, $40, $00	    ;L
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $62, $73, $59, $49, $4F, $46, $00, $00	    ;2 
              
Del3          DC.B $00, $7F, $7F, $41, $63, $3E, $1C, $00	    ;D
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7F, $7F, $40, $40, $40, $40, $00	    ;L
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $22, $63, $49, $49, $7F, $36, $00, $00	    ;3 
              
Delete        DC.B $00, $7F, $7F, $41, $63, $3E, $1C, $00	    ;D
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7F, $7F, $40, $40, $40, $40, $00	    ;L
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E 
              
DispEr        DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $00, $41, $7F, $41, $00               ;I
              DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $7F, $09, $09, $09, $06               ;P
              DC.B $00, $7F, $40, $40, $40, $40               ;L
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $07, $08, $70, $08, $07               ;Y
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $09, $19, $29, $46               ;R             

Dly           DC.B $00, $7F, $7F, $41, $63, $3E, $1C, $00	    ;D
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7F, $7F, $40, $40, $40, $40, $00	    ;L
              DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A
              DC.B $00, $07, $0F, $78, $78, $0F, $07, $00	    ;Y
              DC.B $00, $7F, $7F, $08, $1C, $77, $63, $00	    ;K

Dph           DC.B $00, $7F, $7F, $41, $63, $3E, $1C, $00	    ;D
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7F, $7F, $09, $09, $0F, $06, $00	    ;P
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7F, $7F, $08, $08, $7F, $7F, $00    	;H
    
End2          DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N
              DC.B $00, $7F, $7F, $41, $63, $3E, $1C, $00	    ;D

Enter         DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R
              
Enter2        DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R
              DC.B $62, $73, $59, $49, $4F, $46, $00, $00	    ;2
              
Enter3        DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R
              DC.B $22, $63, $49, $49, $7F, $36, $00, $00	    ;3
              
Enter4        DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R
              DC.B $18, $1C, $16, $13, $7F, $7F, $10, $00	    ;4
              
Ex            DC.B $00, $38, $7C, $54, $54, $5C, $18, $00    	;e
              DC.B $11, $1B, $0E, $04, $0E, $1B, $11, $00   	;^x 
              
Exp           DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $00, $63, $77, $1C, $1C, $77, $63, $00	    ;X 
              DC.B $00, $7F, $7F, $09, $09, $0F, $06, $00	    ;P

Fac           DC.B $00, $00, $00, $5F, $5F, $00, $00, $00	    ;!

Fix           DC.B $00, $7F, $7F, $09, $09, $01, $01, $00   	;F
              DC.B $00, $00, $00, $7F, $7F, $00, $00, $00	    ;I
              DC.B $00, $63, $77, $1C, $1C, $77, $63, $00	    ;X

Flr           DC.B $00, $00, $00, $7F, $7F, $40, $40, $40     ;|..
              DC.B $00, $63, $77, $1C, $1C, $77, $63, $00	    ;X 
              DC.B $40, $40, $40, $7F, $7F, $00, $00, $00     ;..|
              
GCD           DC.B $1C, $3E, $63, $41, $51, $73, $72, $00    	;G
              DC.B $1C, $3E, $63, $41, $41, $63, $22, $00     ;C
              DC.B $00, $7F, $7F, $41, $63, $3E, $1C, $00	    ;D
              DC.B $00, $1C, $3E, $63, $41, $00, $00, $00	    ;(
              DC.B $00, $20, $74, $54, $54, $3C, $78, $00	    ;a
              DC.B $00, $80, $E0, $60, $00, $00, $00, $00   	;,
              DC.B $00, $7F, $3F, $48, $48, $78, $30, $00	    ;b
              DC.B $00, $41, $63, $3E, $1C, $00, $00, $00	    ;)

GotoIf        DC.B $1C, $3E, $63, $41, $51, $73, $72, $00    	;G
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O 
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O
              DC.B $00, $00, $00, $7F, $7F, $00, $00, $00	    ;I
              DC.B $00, $7F, $7F, $09, $09, $01, $01, $00   	;F
              
Goto0         DC.B $24, $24, $24, $24, $24, $24, $00, $00	    ;=
              DC.B $3E, $7F, $71, $59, $4D, $7F, $3E, $00	    ;0
              
GotoCE        DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7F, $09, $09, $09, $06               ;P

GotoN0        DC.B $24, $24, $7F, $7F, $24, $24, $00, $00	    ;<>
              DC.B $3E, $7F, $71, $59, $4D, $7F, $3E, $00	    ;0

GotoGE        DC.B $00, $41, $63, $36, $1C, $08, $00, $00    	;>
              DC.B $24, $24, $24, $24, $24, $24, $00, $00	    ;= 
              
GotoLE        DC.B $08, $1C, $36, $63, $41, $00, $00, $00	    ;<
              DC.B $24, $24, $24, $24, $24, $24, $00, $00	    ;= 

GotoIfSL      DC.B $00, $3E, $41, $49, $49, $7A               ;G
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $00, $41, $7F, $41, $00               ;I
              DC.B $00, $7F, $09, $09, $09, $01               ;F

GotoEx        DC.B $00, $14, $14, $14, $14, $14               ;=
              DC.B $00, $44, $28, $10, $28, $44               ;x
              DC.B $00, $00, $1C, $22, $41, $00               ;(
              DC.B $00, $7F, $08, $14, $22, $41               ;K
              DC.B $00, $00, $41, $22, $1C, $00               ;)
              
GotoNEx       DC.B $00, $14, $14, $7F, $14, $14               ;<>
              DC.B $00, $44, $28, $10, $28, $44               ;x
              DC.B $00, $00, $1C, $22, $41, $00               ;(
              DC.B $00, $7F, $08, $14, $22, $41               ;K
              DC.B $00, $00, $41, $22, $1C, $00               ;)

GotoGEx       DC.B $00, $00, $41, $22, $14, $08               ;>
              DC.B $00, $14, $14, $14, $14, $14               ;=
              DC.B $00, $44, $28, $10, $28, $44               ;x
              DC.B $00, $00, $1C, $22, $41, $00               ;(
              DC.B $00, $7F, $08, $14, $22, $41               ;K
              DC.B $00, $00, $41, $22, $1C, $00               ;)
              
GotoLEx       DC.B $00, $00, $08, $14, $22, $41               ;<
              DC.B $00, $14, $14, $14, $14, $14               ;=
              DC.B $00, $44, $28, $10, $28, $44               ;x
              DC.B $00, $00, $1C, $22, $41, $00               ;(
              DC.B $00, $7F, $08, $14, $22, $41               ;K
              DC.B $00, $00, $41, $22, $1C, $00               ;) 
              
GotoKP        DC.B $00, $7F, $08, $14, $22, $41               ;K
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $07, $08, $70, $08, $07               ;Y 
              DC.B $00, $7F, $09, $09, $09, $06               ;P
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $46, $49, $49, $49, $31               ;S
             
Halt2         DC.B $00, $7F, $7F, $08, $08, $7F, $7F, $00    	;H 
              DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A
              DC.B $00, $7F, $7F, $40, $40, $40, $40, $00	    ;L
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T

IncK2         DC.B $00, $00, $41, $7F, $41, $00               ;I
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $7F, $08, $14, $22, $41               ;K
              
JTS           DC.B $00, $20, $40, $41, $3F, $01               ;J
              DC.B $00, $3F, $40, $40, $40, $3F               ;U
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7F, $09, $09, $09, $06               ;P   
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $3E, $41, $41, $41, $3E               ;O              
              DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $3F, $40, $40, $40, $3F               ;U
              DC.B $00, $7F, $49, $49, $49, $36               ;B
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $7F, $49, $49, $49, $41               ;E           

LCM           DC.B $00, $7F, $7F, $40, $40, $40, $40, $00	    ;L
              DC.B $1C, $3E, $63, $41, $41, $63, $22, $00     ;C
              DC.B $7F, $7F, $0E, $1C, $0E, $7F, $7F, $00	    ;M
              DC.B $00, $1C, $3E, $63, $41, $00, $00, $00	    ;(
              DC.B $00, $20, $74, $54, $54, $3C, $78, $00	    ;a
              DC.B $00, $80, $E0, $60, $00, $00, $00, $00   	;,
              DC.B $00, $7F, $3F, $48, $48, $78, $30, $00	    ;b
              DC.B $00, $41, $63, $3E, $1C, $00, $00, $00	    ;)

Ld            DC.B $00, $00, $00, $7F, $7F, $00, $00, $00	    ;l 
              DC.B $00, $30, $78, $48, $48, $3F, $7F, $00	    ;d
              DC.B $00, $00, $00, $00, $00, $00, $00, $00     ;
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x
              
Lg            DC.B $00, $00, $00, $7F, $7F, $00, $00, $00	    ;l 
              DC.B $00, $38, $7C, $44, $44, $7C, $38, $00    	;o
              DC.B $00, $18, $BC, $A4, $A4, $F8, $7C, $00	    ;g
              DC.B $00, $00, $00, $00, $00, $00, $00, $00     ;
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x            
              
Ln            DC.B $00, $00, $00, $7F, $7F, $00, $00, $00	    ;l 
              DC.B $00, $7C, $7C, $04, $04, $7C, $78, $00    	;n
              DC.B $00, $00, $00, $00, $00, $00, $00, $00     ;
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x 

meanx         DC.B $45, $6D, $39, $11, $39, $6D, $45, $00     ;x bar  

ModZ          DC.B $00, $00, $00, $7F, $7F, $00, $00, $00     ;|
              DC.B $41, $61, $71, $59, $4D, $47, $43, $00   	;Z
              DC.B $00, $00, $00, $7F, $7F, $00, $00, $00     ;|

MultS         DC.B $08, $2A, $3E, $1C, $1C, $3E, $2A, $08   	;*

Neg           DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $1C, $3E, $63, $41, $51, $73, $72, $00    	;G
              DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T              
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E              

noOp          DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O
              DC.B $00, $7F, $7F, $09, $09, $0F, $06, $00	    ;P

OneX          DC.B $00, $02, $7F, $7F, $00, $00, $00, $00	    ;1
              DC.B $60, $30, $18, $0C, $06, $03, $01, $00	    ;/
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x
              
Over          DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O  
              DC.B $00, $1F, $3F, $60, $60, $3F, $1F, $00	    ;V
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E 
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R
 
PR            DC.B $00, $7F, $09, $09, $09, $06               ;P
              DC.B $00, $7F, $49, $49, $49, $41               ;E  
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $3F, $40, $40, $40, $3F               ;U
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $00, $41, $7F, $41, $00               ;I
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $04, $08, $10, $7F               ;N 

Pi            DC.B $00, $7F, $7F, $01, $01, $7F, $7F, $00	    ;pi

Pick2         DC.B $00, $7F, $7F, $09, $09, $0F, $06, $00	    ;P
              DC.B $00, $00, $00, $7F, $7F, $00, $00, $00	    ;I
              DC.B $1C, $3E, $63, $41, $41, $63, $22, $00     ;C
              DC.B $00, $7F, $7F, $08, $1C, $77, $63, $00	    ;K
              
PZ            DC.B $00, $7F, $09, $09, $09, $06               ;P 
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $40, $40, $40, $40               ;L
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $09, $09, $09, $01               ;F
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $3E, $41, $41, $41, $3E               ;O
              DC.B $00, $7F, $09, $09, $09, $01               ;F
              DC.B $00, $61, $51, $49, $45, $43               ;Z
              
RclA          DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A   
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclB          DC.B $00, $7F, $7F, $49, $49, $7F, $36, $00	    ;B
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclC          DC.B $1C, $3E, $63, $41, $41, $63, $22, $00     ;C  
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclD          DC.B $00, $7F, $7F, $41, $63, $3E, $1C, $00	    ;D
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              
RclE          DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclF          DC.B $00, $7F, $7F, $09, $09, $01, $01, $00   	;F
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclG          DC.B $1C, $3E, $63, $41, $51, $73, $72, $00	    ;G 
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclH          DC.B $00, $7F, $7F, $08, $08, $7F, $7F, $00    	;H 
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclI          DC.B $00, $00, $00, $7F, $7F, $00, $00, $00	    ;I  
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclJ          DC.B $00, $30, $70, $40, $40, $7F, $3F, $00	    ;J
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              
RclK          DC.B $00, $7F, $7F, $08, $1C, $77, $63, $00	    ;K 
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclL          DC.B $00, $7F, $7F, $40, $40, $40, $40, $00    	;L
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclM          DC.B $7F, $7F, $0E, $1C, $0E, $7F, $7F, $00	    ;M 
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclN          DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclO          DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O 
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclP          DC.B $00, $7F, $7F, $09, $09, $0F, $06, $00	    ;P
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              
RclQ          DC.B $00, $1E, $3F, $21, $71, $7F, $5E, $00	    ;Q 
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclR          DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R 
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclS          DC.B $00, $26, $6F, $4D, $59, $73, $32, $00	    ;S  
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclT          DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclU          DC.B $00, $3F, $7F, $40, $40, $7F, $7F, $00	    ;U  
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclV          DC.B $00, $1F, $3F, $60, $60, $3F, $1F, $00	    ;V
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              
RclW          DC.B $7F, $7F, $30, $18, $30, $7F, $7F, $00	    ;W 
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclX          DC.B $00, $63, $77, $1C, $1C, $77, $63, $00	    ;X
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclY          DC.B $00, $07, $0F, $78, $78, $0F, $07, $00	    ;Y 
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->

RclZ          DC.B $41, $61, $71, $59, $4D, $47, $43, $00   	;Z
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              
RclKN         DC.B $00, $7F, $08, $14, $22, $41               ;K
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $07, $08, $70, $08, $07               ;Y
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $3F, $40, $40, $40, $3F               ;U
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7F, $49, $49, $49, $36               ;B
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $08, $08, $3E, $1C, $08               ;->

RclxK         DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x
              DC.B $00, $1C, $3E, $63, $41, $00, $00, $00	    ;(
              DC.B $00, $7F, $7F, $08, $1C, $77, $63, $00	    ;K
              DC.B $00, $41, $63, $3E, $1C, $00, $00, $00	    ;)
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              
RclyK         DC.B $00, $1C, $BC, $A0, $A0, $FC, $7C, $00   	;y
              DC.B $00, $1C, $3E, $63, $41, $00, $00, $00	    ;(
              DC.B $00, $7F, $7F, $08, $1C, $77, $63, $00	    ;K
              DC.B $00, $41, $63, $3E, $1C, $00, $00, $00	    ;)
              DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              
RFS           DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $7F, $09, $09, $09, $01               ;F
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $3F, $40, $40, $40, $3F               ;U
              DC.B $00, $7F, $49, $49, $49, $36               ;B
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $7F, $49, $49, $49, $41               ;E

RND           DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $3E, $41, $41, $41, $3E               ;O              
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M              
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $3F, $40, $40, $40, $3F               ;U
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7F, $49, $49, $49, $36               ;B
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              
RNDSD         DC.B $18, $18, $18, $5A, $3C, $18               ;->
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $3E, $41, $41, $41, $3E               ;O              
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $14, $7F, $14, $7F, $14               ;#
              DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $41, $41, $22, $1C               ;D              

Rot           DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A 
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E 
              
RToC          DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $40, $40, $40, $40               ;L	
              DC.B $18, $18, $18, $5A, $3C, $18               ;->
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $3E, $41, $41, $41, $3E               ;O 
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7F, $09, $09, $09, $06               ;P 
              DC.B $00, $7F, $40, $40, $40, $40               ;L              
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $63, $14, $08, $14, $63               ;X

ScanKP        DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $04, $08, $10, $7F               ;N              
              DC.B $00, $7F, $08, $14, $22, $41               ;K
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $07, $08, $70, $08, $07               ;Y 
              DC.B $00, $7F, $09, $09, $09, $06               ;P
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $41, $41, $22, $1C               ;D
              
Sett          DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $7F, $49, $49, $49, $41               ;E 
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              
Mode          DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $3E, $41, $41, $41, $3E               ;O 
              DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $7F, $49, $49, $49, $41               ;E

SDegMode      DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $3E, $41, $49, $49, $7A               ;G              
              
SRadMode      DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $41, $41, $22, $1C               ;D              
              
SGraMode      DC.B $00, $3E, $41, $49, $49, $7A               ;G
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              
SDecMode      DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              
SSciMode      DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $3E, $41, $41, $41, $22               ;C 
              DC.B $00, $00, $41, $7F, $41, $00               ;I
              
SHexMode      DC.B $00, $7F, $08, $08, $08, $7F               ;H
              DC.B $00, $7F, $49, $49, $49, $41               ;E 
              DC.B $00, $63, $14, $08, $14, $63               ;X
              
SBinMode      DC.B $00, $7F, $49, $49, $49, $36               ;B
              DC.B $00, $00, $41, $7F, $41, $00               ;I 
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
 
SApxMode      DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $09, $09, $09, $06               ;P    
              DC.B $00, $63, $14, $08, $14, $63               ;X              
              
SExtMode      DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $63, $14, $08, $14, $63               ;X    
              DC.B $00, $01, $01, $7F, $01, $01               ;T              
                            
SCpxMode      DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $7F, $09, $09, $09, $06               ;P    
              DC.B $00, $63, $14, $08, $14, $63               ;X
              
SEngMode      DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7F, $04, $08, $10, $7F               ;N    
              DC.B $00, $3E, $41, $49, $49, $7A               ;G
 
SH            DC.B $00, $48, $5C, $54, $54, $74, $24, $00   	;s
              DC.B $00, $00, $00, $7D, $7D, $00, $00, $00	    ;i
              DC.B $00, $7C, $7C, $04, $04, $7C, $78, $00    	;n
              DC.B $00, $7F, $7F, $08, $04, $7C, $78, $00	    ;h
              DC.B $00, $00, $00, $00, $00, $00, $00, $00     ;
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x
              
Sinx          DC.B $00, $48, $5C, $54, $54, $74, $24, $00   	;s
              DC.B $00, $00, $00, $7D, $7D, $00, $00, $00	    ;i
              DC.B $00, $7C, $7C, $04, $04, $7C, $78, $00    	;n
              DC.B $00, $00, $00, $00, $00, $00, $00, $00     ;
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x
              
Sqr           DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x 
              DC.B $00, $12, $19, $15, $12, $00, $00, $00	    ;^2

Sqrt          DC.B $10, $30, $60, $C0, $70, $1C, $07, $01     ;square root
              DC.B $45, $6D, $39, $11, $39, $6D, $45, $00     ;x bar              

StoA          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A  
              
StoB          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $7F, $7F, $49, $49, $7F, $36, $00	    ;B

StoC          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $1C, $3E, $63, $41, $41, $63, $22, $00     ;C 
              
StoD          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $7F, $7F, $41, $63, $3E, $1C, $00	    ;D

StoE          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E 
              
StoF          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $7F, $7F, $09, $09, $01, $01, $00   	;F

StoG          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $1C, $3E, $63, $41, $51, $73, $72, $00	    ;G 
              
StoH          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $7F, $7F, $08, $08, $7F, $7F, $00    	;H 

StoI          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $00, $00, $7F, $7F, $00, $00, $00	    ;I
              
StoJ          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $30, $70, $40, $40, $7F, $3F, $00	    ;J

StoK          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $7F, $7F, $08, $1C, $77, $63, $00	    ;K
              
StoL          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $7F, $7F, $40, $40, $40, $40, $00    	;L

StoM          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $7F, $7F, $0E, $1C, $0E, $7F, $7F, $00	    ;M 
              
StoN          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N

StoO          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O  
              
StoP          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $7F, $7F, $09, $09, $0F, $06, $00	    ;P

StoQ          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $1E, $3F, $21, $71, $7F, $5E, $00	    ;Q
              
StoR          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R 

StoS          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $26, $6F, $4D, $59, $73, $32, $00	    ;S 
              
StoT          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T

StoU          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $3F, $7F, $40, $40, $7F, $7F, $00	    ;U  
              
StoV          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $1F, $3F, $60, $60, $3F, $1F, $00	    ;V

StoW          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $7F, $7F, $30, $18, $30, $7F, $7F, $00	    ;W 
              
StoX          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $63, $77, $1C, $1C, $77, $63, $00	    ;X

StoY          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $00, $07, $0F, $78, $78, $0F, $07, $00	    ;Y 
              
StoZ          DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->
              DC.B $41, $61, $71, $59, $4D, $47, $43, $00   	;Z
              
StoxK         DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->  
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x
              DC.B $00, $1C, $3E, $63, $41, $00, $00, $00	    ;(
              DC.B $00, $7F, $7F, $08, $1C, $77, $63, $00	    ;K
              DC.B $00, $41, $63, $3E, $1C, $00, $00, $00	    ;)
              
StoyK         DC.B $08, $08, $08, $2A, $3E, $1C, $08, $00	    ;->  
              DC.B $00, $1C, $BC, $A0, $A0, $FC, $7C, $00   	;y
              DC.B $00, $1C, $3E, $63, $41, $00, $00, $00	    ;(
              DC.B $00, $7F, $7F, $08, $1C, $77, $63, $00	    ;K
              DC.B $00, $41, $63, $3E, $1C, $00, $00, $00	    ;)                                       
 
Swap          DC.B $00, $26, $6F, $4D, $59, $73, $32, $00	    ;S
              DC.B $7F, $7F, $30, $18, $30, $7F, $7F, $00	    ;W
              DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A
              DC.B $00, $7F, $7F, $09, $09, $0F, $06, $00	    ;P
              
Tanx          DC.B $00, $04, $3F, $7F, $44, $24, $00, $00	    ;t
              DC.B $00, $20, $74, $54, $54, $3C, $78, $00	    ;a
              DC.B $00, $7C, $7C, $04, $04, $7C, $78, $00    	;n
              DC.B $00, $00, $00, $00, $00, $00, $00, $00     ;
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x 

TBI           DC.B $00, $42, $61, $51, $49, $46               ;2
              DC.B $00, $7F, $49, $49, $49, $36               ;B
              DC.B $00, $07, $08, $70, $08, $07               ;Y
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $00, $41, $7F, $41, $00               ;I
              DC.B $00, $7F, $04, $08, $10, $7F               ;N
              DC.B $00, $46, $49, $49, $49, $31               ;S
              DC.B $00, $01, $01, $7F, $01, $01               ;T
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $3F, $40, $40, $40, $3F               ;U
              DC.B $00, $3E, $41, $41, $41, $22               ;C 
              
Tenx          DC.B $00, $02, $7F, $7F, $00, $00, $00, $00	    ;1
              DC.B $3E, $7F, $71, $59, $4D, $7F, $3E, $00	    ;0              
              DC.B $11, $1B, $0E, $04, $0E, $1B, $11, $00   	;^x

TH            DC.B $00, $04, $3F, $7F, $44, $24, $00, $00	    ;t
              DC.B $00, $20, $74, $54, $54, $3C, $78, $00	    ;a
              DC.B $00, $7C, $7C, $04, $04, $7C, $78, $00    	;n
              DC.B $00, $7F, $7F, $08, $04, $7C, $78, $00	    ;h
              DC.B $00, $00, $00, $00, $00, $00, $00, $00     ;
              DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x

Tmron         DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $00, $00, $7F, $7F, $00, $00, $00	    ;I
              DC.B $7F, $7F, $0E, $1C, $0E, $7F, $7F, $00	    ;M
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E 
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00	    ;O
              DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00   	;N

Tmroff        DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $00, $00, $7F, $7F, $00, $00, $00	    ;I
              DC.B $7F, $7F, $0E, $1C, $0E, $7F, $7F, $00	    ;M
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E 
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00	    ;O
              DC.B $00, $7F, $7F, $09, $09, $01, $01, $00	    ;F
              DC.B $00, $7F, $7F, $09, $09, $01, $01, $00	    ;F
              
ToDMS         DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $00, $41, $7F, $41, $00               ;I
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $40, $40, $40, $40               ;L
              DC.B $18, $18, $18, $5A, $3C, $18               ;->
              DC.B $00, $0C, $1E, $12, $1E, $0C         	    ;degree symbol
              DC.B $00, $00, $00, $00, $00, $07               ;'
              DC.B $00, $00, $00, $07, $00, $07               ;"              
              
DMSTo         DC.B $00, $0C, $1E, $12, $1E, $0C         	    ;degree symbol
              DC.B $00, $00, $00, $00, $00, $07               ;'
              DC.B $00, $00, $00, $07, $00, $07               ;"        
              DC.B $18, $18, $18, $5A, $3C, $18               ;->
              DC.B $00, $7F, $41, $41, $22, $1C               ;D
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $00, $41, $7F, $41, $00               ;I
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $40, $40, $40, $40               ;L

CToR          DC.B $00, $3E, $41, $41, $41, $22               ;C
              DC.B $00, $3E, $41, $41, $41, $3E               ;O 
              DC.B $00, $7F, $02, $0C, $02, $7F               ;M
              DC.B $00, $7F, $09, $09, $09, $06               ;P 
              DC.B $00, $7F, $40, $40, $40, $40               ;L              
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $63, $14, $08, $14, $63               ;X
              DC.B $18, $18, $18, $5A, $3C, $18               ;->
              DC.B $00, $7F, $09, $19, $29, $46               ;R
              DC.B $00, $7F, $49, $49, $49, $41               ;E
              DC.B $00, $7C, $12, $11, $12, $7C               ;A
              DC.B $00, $7F, $40, $40, $40, $40               ;L

Twox          DC.B $62, $73, $59, $49, $4F, $46, $00, $00	    ;2           
              DC.B $11, $1B, $0E, $04, $0E, $1B, $11, $00   	;^x

Urt           DC.B $00, $3F, $7F, $40, $40, $7F, $7F, $00	    ;U  
              DC.B $7F, $7F, $06, $0C, $18, $7F, $7F, $00	    ;N
              DC.B $00, $7F, $7F, $09, $19, $7F, $66, $00	    ;R  
              DC.B $00, $3E, $7F, $41, $41, $7F, $3E, $00   	;O  
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7C, $7E, $13, $13, $7E, $7C, $00     ;A                
              DC.B $00, $01, $01, $7F, $7F, $01, $01, $00	    ;T
              DC.B $00, $7F, $7F, $49, $49, $41, $41, $00	    ;E 

Xy            DC.B $44, $6C, $38, $10, $38, $6C, $44, $00	    ;x 
              DC.B $00, $00, $07, $2F, $28, $28, $3F, $1F     ;^y
              
Y1x           DC.B $11, $1B, $0E, $04, $0E, $1B, $11, $00   	;^x
              DC.B $10, $30, $60, $C0, $70, $1C, $07, $01     ;square root
              DC.B $00, $1C, $BC, $A0, $A0, $FC, $7C, $00	    ;y
              
;*********End Program edit mode Instruction Table********* 



              

              
              
